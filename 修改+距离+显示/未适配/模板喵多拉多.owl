变量
{
	全局:
		0: Kaiguan
		1: Checkpoints
		2: DesignMode
		3: RestartHourLeft
		4: CheckCampoints
		5: DistanceToPoint
		6: CamSpeed
		7: FaultTimes
		8: MapDesigner
		9: ShareCode
		10: ThanksList
		11: RankList
		12: PlayerList
		13: UnlockFlyNum
		14: HelloTipTime
		15: HelloTipRadius

	玩家:
		0: PlayerName
		1: Invisible
		3: FinishGame
		4: CurrentCheckpoints
		5: CurrentCheckpointNum
		6: CurrentPlayerpoint
		7: Getit
		8: CurrentCheckCampoints
		9: PicNum
		10: TempNum
		11: EditCamMode
		12: EditCampoint
		13: TempCampoint
		14: TempCamSpeed
		15: CamSpeedLevel
		16: AlreadyFaultTimes
		17: HUDdescribe1
		18: HUDdescribe2
		19: HUDdescribe3
		21: CounterI
		22: CurrentRankList
		23: PlayerListpoint
		24: HUDdescribe4
		25: PicView
		26: HUDdescribe5
		27: HUDdescribe6
		28: TeleportE
		29: TeleportENum
		30: ObserverMode
		31: TempHorizontalAngle
		32: TempNum2
		33: HelloTip
		34: FireEffect
		35: GetitEffect
		36: TeleportName
		37: CAIDAN
}

子程序
{
	0: SetInvisible
	2: SetNum
	3: InitialHUDdescribe
	4: RefreshPlayerList
	5: GameStartTeleport
}

规则("------点位粘贴在这里！导出并复制后，点开规则在右边动作里全选清空后按亮黄色按钮粘贴------有问题联系作者，QQ群：581151308")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.Kaiguan = 假;
		全局.Checkpoints = 数组(矢量(-13.566, 1.962, -4.196), 矢量(3.297, 2.428, 6.144), 矢量(61.564, 12.230, -26.489), 矢量(107.976, 12.778, -30.084),
			矢量(130.786, 14.100, 26.014), 矢量(230.037, 16.644, 54.525), 矢量(205.209, 16.251, 32.811), 矢量(184.414, 7.369, 40.721), 矢量(67.843,
			17.376, 42.086), 矢量(66.998, 16.342, 26.031), 矢量(122.952, 7.903, -16.825), 矢量(82.030, 10.327, -50.199), 矢量(-25.127, 6.233,
			11.741), 矢量(10.454, 2.640, -26.446), 矢量(65.030, 10.880, -56.109), 矢量(125.804, 11.028, -27.172), 矢量(148.918, 14.502, 5.088), 矢量(
			197.587, 18.316, 78.817), 矢量(195.477, 16.264, 22.676), 矢量(91.144, 21.579, 17.121), 矢量(83.361, 16.961, 38.793), 矢量(74.693, 13,
			-31.280), 矢量(36.220, 4.170, 8.380), 矢量(16.267, 2.947, -6.773), 矢量(-44.336, 1.213, -25.244), 矢量(26.978, 1.799, 28.061), 矢量(
			106.638, 11.481, 29.025), 矢量(179.526, 9.217, 39.523), 矢量(112.209, 11.818, -34.288), 矢量(-43.620, 27.398, -70.071), 矢量(41.825,
			32.811, -26.133), 矢量(181.940, 40.174, 40.214), 矢量(42.213, 10.421, -33.547), 矢量(-18.155, 11.687, -30.352), 矢量(27.022, 0.188,
			22.319), 矢量(47.268, 7.127, -23.863), 矢量(114.573, 13.168, -30.011), 矢量(158.992, 10.419, -12.040), 矢量(168.511, 14.093, 67.492),
			矢量(208.423, 38.429, 47.570), 矢量(57.904, 14.437, 39.168), 矢量(69.614, 21.301, -54.496), 矢量(185.048, 18.627, 30.635), 矢量(4.535,
			0.623, 12.674), 矢量(-52.971, 8.462, -13.609), 矢量(71.090, 8.400, -28.316), 矢量(176.549, 16.794, 20.289), 矢量(132.941, 25.835,
			41.470), 矢量(-46.274, 14.623, -67.191), 矢量(234.606, 23.277, 49.540));
		全局.DesignMode = 假;
		全局.RestartHourLeft = 3;
		全局.CheckCampoints = 数组(矢量(-12.784, 1.995, -3.573), 矢量(4.187, 1.972, 6.148), 矢量(62.464, 12.012, -26.866), 矢量(107.198, 13.026,
			-30.661), 矢量(130.821, 13.101, 26.025), 矢量(229.077, 16.708, 54.251), 矢量(205.107, 15.258, 32.764), 矢量(184.397, 8.369, 40.716),
			矢量(67.345, 17.958, 42.729), 矢量(66.385, 16.430, 26.817), 矢量(123.555, 7.722, -17.602), 矢量(82.895, 10.261, -50.697), 矢量(-25.700,
			6.569, 12.488), 矢量(10.405, 1.649, -26.571), 矢量(65.922, 10.818, -56.557), 矢量(126.402, 11.033, -27.974), 矢量(147.962, 14.606,
			4.813), 矢量(197.585, 17.734, 79.631), 矢量(195.738, 16.321, 21.712), 矢量(91.762, 21.551, 16.335), 矢量(83.026, 17.793, 39.237), 矢量(
			75.519, 12.895, -31.835), 矢量(35.273, 4.487, 8.332), 矢量(16.315, 1.949, -6.766), 矢量(-45.127, 1.292, -25.852), 矢量(26.527, 2.432,
			28.689), 矢量(106.145, 11.366, 29.887), 矢量(178.579, 9.141, 39.210), 矢量(112.509, 10.903, -34.559), 矢量(-43.637, 26.399, -70.070),
			矢量(41.807, 31.812, -26.134), 矢量(182.929, 40.102, 40.346), 矢量(42.388, 10.545, -34.524), 矢量(-18.621, 12.327, -29.741), 矢量(28.002,
			-0.007, 22.367), 矢量(48.263, 7.101, -23.767), 矢量(113.797, 13.328, -30.621), 矢量(158.682, 9.693, -11.427), 矢量(168.288, 13.559,
			68.307), 矢量(209.386, 38.486, 47.832), 矢量(57.102, 14.050, 39.623), 矢量(69.928, 21.929, -53.784), 矢量(185.283, 19.081, 29.776), 矢量(
			4.545, 1.623, 12.688), 矢量(-53.759, 8.515, -14.222), 矢量(70.280, 8.327, -27.734), 矢量(176.256, 16.998, 21.224), 矢量(133.891,
			25.631, 41.707), 矢量(-45.728, 14.759, -68.017), 矢量(234.602, 24.277, 49.557));
		全局.DistanceToPoint = 4;
		全局.CamSpeed = 1;
		全局.FaultTimes = 4;
		全局.MapDesigner = 自定义字符串("衾岚喵#5486");
		全局.ShareCode = 自定义字符串("YHMEY");
		全局.RankList = 数组();
		全局.PlayerList = 数组();
		全局.UnlockFlyNum = 30;
		全局.HelloTipTime = 60;
		全局.HelloTipRadius = 30;
	}
}

规则("---作--者--信--息---")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		"作者名只改这个"
		全局.MapDesigner = 自定义字符串("衾岚喵#5486");
		"分享码，如“A7306”"
		全局.ShareCode = 自定义字符串("YHMEY");
		禁用 全局.ThanksList = 自定义字符串("编辑器作者：机智的阁下#5771");
	}
}

规则("全局初始化")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		关闭游戏预设完成条件;
		关闭游戏预设计分模式;
		关闭游戏预设通告模式;
		关闭游戏预设音乐模式;
		设置比赛时间(2);
		全局.RestartHourLeft = 当前游戏模式 == 游戏模式(突击模式) ? 4 : 1.500;
		If(全局.Checkpoints == 0 && 全局.CheckCampoints == 0);
			全局.Checkpoints = 空数组;
			全局.CheckCampoints = 空数组;
		End;
		全局.RankList = 空数组;
		全局.PlayerList = 空数组;
	}
}

规则("玩家初始化")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
	}

	动作
	{
		禁用查看器录制;
		设置最大复生时间(事件玩家, 4);
		设置状态(事件玩家, 空, 无敌, 6 * 3600);
		事件玩家.CurrentCheckpoints = 全局.Checkpoints;
		事件玩家.CurrentCheckCampoints = 全局.CheckCampoints;
		禁用 事件玩家.CurrentPlayerpoint = 矢量(0, 0, 0);
		事件玩家.PlayerName = 自定义字符串("{0}", 事件玩家);
		事件玩家.ObserverMode = 0;
		事件玩家.CurrentCheckpointNum = 0;
		事件玩家.PicNum = 事件玩家.CurrentCheckpointNum;
		事件玩家.TempNum = 事件玩家.PicNum;
		事件玩家.TeleportENum = 0;
		事件玩家.FinishGame = 0;
		事件玩家.Invisible = 真;
		事件玩家.Getit = 假;
		事件玩家.GetitEffect = -1;
		事件玩家.FireEffect[0] = -1;
		事件玩家.PicView = 0;
		事件玩家.HelloTip = 0;
		事件玩家.TempHorizontalAngle = 水平朝向角度(事件玩家);
		根据条件跳过(全局.Kaiguan, 1);
		事件玩家.Invisible = 假;
		调用子程序(SetInvisible);
		调用子程序(GameStartTeleport);
		禁用 传送(事件玩家, 全局.Checkpoints[0]);
		禁用 传送(事件玩家, 最近的可行走位置(矢量(0, 0, 0)));
		事件玩家.AlreadyFaultTimes = 0;
		调用子程序(InitialHUDdescribe);
		If(全局.DesignMode);
			创建HUD文本(事件玩家, 图标字符串(感叹号), 空, 自定义字符串("编辑规则已被打开，主机玩家可修改点位"), 左边, -1, 颜色(红色), 颜色(白色), 颜色(橙色), 可见和字符串, 默认可见度);
			禁用 Else;
		End;
		禁用 在索引处修改全局变量(RankList, 栏位(事件玩家), 添加至数组, 事件玩家.CurrentCheckpointNum);
		禁用 修改全局变量(PlayerList, 添加至数组, 矢量(事件玩家.CurrentCheckpointNum, 0, 栏位(事件玩家)));
		禁用 事件玩家.PlayerListpoint = 数组值的索引(全局.PlayerList * 前, 栏位(事件玩家));
		禁用 事件玩家.PlayerListpoint = 数组值的索引(Z方向分量(全局.PlayerList), 栏位(事件玩家));
		创建HUD文本(所有玩家(所有队伍), 空, 空, 自定义字符串("{0}  {1}/{2}", 事件玩家.PlayerName, 事件玩家.CurrentCheckpointNum, 数量(事件玩家.CurrentCheckpoints)), 右边, -1,
			颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		事件玩家.HUDdescribe5 = 上一个文本ID;
		小字体信息(事件玩家, 自定义字符串("欢迎进来玩看图找物"));
		等待(2, 无视条件);
		小字体信息(事件玩家, 自定义字符串("顶部有滚动操作提示"));
		对所有玩家启用死亡回放(事件玩家);
		启用死亡回放时目标的HUD(事件玩家);
		事件玩家.CAIDAN = 0;
	}
}

规则("[选项]--容错次数")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.FaultTimes = 4;
	}
}

规则("[选项]--飞行模式解锁关卡数")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.UnlockFlyNum = 30;
	}
}

规则("[开关选项]--隐身开关")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		"真为隐身，假则不隐身"
		全局.Kaiguan = 假;
	}
}

规则("[自定义选项]点位的距离")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.DistanceToPoint = 4;
	}
}

规则("[自定义选项]--每次提示是否附近的间隔时间/秒-以及提示附近的范围")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		"这是间隔时间/秒"
		全局.HelloTipTime = 60;
		"这是提示附近的范围"
		全局.HelloTipRadius = 30;
	}
}



禁用 规则("启用编辑规则！---如发图请关闭此规则--或把真改为假")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.DesignMode = 真;
	}
}

规则("禁用技能")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
	}

	动作
	{
		设置启用技能 1(事件玩家, 假);
		设置启用技能 2(事件玩家, 假);
		设置启用终极技能(事件玩家, 假);
		设置辅助攻击模式启用(事件玩家, 假);
		设置主要攻击模式启用(事件玩家, 假);
		设置启用近战攻击(事件玩家, 假);
	}
}

规则("开关编辑模式")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		全局.DesignMode == 真;
		事件玩家 == 主机玩家;
		按钮被按下(事件玩家, 按钮(装填)) == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 假;
		按钮被按下(事件玩家, 按钮(跳跃)) == 假;
	}

	动作
	{
		根据条件跳过(事件玩家.EditCamMode, 1);
		事件玩家.EditCampoint = 眼睛位置(事件玩家);
		If(事件玩家.EditCamMode);
			传送(事件玩家, 事件玩家.EditCampoint);
			设置移动速度(事件玩家, 100);
			禁用 传送(事件玩家, 最近的可行走位置(事件玩家.EditCampoint));
			停止镜头(事件玩家);
			事件玩家.EditCampoint = 眼睛位置(事件玩家);
			事件玩家.TempCampoint = 事件玩家.EditCampoint;
			事件玩家.EditCamMode = 0;
			根据条件跳过(事件玩家.CurrentCheckpointNum == 数量(事件玩家.CurrentCheckpoints), 1);
			消除效果(最后创建的实体);
			禁用 启用查看器录制;
		Else;
			开始镜头(事件玩家, 事件玩家.EditCampoint, 事件玩家.EditCampoint + 面朝方向(事件玩家), 400);
			设置移动速度(事件玩家, 0);
			事件玩家.EditCamMode = 1;
			根据条件跳过(事件玩家.CurrentCheckpointNum == 数量(事件玩家.CurrentCheckpoints), 1);
			创建效果(事件玩家, 球体, 颜色(亮紫色), 事件玩家.CurrentCheckpoints[事件玩家.CurrentCheckpointNum], 1, 可见，位置和半径);
			禁用 禁用查看器录制;
		End;
		事件玩家.TempCamSpeed = 全局.CamSpeed;
		事件玩家.CamSpeedLevel = 2;
	}
}

规则("观战")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(互动)) == 真;
		按钮被按下(事件玩家, 按钮(技能2)) == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 假;
		按钮被按下(事件玩家, 按钮(跳跃)) == 假;
	}

	动作
	{
		If(事件玩家.ObserverMode);
			开启游戏预设复生模式(事件玩家);
			设置主要攻击模式启用(事件玩家, 假);
			复活(事件玩家);
			等待(0.100, 无视条件);
			小字体信息(所有玩家(所有队伍), 自定义字符串("已关闭观战模式"));
			事件玩家.ObserverMode = 0;
		Else;
			事件玩家.ObserverMode = 1;
			关闭游戏预设复生模式(事件玩家);
			击杀(事件玩家, 空);
			设置主要攻击模式启用(事件玩家, 真);
			小字体信息(事件玩家, 自定义字符串("已开启观战模式，按左右键切换观战对象"));
		End;
		等待(1, 无视条件);
	}
}

规则("游戏时间")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		当前游戏模式 == 游戏模式(突击模式);
		比赛时间 == 0;
	}

	动作
	{
		If(全局.RestartHourLeft == 0);
			比赛时间暂停;
		Else;
			设置比赛时间(60 * 3600);
		End;
		全局.RestartHourLeft = 全局.RestartHourLeft - 1;
	}
}

规则("重生")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		死亡(事件玩家) == 真;
		事件玩家.ObserverMode == 假;
	}

	动作
	{
		传送(事件玩家, 最近的可行走位置(所选位置(事件玩家)));
		等待(3, 无视条件);
		复活(事件玩家);
	}
}

禁用 规则("调试规则")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
		事件玩家 == 主机玩家;
	}

	动作
	{
		创建HUD文本(主机玩家, 自定义字符串("当前位置：{0}     眼睛位置{1}      面朝方向{2}", 所选位置(事件玩家), 眼睛位置(事件玩家), 面朝方向(事件玩家)), 空, 空, 左边, 0, 颜色(橙色), 颜色(白色), 颜色(白色),
			可见和字符串, 默认可见度);
		创建HUD文本(主机玩家, 自定义字符串("当前Num：{0}   Pic：{1}   Currentpoints数{2}", 事件玩家.CurrentCheckpointNum, 事件玩家.PicNum, 数量(
			事件玩家.CurrentCheckpoints)), 空, 空, 左边, 0, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		创建HUD文本(主机玩家, 自定义字符串("X{0}  Y{1}  Z{2}", X方向分量(阈值(事件玩家)), Y方向分量(阈值(事件玩家)), Z方向分量(阈值(事件玩家))), 空, 空, 左边, 0, 颜色(白色), 颜色(白色), 颜色(白色),
			可见和字符串, 默认可见度);
		创建HUD文本(主机玩家, 自定义字符串("EdCamp{0}   EdCamMo{1}   CamSpLe{2}", 事件玩家.EditCampoint, 事件玩家.EditCamMode, 事件玩家.CamSpeedLevel), 空, 空, 左边, 0,
			颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		创建HUD文本(所有玩家(所有队伍), 自定义字符串("当前地图{0}", 当前地图), 空, 空, 左边, 0, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		创建效果(事件玩家, 环, 颜色(绿色), 所选位置(事件玩家), 2, 可见，位置和半径);
		创建HUD文本(事件玩家, 自定义字符串("所在队伍{0}  快速跳跃图片{1}  水平朝向角度{2}", 所在队伍(事件玩家), 取整(绝对值(与此方向的水平角度(面朝方向(事件玩家))) * (数量(事件玩家.CurrentCheckpointNum)
			/ 180), 上), 水平朝向角度(事件玩家)), 空, 空, 左边, 0, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		创建HUD文本(事件玩家, 自定义字符串("Effect0：{0}   Effect1：{1}", 事件玩家.FireEffect[0], 事件玩家.FireEffect[1]), 空, 空, 左边, 0, 颜色(白色), 颜色(白色), 颜色(白色),
			可见和字符串, 默认可见度);
	}
}

规则("索取关卡位置")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.Getit == 真;
	}

	动作
	{
		根据条件跳过(事件玩家.CurrentCheckpointNum == 数量(事件玩家.CurrentCheckpoints), 1);
		事件玩家.CurrentCheckpointNum += 1;
		事件玩家.Getit = 假;
		根据条件跳过(事件玩家.CurrentCheckpointNum == 数量(事件玩家.CurrentCheckpoints), 1);
		事件玩家.PicNum = 事件玩家.CurrentCheckpointNum;
		事件玩家.TempNum = 事件玩家.PicNum;
		根据条件跳过(事件玩家.CurrentCheckpointNum != 全局.UnlockFlyNum, 1);
		小字体信息(事件玩家, 自定义字符串("已解锁飞行模式，按住跳跃可进行飞行"));
		停止追踪玩家变量(事件玩家, HelloTip);
		事件玩家.HelloTip = 0;
	}
}

规则("找到点位")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(互动)) == 真;
		(事件玩家.CurrentCheckpointNum < 数量(事件玩家.CurrentCheckpoints)) == 真;
		按钮被按下(事件玩家, 按钮(辅助攻击模式)) == 假;
		事件玩家.EditCamMode == 假;
		存活(事件玩家) == 真;
	}

	动作
	{
		If(相距距离(眼睛位置(事件玩家), 事件玩家.CurrentCheckpoints[事件玩家.CurrentCheckpointNum]) <= 全局.DistanceToPoint);
			小字体信息(事件玩家, 自定义字符串("选对了哟，继续努力"));
			播放效果(事件玩家, 有益爆炸, 颜色(橙色), 事件玩家.CurrentCheckpoints[事件玩家.CurrentCheckpointNum], 1);
			根据条件跳过(!实体存在(事件玩家.GetitEffect), 1);
			消除效果(事件玩家.GetitEffect);
			创建效果(事件玩家, 有益光环, 颜色(橙色), 事件玩家.CurrentCheckpoints[事件玩家.CurrentCheckpointNum - 1], 1, 可见，位置和半径);
			事件玩家.GetitEffect = 最后创建的实体;
			播放效果(事件玩家, 正面状态施加声音, 颜色(白色), 事件玩家.CurrentCheckpoints[事件玩家.CurrentCheckpointNum], 200);
			播放效果(事件玩家, 有益选择效果 , 颜色(白色), 事件玩家, 100);
			事件玩家.AlreadyFaultTimes = 0;
			事件玩家.Getit = 真;
		Else;
			设置状态(事件玩家, 空, 冰冻, 1);
			小字体信息(事件玩家, 自定义字符串("选错啦！再仔细找找"));
			事件玩家.AlreadyFaultTimes += 1;
		End;
	}
}

规则("右键查看图片")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(辅助攻击模式)) == 真;
		按钮被按下(事件玩家, 按钮(主要攻击模式)) == 假;
		事件玩家.PicView == 0;
		死亡(事件玩家) == 假;
	}

	动作
	{
		禁用查看器录制;
		事件玩家.TempNum = 事件玩家.PicNum;
		事件玩家.TempNum2 = 水平朝向角度(事件玩家);
		开始镜头(事件玩家, 事件玩家.CurrentCheckpoints[事件玩家.PicNum], 事件玩家.CurrentCheckCampoints[事件玩家.PicNum], 0);
		根据条件跳过(事件玩家.HUDdescribe4 == 0, 1);
		消除HUD文本(事件玩家.HUDdescribe4);
		创建HUD文本(事件玩家, 自定义字符串("正在查看第{0}张图片", 1 + 事件玩家.PicNum), 空, 空, 左边, 0, 颜色(黄色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		事件玩家.HUDdescribe4 = 上一个文本ID;
		事件玩家.PicView = 1;
	}
}

规则("左键回退图片")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(主要攻击模式)) == 真;
		按钮被按下(事件玩家, 按钮(辅助攻击模式)) == 真;
		按钮被按下(事件玩家, 按钮(互动)) == 假;
		事件玩家.PicNum > 0;
		死亡(事件玩家) == 假;
		事件玩家.PicView == 1;
	}

	动作
	{
		事件玩家.PicNum -= 1;
		禁用 开始镜头(事件玩家, 事件玩家.CurrentCheckpoints[事件玩家.PicNum], 事件玩家.CurrentCheckCampoints[事件玩家.PicNum], 0);
	}
}

规则("停止查看图片")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(辅助攻击模式)) == 假;
		死亡(事件玩家) == 假;
	}

	动作
	{
		停止镜头(事件玩家);
		事件玩家.PicNum = 事件玩家.TempNum;
		根据条件跳过(事件玩家.HUDdescribe4 == 0, 1);
		消除HUD文本(事件玩家.HUDdescribe4);
		事件玩家.PicView = 0;
		根据条件跳过(全局.DesignMode == 假, 1);
		禁用 启用查看器录制;
		根据条件跳过(事件玩家.EditCamMode == 假, 2);
		开始镜头(事件玩家, 事件玩家.EditCampoint, 事件玩家.EditCampoint + 面朝方向(事件玩家), 400);
		禁用查看器录制;
	}
}

规则("移动镜头")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.EditCamMode == 真;
		全局.DesignMode == 真;
		(绝对值(X方向分量(阈值(事件玩家))) || 绝对值(Z方向分量(阈值(事件玩家)))) == 真;
	}

	动作
	{
		禁用查看器录制;
		If(Z方向分量(阈值(事件玩家)) != 0);
			事件玩家.TempCampoint = 事件玩家.EditCampoint;
			追踪玩家变量频率(事件玩家, EditCampoint, 事件玩家.TempCampoint + 面朝方向(事件玩家) * 事件玩家.TempCamSpeed * Z方向分量(归一化(阈值(事件玩家))), 事件玩家.TempCamSpeed * 10,
				速率及最终值);
			禁用 事件玩家.EditCampoint += 面朝方向(事件玩家) * 0.500;
			禁用 Else If(Z方向分量(阈值(事件玩家)) < 0);
			禁用 事件玩家.TempCampoint = 事件玩家.EditCampoint;
			禁用 追踪玩家变量频率(事件玩家, EditCampoint, 事件玩家.TempCampoint + 面朝方向(事件玩家) * 事件玩家.TempCamSpeed * -1, 事件玩家.TempCamSpeed * 10, 速率及最终值);
		Else If(X方向分量(阈值(事件玩家)) != 0);
			事件玩家.TempCampoint = 事件玩家.EditCampoint;
			禁用 追踪玩家变量频率(事件玩家, EditCampoint, 事件玩家.TempCampoint + 地图矢量(矢量(X方向分量(归一化(阈值(事件玩家))), 0, 0), 事件玩家, 旋转) * 事件玩家.TempCamSpeed,
				事件玩家.TempCamSpeed * 10, 速率及最终值);
			追踪玩家变量频率(事件玩家, EditCampoint, 事件玩家.TempCampoint + 地图矢量(矢量(1, 0, 0) * X方向分量(归一化(阈值(事件玩家))), 事件玩家, 旋转) * 事件玩家.TempCamSpeed,
				事件玩家.TempCamSpeed * 10, 速率及最终值);
		End;
		等待(0.020, 无视条件);
		如条件为“假”则中止;
		循环;
	}
}

规则("新建关卡")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		全局.DesignMode == 真;
		事件玩家.EditCamMode == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 真;
		按钮被按下(事件玩家, 按钮(装填)) == 真;
		事件玩家 == 主机玩家;
	}

	动作
	{
		消除效果(最后创建的实体);
		修改全局变量(CheckCampoints, 添加至数组, 事件玩家.EditCampoint + 面朝方向(事件玩家));
		修改全局变量(Checkpoints, 添加至数组, 事件玩家.EditCampoint);
		启用查看器录制;
		禁用查看器录制;
		调用子程序(SetNum);
		小字体信息(事件玩家, 自定义字符串("新建最后一关成功"));
	}
}

规则("替换关卡")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		全局.DesignMode == 真;
		事件玩家.EditCamMode == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 真;
		按钮被按下(事件玩家, 按钮(技能2)) == 真;
		事件玩家 == 主机玩家;
	}

	动作
	{
		小字体信息(事件玩家, 自定义字符串("长按1s替换关卡"));
		等待(1, 无视条件);
		如条件为“假”则中止;
		全局.Checkpoints[事件玩家.PicNum] = 事件玩家.EditCampoint;
		全局.CheckCampoints[事件玩家.PicNum] = 事件玩家.EditCampoint + 面朝方向(事件玩家);
		启用查看器录制;
		禁用查看器录制;
		事件玩家.CurrentCheckpoints = 全局.Checkpoints;
		事件玩家.CurrentCheckCampoints = 全局.CheckCampoints;
		小字体信息(事件玩家, 自定义字符串("替换成功"));
	}
}

规则("删除关卡")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		全局.DesignMode == 真;
		事件玩家.EditCamMode == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 真;
		按钮被按下(事件玩家, 按钮(终极技能)) == 真;
		事件玩家 == 主机玩家;
	}

	动作
	{
		禁用 根据条件跳过(全局.Checkpoints == 1, 1);
		小字体信息(事件玩家, 自定义字符串("长按1s删除关卡"));
		等待(1, 无视条件);
		如条件为“假”则中止;
		禁用 修改全局变量(Checkpoints, 根据索引从数组中移除, 数量(全局.Checkpoints) - 1);
		禁用 修改全局变量(CheckCampoints, 根据索引从数组中移除, 全局.CheckCampoints - 1);
		修改全局变量(Checkpoints, 根据索引从数组中移除, 事件玩家.PicNum);
		修改全局变量(CheckCampoints, 根据索引从数组中移除, 事件玩家.PicNum);
		启用查看器录制;
		禁用查看器录制;
		消除效果(最后创建的实体);
		调用子程序(SetNum);
	}
}

规则("子程序SetNum")
{
	事件
	{
		子程序;
		SetNum;
	}

	动作
	{
		事件玩家.CurrentCheckpoints = 全局.Checkpoints;
		事件玩家.CurrentCheckCampoints = 全局.CheckCampoints;
		事件玩家.CurrentCheckpointNum = 数量(事件玩家.CurrentCheckpoints) + 0;
		事件玩家.PicNum = 事件玩家.CurrentCheckpointNum - 1;
		事件玩家.TempNum = 事件玩家.PicNum;
	}
}

规则("镜头默认速度")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.CamSpeed = 1;
	}
}

规则("降镜头速度")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.EditCamMode == 真;
		全局.DesignMode == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 假;
		按钮被按下(事件玩家, 按钮(互动)) == 假;
		事件玩家 == 主机玩家;
	}

	动作
	{
		等待(1, 无视条件);
		如条件为“假”则中止;
		根据条件跳过(事件玩家.CamSpeedLevel == 0, 3);
		事件玩家.TempCamSpeed *= 0.100;
		事件玩家.CamSpeedLevel -= 1;
		小字体信息(事件玩家, 自定义字符串("速度已减一档"));
		根据条件跳过(事件玩家.CamSpeedLevel > 0, 1);
		小字体信息(事件玩家, 自定义字符串("不能再减了"));
	}
}

规则("升镜头速度")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.EditCamMode == 真;
		全局.DesignMode == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 假;
		按钮被按下(事件玩家, 按钮(跳跃)) == 真;
		按钮被按下(事件玩家, 按钮(互动)) == 假;
		事件玩家 == 主机玩家;
	}

	动作
	{
		等待(1, 无视条件);
		如条件为“假”则中止;
		根据条件跳过(事件玩家.CamSpeedLevel == 3, 3);
		事件玩家.TempCamSpeed *= 10;
		事件玩家.CamSpeedLevel += 1;
		小字体信息(事件玩家, 自定义字符串("速度已升一档"));
		根据条件跳过(事件玩家.CamSpeedLevel < 3, 1);
		小字体信息(事件玩家, 自定义字符串("不能再升了"));
	}
}

规则("移动加速")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(技能1)) == 真;
		事件玩家.EditCamMode == 假;
	}

	动作
	{
		设置移动速度(事件玩家, 300);
	}
}

规则("取消移动加速")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(技能1)) == 假;
	}

	动作
	{
		设置移动速度(事件玩家, 150);
	}
}

规则("编辑模式下跳关")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		全局.DesignMode == 真;
		禁用 事件玩家.EditCamMode == 真;
		按钮被按下(事件玩家, 按钮(互动)) == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 真;
		按钮被按下(事件玩家, 按钮(辅助攻击模式)) == 真;
		事件玩家 == 主机玩家;
	}

	动作
	{
		If(事件玩家.CurrentCheckpointNum < 数量(事件玩家.CurrentCheckpoints));
			事件玩家.CurrentCheckpointNum += 1;
			根据条件跳过(事件玩家.CurrentCheckpointNum == 数量(事件玩家.CurrentCheckpoints), 1);
			事件玩家.PicNum = 事件玩家.CurrentCheckpointNum;
		Else;
			事件玩家.CurrentCheckpointNum = 0;
			事件玩家.PicNum = 事件玩家.CurrentCheckpointNum;
		End;
		事件玩家.TempNum = 事件玩家.PicNum;
		小字体信息(事件玩家, 自定义字符串("已跳至{0}关", 事件玩家.CurrentCheckpointNum));
		传送(事件玩家, 最近的可行走位置(事件玩家.CurrentCheckpoints[事件玩家.CurrentCheckpointNum]));
		根据条件跳过(事件玩家.CurrentCheckpointNum < 数量(事件玩家.CurrentCheckpoints), 1);
		传送(事件玩家, 最近的可行走位置(事件玩家.CurrentCheckpoints[事件玩家.CurrentCheckpointNum - 1]));
		根据条件跳过(事件玩家.CurrentCheckpointNum != 全局.UnlockFlyNum, 1);
		小字体信息(事件玩家, 自定义字符串("已解锁飞行模式，按住跳跃可进行飞行"));
	}
}

规则("编辑模式下退关")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		全局.DesignMode == 真;
		禁用 事件玩家.EditCamMode == 真;
		按钮被按下(事件玩家, 按钮(互动)) == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		按钮被按下(事件玩家, 按钮(辅助攻击模式)) == 真;
		事件玩家 == 主机玩家;
	}

	动作
	{
		If(事件玩家.CurrentCheckpointNum > 0);
			禁用 根据条件跳过(事件玩家.CurrentCheckpointNum == 数量(事件玩家.CurrentCheckpoints), 1);
			事件玩家.CurrentCheckpointNum -= 1;
			根据条件跳过(事件玩家.CurrentCheckpointNum == 数量(事件玩家.CurrentCheckpoints), 1);
			事件玩家.PicNum = 事件玩家.CurrentCheckpointNum;
		Else;
			禁用 根据条件跳过(事件玩家.CurrentCheckpointNum < 数量(事件玩家.CurrentCheckpoints), 1);
			事件玩家.CurrentCheckpointNum = 数量(事件玩家.CurrentCheckpoints);
			事件玩家.PicNum = 事件玩家.CurrentCheckpointNum - 1;
		End;
		事件玩家.TempNum = 事件玩家.PicNum;
		小字体信息(事件玩家, 自定义字符串("已跳至{0}关", 事件玩家.CurrentCheckpointNum));
		传送(事件玩家, 最近的可行走位置(事件玩家.CurrentCheckpoints[事件玩家.CurrentCheckpointNum]));
		根据条件跳过(事件玩家.CurrentCheckpointNum < 数量(事件玩家.CurrentCheckpoints), 1);
		传送(事件玩家, 最近的可行走位置(事件玩家.CurrentCheckpoints[事件玩家.CurrentCheckpointNum - 1]));
		根据条件跳过(事件玩家.CurrentCheckpointNum != 全局.UnlockFlyNum, 1);
		小字体信息(事件玩家, 自定义字符串("已解锁飞行模式，按住跳跃可进行飞行"));
	}
}

规则("顶部进度文字")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
	}

	动作
	{
		禁用 创建HUD文本(事件玩家, 自定义字符串("「关卡进度」{0} / {1}", 事件玩家.CurrentCheckpointNum, 数量(事件玩家.CurrentCheckpoints)), 空, 空, 顶部, 100, 颜色(白色), 颜色(白色), 颜色(
			白色), 可见和字符串, 默认可见度);
		创建HUD文本(事件玩家, 自定义字符串("「你已找到」{0} / {1}", 事件玩家.CurrentCheckpointNum, 数量(事件玩家.CurrentCheckpoints)), 空, 空, 左边, 300, 颜色(玫红), 颜色(绿色), 颜色(
			玫红), 可见和字符串, 默认可见度);
	}
}

规则("默认右边描述")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
	}

	动作
	{
		禁用 创建HUD文本(事件玩家, 空, 空, 自定义字符串("\r\n编辑器1.0.2  编辑器作者：机智的阁下#5771"), 右边, -1 * 993, 颜色(白色), 颜色(白色), 颜色(绿色), 可见, 默认可见度);
		禁用 创建HUD文本(事件玩家, 空, 空, 自定义字符串(
			"按住右键看图，再按左键回看\r\n  长按 SHIFT       加速移动\r\n  发送“你好”    关卡提示\r\n     CTRL 键       进出传送门\r\n30关之后，长按空格键可飞行进行传送"), 右边, -1 * 994,
			颜色(白色), 颜色(白色), 颜色(绿色), 可见, 默认可见度);
		禁用 创建HUD文本(事件玩家, 空, 空, 自定义字符串(
			"按住右键看图，再按左键回看\r\n  长按 SHIFT       加速移动\r\n  发送“你好”      关卡提示\n    CTRL 键        进出传送门\r\n30关之后，长按空格键可飞行"), 右边, -1 * 995, 颜色(
			白色), 颜色(白色), 颜色(绿色), 可见, 默认可见度);
		禁用 创建HUD文本(事件玩家, 自定义字符串("作者：{0}\r\n代码：{1}\r\n{2}", 全局.MapDesigner, 全局.ShareCode, 全局.ThanksList), 空, 空, 左边, -1 * 996, 颜色(橙色), 颜色(白色),
			颜色(天蓝色), 可见, 默认可见度);
	}
}

规则("错误惩罚措施（送小黑屋喔）")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.AlreadyFaultTimes == 全局.FaultTimes + 1;
		已重生(事件玩家) == 真;
	}

	动作
	{
		事件玩家.CurrentPlayerpoint = 所选位置(事件玩家);
		If(当前地图 == 地图(万圣节艾兴瓦尔德) || 当前地图 == 地图(艾兴瓦尔德));
			传送(事件玩家, 矢量(-24.530, 6.500, -89.570));
		Else If(当前地图 == 地图(“地平线”月球基地));
			传送(事件玩家, 矢量(74.050, 9.500, -93.570));
		Else If(当前地图 == 地图(圣诞节花村) || 当前地图 == 地图(花村));
			传送(事件玩家, 矢量(1.870, -1.500, 26.170));
		Else If(当前地图 == 地图(国王大道) || 当前地图 == 地图(圣诞节国王大道));
			传送(事件玩家, 矢量(-117.960, -4.400, -28.390));
		Else If(当前地图 == 地图(暴雪世界) || 当前地图 == 地图(圣诞节暴雪世界));
			传送(事件玩家, 矢量(-35.050, -2.210, 146.480));
		Else If(当前地图 == 地图(渣客镇));
			传送(事件玩家, 矢量(-43.750, 4.270, -5.580));
		Else If(当前地图 == 地图(多拉多));
			传送(事件玩家, 矢量(-43.650, 27.362, -74.604));
		Else If(当前地图 == 地图(里阿尔托));
			传送(事件玩家, 矢量(-23.630, -0.230, -13.060));
		Else If(当前地图 == 地图(哈瓦那));
			传送(事件玩家, 矢量(-13.626, 27.730, -45.243));
		Else If(当前地图 == 地图(漓江塔) || 当前地图 == 地图(春节漓江塔) || 当前地图 == 地图(尼泊尔) || 当前地图 == 地图(伊利奥斯) || 当前地图 == 地图(绿洲城) || 当前地图 == 地图(釜山));
			设置状态(事件玩家, 空, 冰冻, 10);
		Else If(当前地图 == 地图(好莱坞) || 当前地图 == 地图(万圣节好莱坞));
			传送(事件玩家, 矢量(-33.448, 43.571, -17.049));
		Else If(当前地图 == 地图(阿努比斯神殿));
			传送(事件玩家, 矢量(-3.512, 122.172, 177.412));
		End;
		If(当前地图 == 地图(漓江塔) || 当前地图 == 地图(春节漓江塔) || 当前地图 == 地图(尼泊尔) || 当前地图 == 地图(伊利奥斯) || 当前地图 == 地图(绿洲城) || 当前地图 == 地图(釜山));
			小字体信息(事件玩家, 自定义字符串("太笨啦，被冻成冰雕了，不要再选错了哦"));
			大字体信息(所有玩家(所有队伍), 自定义字符串("{0}因为太笨被冻成冰雕啦，心疼一秒", 事件玩家.PlayerName));
		Else;
			小字体信息(事件玩家, 自定义字符串("选错太多啦，进小黑屋反省下吧！"));
			大字体信息(所有玩家(所有队伍), 自定义字符串("{0}因为打星际太多被关进小黑屋了，心疼1秒", 事件玩家.PlayerName));
		End;
		事件玩家.Invisible = 假;
		调用子程序(SetInvisible);
		等待(10, 无视条件);
		传送(事件玩家, 事件玩家.CurrentPlayerpoint);
		根据条件跳过(全局.Kaiguan == 假, 2);
		事件玩家.Invisible = 真;
		调用子程序(SetInvisible);
		事件玩家.AlreadyFaultTimes = 0;
		小字体信息(事件玩家, 自定义字符串("这次先放过你，下次可不能再进来啦！"));
	}
}

规则("关卡效果显示")
{
	事件
	{
		持续 - 全局;
	}
}

规则("右边编辑模式描述")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.EditCamMode == 真;
		全局.DesignMode == 真;
		事件玩家 == 主机玩家;
		已重生(事件玩家) == 真;
	}

	动作
	{
		禁用 根据条件跳过(!事件玩家.HUDdescribe3, 1);
		消除HUD文本(事件玩家.HUDdescribe3);
		创建HUD文本(事件玩家, 空, 空, 自定义字符串(
			"         长按CTRL       镜头减速一档\r\n         长按空格         镜头加速一档\r\n          按WSAD移动镜头，按R退出\r\n          使用（语音：感谢）导出点位"), 右边,
			-1 * 997, 颜色(白色), 颜色(白色), 颜色(橙色), 可见, 默认可见度);
		事件玩家.HUDdescribe1 = 上一个文本ID;
		创建HUD文本(事件玩家, 空, 空, 自定义字符串(
			"已进入编辑模式\r\n       CTRL+空格+R         新建最后一关\r\n长按CTRL+空格+E         替换当前关卡\r\n长按CTRL+空格+Q         删除当前关卡"), 右边, -1 * 997, 颜色(
			白色), 颜色(白色), 颜色(橙色), 可见, 默认可见度);
		事件玩家.HUDdescribe2 = 上一个文本ID;
	}
}

规则("右边编辑模式描述关闭")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.EditCamMode == 假;
		全局.DesignMode == 真;
		已重生(事件玩家) == 真;
		事件玩家 == 主机玩家;
	}

	动作
	{
		根据条件跳过(!事件玩家.HUDdescribe1, 1);
		消除HUD文本(事件玩家.HUDdescribe1);
		根据条件跳过(!事件玩家.HUDdescribe2, 1);
		消除HUD文本(事件玩家.HUDdescribe2);
		创建HUD文本(事件玩家, 空, 空, 自定义字符串("已开启编辑规则，玩家可修改关卡\r\n按R可进入编辑模式\r\n右键+F+空格              跳至下一关\r\n右键+F+CTRL            跳至上一关"), 右边,
			-1 * 997, 颜色(白色), 颜色(白色), 颜色(橙色), 可见, 默认可见度);
		事件玩家.HUDdescribe3 = 上一个文本ID;
	}
}

规则("子程序InitialHUDdescribe")
{
	事件
	{
		子程序;
		InitialHUDdescribe;
	}

	动作
	{
		事件玩家.HUDdescribe1 = 0;
		事件玩家.HUDdescribe2 = 0;
		事件玩家.HUDdescribe3 = 0;
		事件玩家.HUDdescribe4 = 0;
		事件玩家.HUDdescribe6 = 0;
	}
}

规则("查看器全局点位导出")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家 == 主机玩家;
		全局.DesignMode == 真;
		禁用 按钮被按下(事件玩家, 按钮(互动)) == 真;
		正在交流(事件玩家, 感谢) == 真;
	}

	动作
	{
		启用查看器录制;
		全局.DesignMode = 假;
		禁用查看器录制;
		全局.DesignMode = 真;
		小字体信息(事件玩家, 自定义字符串("已导出，请到20s内到查看器复制全局变量"));
		等待(2, 无视条件);
		小字体信息(事件玩家, 自定义字符串("20s内请不要进行修改，否则无法保证准确导出"));
		等待(2, 无视条件);
		小字体信息(事件玩家, 自定义字符串("如有后续更改，请更新导出"));
		等待(20, 无视条件);
		禁用 启用查看器录制;
	}
}

规则("通关效果")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.CurrentCheckpointNum == 数量(事件玩家.CurrentCheckpoints);
		已重生(事件玩家) == 真;
		事件玩家.CurrentCheckpointNum != 0;
		事件玩家.FinishGame == 假;
	}

	动作
	{
		事件玩家.FinishGame = 1;
		事件玩家.Invisible = 假;
		调用子程序(SetInvisible);
		大字体信息(所有玩家(所有队伍), 自定义字符串("恭喜小可爱{0}已通关！！", 事件玩家));
		根据条件跳过(实体存在(事件玩家.FireEffect[0]), 8);
		创建效果(所有玩家(所有队伍), 火花, 颜色(绿色), 事件玩家, 0.350, 可见，位置和半径);
		事件玩家.FireEffect[0] = 最后创建的实体;
		创建效果(所有玩家(所有队伍), 火花, 颜色(蓝色), 事件玩家, 0.350, 可见，位置和半径);
		事件玩家.FireEffect[1] = 最后创建的实体;
		创建效果(所有玩家(所有队伍), 火花, 颜色(亮紫色), 事件玩家, 0.350, 可见，位置和半径);
		事件玩家.FireEffect[2] = 最后创建的实体;
		创建效果(所有玩家(所有队伍), 火花, 颜色(橙色), 事件玩家, 0.350, 可见，位置和半径);
		事件玩家.FireEffect[3] = 最后创建的实体;
		消除HUD文本(事件玩家.HUDdescribe5);
		创建HUD文本(所有玩家(所有队伍), 空, 空, 自定义字符串("{0}  {1}/{2}   已完成", 事件玩家.PlayerName, 事件玩家.CurrentCheckpointNum, 数量(事件玩家.CurrentCheckpoints)),
			右边, -2, 颜色(白色), 颜色(白色), 颜色(绿色), 可见和字符串, 默认可见度);
		根据条件跳过(事件玩家.HUDdescribe6 != 0, 2);
		禁用 创建HUD文本(所有玩家(所有队伍), 自定义字符串("{0}{1}{2}", 英雄图标字符串(所用英雄(事件玩家)), 事件玩家.PlayerName, 图标字符串(旗帜)), 空, 空, 左边, 1, 颜色(橙色), 颜色(白色), 颜色(白色),
			可见和字符串, 默认可见度);
		事件玩家.HUDdescribe6 = 上一个文本ID;
		禁用 修改全局变量(PlayerList, 根据索引从数组中移除, 事件玩家.PlayerListpoint);
		禁用 调用子程序(RefreshPlayerList);
	}
}

规则("消除通关效果")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.CurrentCheckpointNum != 数量(事件玩家.CurrentCheckpoints);
		事件玩家 == 主机玩家;
		禁用 事件玩家.CurrentCheckpointNum != 0;
		事件玩家.FinishGame == 真;
		全局.DesignMode == 真;
	}

	动作
	{
		事件玩家.FinishGame = 0;
		根据条件跳过(全局.Kaiguan == 假, 2);
		事件玩家.Invisible = 真;
		调用子程序(SetInvisible);
		禁用 消除效果(事件玩家);
	}
}

禁用 规则("右上角排名")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
		禁用 事件玩家 == 主机玩家;
		禁用 按钮被按下(事件玩家, 按钮(技能1)) == 真;
		禁用 按钮被按下(事件玩家, 按钮(技能2)) == 真;
	}

	动作
	{
		禁用 For 玩家变量(事件玩家, CounterI, 0, 数量(全局.RankList), 1);
		禁用 If(此栏位的玩家(事件玩家.CounterI, 所有队伍).CurrentCheckpointNum >= 此栏位的玩家(事件玩家.CounterI + 1, 所有队伍).CurrentCheckpointNum);
		禁用 修改全局变量(RankList, 添加至数组, 矢量(事件玩家.CurrentCheckpointNum, 0, 栏位(事件玩家)));
		禁用 事件玩家.CurrentRankList = 已排序的数组(全局.RankList, 当前数组元素);
		禁用 创建HUD文本(事件玩家, 自定义字符串("{0} {1}/{2}", 此栏位的玩家(Z方向分量(全局.RankList)[0], 所有队伍).PlayerName, 事件玩家.CurrentCheckpointNum, 数量(全局.Checkpoints)),
			空, 空, 右边, 0, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		禁用 创建HUD文本(事件玩家, 自定义字符串("{0} {1}/{2}", 此栏位的玩家(Z方向分量(全局.RankList)[0], 所有队伍).PlayerName, 此栏位的玩家(Z方向分量(全局.RankList)[0], 所有队伍)
			.CurrentCheckpointNum, 数量(事件玩家.CurrentCheckpoints)), 空, 空, 左边, 10, 颜色(橙色), 颜色(紫色), 颜色(玫红), 可见和字符串, 默认可见度);
	}
}

禁用 规则("存进PlayList")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
		事件玩家.Getit == 假;
	}

	动作
	{
		全局.PlayerList[事件玩家.PlayerListpoint] = 矢量(事件玩家.CurrentCheckpointNum, 0, 栏位(事件玩家));
		禁用 事件玩家.CurrentRankList = 已排序的数组(全局.PlayerList, 当前数组元素);
		禁用 全局.RankList = 事件玩家.CurrentRankList;
		调用子程序(RefreshPlayerList);
	}
}

规则("玩家退出")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 假;
	}

	动作
	{
		禁用 修改全局变量(PlayerList, 根据索引从数组中移除, 事件玩家.PlayerListpoint);
		禁用 调用子程序(RefreshPlayerList);
		禁用 消除所有HUD文本;
	}
}

禁用 规则("子程序RefreshPlayerList")
{
	事件
	{
		子程序;
		RefreshPlayerList;
	}

	动作
	{
		事件玩家.CurrentRankList = 已排序的数组(全局.PlayerList, 当前数组元素);
		全局.RankList = 事件玩家.CurrentRankList;
	}
}

规则("飞行模式")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		死亡(事件玩家) == 假;
		(事件玩家.CurrentCheckpointNum >= 全局.UnlockFlyNum) == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 真;
		事件玩家.EditCamMode == 假;
		(事件玩家.AlreadyFaultTimes == 全局.FaultTimes + 1) == 假;
	}

	动作
	{
		设置引力(事件玩家, 0);
		While(按钮被按下(事件玩家, 按钮(跳跃)));
			施加推力(事件玩家, 上, 3, 至地图, 取消相反运动);
			等待(0.200, 无视条件);
		End;
		设置引力(事件玩家, 100);
	}
}

规则("每10s启用一次查看器并且同步关卡")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		全局.DesignMode == 真;
	}

	动作
	{
		启用查看器录制;
		禁用查看器录制;
		等待(10, 无视条件);
		事件玩家.CurrentCheckpoints = 全局.Checkpoints;
		事件玩家.CurrentCheckCampoints = 全局.CheckCampoints;
		禁用 根据条件跳过(事件玩家 != 主机玩家 && 事件玩家.CurrentCheckpointNum > 数量(事件玩家.CurrentCheckpoints), 1);
		禁用 事件玩家.CurrentCheckpointNum = 数量(事件玩家.CurrentCheckpoints);
		循环;
	}
}

规则("禁用半藏源氏爬墙DJ滑墙回声天使滑行1")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		(在墙上(事件玩家) || 正在空中(事件玩家)) == 真;
		数组包含(数组(英雄(半藏), 英雄(源氏), 英雄(卢西奥), 英雄(回声), 英雄(天使)), 所用英雄(事件玩家)) == 真;
	}

	动作
	{
		禁用按钮(事件玩家, 按钮(跳跃));
		取消主要动作(事件玩家);
	}
}

规则("禁用半藏源氏爬墙DJ滑墙回声天使滑行2")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		在地面上(事件玩家) == 真;
		数组包含(数组(英雄(半藏), 英雄(源氏), 英雄(卢西奥), 英雄(回声), 英雄(天使)), 所用英雄(事件玩家)) == 真;
	}

	动作
	{
		可用按钮(事件玩家, 按钮(跳跃));
	}
}

规则("按住V快速切换图片")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(近身攻击)) == 真;
		按钮被按下(事件玩家, 按钮(辅助攻击模式)) == 真;
		(取整(事件玩家.TempHorizontalAngle, 至最近) != 取整(水平朝向角度(事件玩家), 至最近)) == 真;
	}

	动作
	{
		事件玩家.PicNum = 绝对值(取整((事件玩家.TempNum2 - 水平朝向角度(事件玩家)) * 3 * 数量(事件玩家.CurrentCheckpoints) / 180 + 事件玩家.TempNum, 至最近)) % (
			事件玩家.TempNum + 1);
		事件玩家.TempHorizontalAngle = 水平朝向角度(事件玩家);
	}
}

规则("传送起始点")
{
	事件
	{
		子程序;
		GameStartTeleport;
	}

	动作
	{
		If(当前地图 == 地图(万圣节艾兴瓦尔德) || 当前地图 == 地图(艾兴瓦尔德));
			传送(事件玩家, 矢量(-15.360, 1, 18.800));
			设置朝向(事件玩家, 矢量(0.120, 0, -0.990), 至地图);
		Else If(当前地图 == 地图(圣诞节花村) || 当前地图 == 地图(花村));
			传送(事件玩家, 矢量(104.240, 1, -0.740));
			设置朝向(事件玩家, 矢量(-0.990, -0.120, 0), 至地图);
		Else If(当前地图 == 地图(漓江塔) || 当前地图 == 地图(春节漓江塔));
			传送(事件玩家, 矢量(-62.260, 267.580, 342.580));
			设置朝向(事件玩家, 矢量(0.720, 0.010, -0.700), 至地图);
		Else If(当前地图 == 地图(国王大道) || 当前地图 == 地图(圣诞节国王大道));
			传送(事件玩家, 矢量(4.020, 2, 54.080));
			设置朝向(事件玩家, 矢量(-0.190, -0.050, -0.980), 至地图);
		Else If(当前地图 == 地图(渣客镇));
			传送(事件玩家, 矢量(62.970, 9, -79.270));
			设置朝向(事件玩家, 矢量(-0.990, -0.040, 0.150), 至地图);
		Else If(当前地图 == 地图(里阿尔托));
			传送(事件玩家, 矢量(141.610, -1.490, -21.570));
			设置朝向(事件玩家, 矢量(-1, 0.040, 0.020), 至地图);
		Else If(当前地图 == 地图(暴雪世界) || 当前地图 == 地图(圣诞节暴雪世界));
			传送(事件玩家, 矢量(3.310, -4.950, -42.910));
			设置朝向(事件玩家, 矢量(0, 0.050, 1), 至地图);
		Else If(当前地图 == 地图(釜山));
			传送(事件玩家, 矢量(-426.880, 11.110, 165.760));
			设置朝向(事件玩家, 矢量(0.990, 0.010, -0.110), 至地图);
		Else If(当前地图 == 地图(“地平线”月球基地));
			传送(事件玩家, 矢量(-24.930, 17.880, 10.170));
			设置朝向(事件玩家, 矢量(0.880, -0.130, -0.460), 至地图);
		Else If(当前地图 == 地图(哈瓦那));
			传送(事件玩家, 矢量(-105.060, 4, -75.890));
			设置朝向(事件玩家, 矢量(0.730, -0.070, 0.680), 至地图);
		Else If(当前地图 == 地图(好莱坞) || 当前地图 == 地图(万圣节好莱坞));
			传送(事件玩家, 矢量(-12.137, 3.250, 90.621));
			设置朝向(事件玩家, 矢量(-12.024, 3.254, 85.976), 至地图);
		Else If(当前地图 == 地图(阿努比斯神殿));
			传送(事件玩家, 矢量(-1.875, 3.223, -41.622));
			设置朝向(事件玩家, 矢量(-1.875, 3.223, -41.622), 至地图);
		Else If(当前地图 == 地图(多拉多));
			传送(事件玩家, 矢量(-23.316, 1.049, -12.331));
			设置朝向(事件玩家, 矢量(-16.064, 1.650, -6.654), 至地图);
	}
}

规则("传送操作--艾兴瓦尔德")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 假;
		按钮被按下(事件玩家, 按钮(装填)) == 假;
		按钮被按下(事件玩家, 按钮(技能2)) == 假;
		按钮被按下(事件玩家, 按钮(终极技能)) == 假;
		(当前地图 == 地图(万圣节艾兴瓦尔德) || 当前地图 == 地图(艾兴瓦尔德)) == 真;
		(事件玩家.AlreadyFaultTimes == 全局.FaultTimes + 1) == 假;
	}

	动作
	{
		禁用 If(相距距离(所选位置(事件玩家), 矢量(0, 0, 0)) <= 2);
		禁用 传送(事件玩家, 矢量(0, 0, 0));
		禁用 Else If(相距距离(所选位置(事件玩家), 矢量(0, 0, 0)) <= 2);
		禁用 传送(事件玩家, 矢量(0, 0, 0));
		If(相距距离(所选位置(事件玩家), 矢量(-11.720, 0, -9.070)) <= 2);
			传送(事件玩家, 矢量(-12.530, 1, -4.470));
		Else If(相距距离(所选位置(事件玩家), 矢量(-12.530, 1, -4.470)) <= 2);
			传送(事件玩家, 矢量(-11.720, 0, -9.070));
		Else If(相距距离(所选位置(事件玩家), 矢量(-6.630, 3.550, -85.450)) <= 2);
			传送(事件玩家, 矢量(-11.950, 5.300, -87.800));
		Else If(相距距离(所选位置(事件玩家), 矢量(-11.950, 5.300, -87.800)) <= 2);
			传送(事件玩家, 矢量(-6.630, 3.550, -85.450));
		Else If(相距距离(所选位置(事件玩家), 矢量(74.740, 10.700, -109.200)) <= 2);
			传送(事件玩家, 矢量(73.390, 10.720, -115.110));
		Else If(相距距离(所选位置(事件玩家), 矢量(73.390, 10.720, -115.110)) <= 2);
			传送(事件玩家, 矢量(74.740, 10.700, -109.200));
		Else If(相距距离(所选位置(事件玩家), 矢量(115.040, 10.720, -13.410)) <= 2);
			传送(事件玩家, 矢量(112.580, 10.740, -9.720));
		Else If(相距距离(所选位置(事件玩家), 矢量(112.580, 10.740, -9.720)) <= 2);
			传送(事件玩家, 矢量(115.040, 10.720, -13.410));
		Else If(相距距离(所选位置(事件玩家), 矢量(91.980, 12.720, -103.740)) <= 2);
			传送(事件玩家, 矢量(87.070, 12.860, -101.270));
		Else If(相距距离(所选位置(事件玩家), 矢量(87.070, 12.860, -101.270)) <= 2);
			传送(事件玩家, 矢量(91.980, 12.720, -103.740));
	}
}

规则("传送操作--花村")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 假;
		按钮被按下(事件玩家, 按钮(装填)) == 假;
		按钮被按下(事件玩家, 按钮(技能2)) == 假;
		按钮被按下(事件玩家, 按钮(终极技能)) == 假;
		(当前地图 == 地图(圣诞节花村) || 当前地图 == 地图(花村)) == 真;
		(事件玩家.AlreadyFaultTimes == 全局.FaultTimes + 1) == 假;
	}

	动作
	{
		If(相距距离(所选位置(事件玩家), 矢量(76.470, -2, 0.150)) <= 2);
			传送(事件玩家, 矢量(71.460, -1.950, 0.040));
		Else If(相距距离(所选位置(事件玩家), 矢量(71.460, -1.950, 0.040)) <= 2);
			传送(事件玩家, 矢量(76.470, -2, 0.150));
		Else If(相距距离(所选位置(事件玩家), 矢量(13.990, -1, 13.530)) <= 2);
			传送(事件玩家, 矢量(14.060, 0, 8.360));
		Else If(相距距离(所选位置(事件玩家), 矢量(14.060, 0, 8.360)) <= 2);
			传送(事件玩家, 矢量(13.990, -1, 13.530));
		Else If(相距距离(所选位置(事件玩家), 矢量(-38.150, 1, -86.960)) <= 2);
			传送(事件玩家, 矢量(-42.120, 1, -90.140));
		Else If(相距距离(所选位置(事件玩家), 矢量(-42.120, 1, -90.140)) <= 2);
			传送(事件玩家, 矢量(-38.150, 1, -86.960));
	}
}

规则("传送操作--漓江塔")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 假;
		按钮被按下(事件玩家, 按钮(装填)) == 假;
		按钮被按下(事件玩家, 按钮(技能2)) == 假;
		按钮被按下(事件玩家, 按钮(终极技能)) == 假;
		(当前地图 == 地图(漓江塔) || 当前地图 == 地图(春节漓江塔)) == 真;
		(事件玩家.AlreadyFaultTimes == 全局.FaultTimes + 1) == 假;
	}

	动作
	{
		If(相距距离(所选位置(事件玩家), 矢量(-54.280, 266.760, 335.240)) <= 2);
			传送(事件玩家, 矢量(-57.890, 267.600, 338.520));
		Else If(相距距离(所选位置(事件玩家), 矢量(-57.890, 267.600, 338.520)) <= 2);
			传送(事件玩家, 矢量(-54.280, 266.760, 335.240));
		Else If(相距距离(所选位置(事件玩家), 矢量(53.810, 266.950, 334.770)) <= 2);
			传送(事件玩家, 矢量(57.190, 267.590, 338.100));
		Else If(相距距离(所选位置(事件玩家), 矢量(57.190, 267.590, 338.100)) <= 2);
			传送(事件玩家, 矢量(53.810, 266.950, 334.770));
		Else If(相距距离(所选位置(事件玩家), 矢量(-65.570, 3.750, -31.460)) <= 2);
			传送(事件玩家, 矢量(-70.520, 4.480, -30.710));
		Else If(相距距离(所选位置(事件玩家), 矢量(-70.520, 4.480, -30.710)) <= 2);
			传送(事件玩家, 矢量(-65.570, 3.750, -31.460));
		Else If(相距距离(所选位置(事件玩家), 矢量(72.960, 4.470, -31.500)) <= 2);
			传送(事件玩家, 矢量(67.680, 3.750, -32.570));
		Else If(相距距离(所选位置(事件玩家), 矢量(67.680, 3.750, -32.570)) <= 2);
			传送(事件玩家, 矢量(72.960, 4.470, -31.500));
		Else If(相距距离(所选位置(事件玩家), 矢量(-69.240, 95.880, 145.790)) <= 2);
			传送(事件玩家, 矢量(-74.320, 96.570, 145.060));
		Else If(相距距离(所选位置(事件玩家), 矢量(-74.320, 96.570, 145.060)) <= 2);
			传送(事件玩家, 矢量(-69.240, 95.880, 145.790));
		Else If(相距距离(所选位置(事件玩家), 矢量(74.510, 96.570, 145.380)) <= 2);
			传送(事件玩家, 矢量(69.220, 95.920, 145.650));
		Else If(相距距离(所选位置(事件玩家), 矢量(69.220, 95.920, 145.650)) <= 2);
			传送(事件玩家, 矢量(74.510, 96.570, 145.380));
	}
}

规则("传送操作--国王大道")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 假;
		按钮被按下(事件玩家, 按钮(装填)) == 假;
		按钮被按下(事件玩家, 按钮(技能2)) == 假;
		按钮被按下(事件玩家, 按钮(终极技能)) == 假;
		(当前地图 == 地图(国王大道) || 当前地图 == 地图(圣诞节国王大道)) == 真;
		(事件玩家.AlreadyFaultTimes == 全局.FaultTimes + 1) == 假;
	}

	动作
	{
		If(相距距离(所选位置(事件玩家), 矢量(-3.040, 1.150, 22.330)) <= 2);
			传送(事件玩家, 矢量(-3.960, 0.070, 17.560));
		Else If(相距距离(所选位置(事件玩家), 矢量(-3.960, 0.070, 17.560)) <= 2);
			传送(事件玩家, 矢量(-3.040, 1.150, 22.330));
		Else If(相距距离(所选位置(事件玩家), 矢量(-1.130, 0.040, -38.250)) <= 2);
			传送(事件玩家, 矢量(3.750, -0.770, -38.940));
		Else If(相距距离(所选位置(事件玩家), 矢量(3.750, -0.770, -38.940)) <= 2);
			传送(事件玩家, 矢量(-1.130, 0.040, -38.250));
		Else If(相距距离(所选位置(事件玩家), 矢量(-90.130, 0.940, -27.950)) <= 2);
			传送(事件玩家, 矢量(-93.920, 1.500, -29.430));
		Else If(相距距离(所选位置(事件玩家), 矢量(-93.920, 1.500, -29.430)) <= 2);
			传送(事件玩家, 矢量(-90.130, 0.940, -27.950));
		Else If(相距距离(所选位置(事件玩家), 矢量(-166.340, 0.070, 15.370)) <= 2);
			传送(事件玩家, 矢量(-165.900, 0.070, 20.130));
		Else If(相距距离(所选位置(事件玩家), 矢量(-165.900, 0.070, 20.130)) <= 2);
			传送(事件玩家, 矢量(-166.340, 0.070, 15.370));
	}
}

规则("传送操作--渣客镇")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 假;
		按钮被按下(事件玩家, 按钮(装填)) == 假;
		按钮被按下(事件玩家, 按钮(技能2)) == 假;
		按钮被按下(事件玩家, 按钮(终极技能)) == 假;
		(当前地图 == 地图(渣客镇)) == 真;
		(事件玩家.AlreadyFaultTimes == 全局.FaultTimes + 1) == 假;
	}

	动作
	{
		If(相距距离(所选位置(事件玩家), 矢量(45.470, 10, -76.780)) <= 2);
			传送(事件玩家, 矢量(40.170, 10, -76.380));
		Else If(相距距离(所选位置(事件玩家), 矢量(40.170, 10, -76.380)) <= 2);
			传送(事件玩家, 矢量(45.470, 10, -76.780));
		Else If(相距距离(所选位置(事件玩家), 矢量(-39.950, 7.290, -114.920)) <= 2);
			传送(事件玩家, 矢量(-42.750, 6.420, -119.620));
		Else If(相距距离(所选位置(事件玩家), 矢量(-42.750, 6.420, -119.620)) <= 2);
			传送(事件玩家, 矢量(-39.950, 7.290, -114.920));
		Else If(相距距离(所选位置(事件玩家), 矢量(-79.920, 7.430, -171.760)) <= 2);
			传送(事件玩家, 矢量(-80.950, 7.440, -176.630));
		Else If(相距距离(所选位置(事件玩家), 矢量(-80.950, 7.440, -176.630)) <= 2);
			传送(事件玩家, 矢量(-79.920, 7.430, -171.760));
		Else If(相距距离(所选位置(事件玩家), 矢量(-38.620, 4.060, -16.050)) <= 2);
			传送(事件玩家, 矢量(-39.300, 4.270, -10.100));
		Else If(相距距离(所选位置(事件玩家), 矢量(-39.300, 4.270, -10.100)) <= 2);
			传送(事件玩家, 矢量(-38.620, 4.060, -16.050));
		Else If(相距距离(所选位置(事件玩家), 矢量(-56.330, 7.510, -84.990)) <= 2);
			传送(事件玩家, 矢量(-55.250, 9.060, -79.770));
		Else If(相距距离(所选位置(事件玩家), 矢量(-55.250, 9.060, -79.770)) <= 2);
			传送(事件玩家, 矢量(-56.330, 7.510, -84.990));
		Else If(相距距离(所选位置(事件玩家), 矢量(-106.830, 6.440, -107.880)) <= 2);
			传送(事件玩家, 矢量(-111.420, 6.440, -106.840));
		Else If(相距距离(所选位置(事件玩家), 矢量(-111.420, 6.440, -106.840)) <= 2);
			传送(事件玩家, 矢量(-106.830, 6.440, -107.880));
	}
}

规则("传送操作--里阿尔托")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 假;
		按钮被按下(事件玩家, 按钮(装填)) == 假;
		按钮被按下(事件玩家, 按钮(技能2)) == 假;
		按钮被按下(事件玩家, 按钮(终极技能)) == 假;
		(当前地图 == 地图(里阿尔托)) == 真;
		(事件玩家.AlreadyFaultTimes == 全局.FaultTimes + 1) == 假;
	}

	动作
	{
		If(相距距离(所选位置(事件玩家), 矢量(119.120, -1.240, -20.550)) <= 2);
			传送(事件玩家, 矢量(113.270, -1.250, -21.090));
		Else If(相距距离(所选位置(事件玩家), 矢量(113.270, -1.250, -21.090)) <= 2);
			传送(事件玩家, 矢量(119.120, -1.240, -20.550));
		Else If(相距距离(所选位置(事件玩家), 矢量(0.740, -0.250, -86.310)) <= 2);
			传送(事件玩家, 矢量(-4.610, -0.380, -85.920));
		Else If(相距距离(所选位置(事件玩家), 矢量(-4.610, -0.380, -85.920)) <= 2);
			传送(事件玩家, 矢量(0.740, -0.250, -86.310));
		Else If(相距距离(所选位置(事件玩家), 矢量(67.140, -0.250, -57.050)) <= 2);
			传送(事件玩家, 矢量(72.110, -0.250, -59.360));
		Else If(相距距离(所选位置(事件玩家), 矢量(72.110, -0.250, -59.360)) <= 2);
			传送(事件玩家, 矢量(67.140, -0.250, -57.050));
		Else If(相距距离(所选位置(事件玩家), 矢量(-15.700, -1.250, -30.500)) <= 2);
			传送(事件玩家, 矢量(-16.440, -1.230, -24.750));
		Else If(相距距离(所选位置(事件玩家), 矢量(-16.440, -1.230, -24.750)) <= 2);
			传送(事件玩家, 矢量(-15.700, -1.250, -30.500));
		Else If(相距距离(所选位置(事件玩家), 矢量(-74.200, 4.750, -148.720)) <= 2);
			传送(事件玩家, 矢量(-74.250, 4.750, -153.080));
		Else If(相距距离(所选位置(事件玩家), 矢量(-74.250, 4.750, -153.080)) <= 2);
			传送(事件玩家, 矢量(-74.200, 4.750, -148.720));
		Else If(相距距离(所选位置(事件玩家), 矢量(-40.860, 1.750, -110.390)) <= 2);
			传送(事件玩家, 矢量(-41.050, 0.530, -115.450));
		Else If(相距距离(所选位置(事件玩家), 矢量(-41.050, 0.530, -115.450)) <= 2);
			传送(事件玩家, 矢量(-40.860, 1.750, -110.390));
	}
}

规则("传送操作--暴-雪世界")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 假;
		按钮被按下(事件玩家, 按钮(装填)) == 假;
		按钮被按下(事件玩家, 按钮(技能2)) == 假;
		按钮被按下(事件玩家, 按钮(终极技能)) == 假;
		(当前地图 == 地图(暴雪世界) || 当前地图 == 地图(圣诞节暴雪世界)) == 真;
		(事件玩家.AlreadyFaultTimes == 全局.FaultTimes + 1) == 假;
	}

	动作
	{
		If(相距距离(所选位置(事件玩家), 矢量(3.020, -3.990, -22.900)) <= 2);
			传送(事件玩家, 矢量(2.900, -4.100, -18.260));
		Else If(相距距离(所选位置(事件玩家), 矢量(2.900, -4.100, -18.260)) <= 2);
			传送(事件玩家, 矢量(3.020, -3.990, -22.900));
		Else If(相距距离(所选位置(事件玩家), 矢量(-79.090, 0.790, 96.660)) <= 2);
			传送(事件玩家, 矢量(-83.900, 0.750, 96.870));
		Else If(相距距离(所选位置(事件玩家), 矢量(-83.900, 0.750, 96.870)) <= 2);
			传送(事件玩家, 矢量(-79.090, 0.790, 96.660));
		Else If(相距距离(所选位置(事件玩家), 矢量(-53.550, -0.250, 141.870)) <= 2);
			传送(事件玩家, 矢量(-58.590, 0.750, 140.320));
		Else If(相距距离(所选位置(事件玩家), 矢量(-58.590, 0.750, 140.320)) <= 2);
			传送(事件玩家, 矢量(-53.550, -0.250, 141.870));
		Else If(相距距离(所选位置(事件玩家), 矢量(-144.760, 0.750, 113.550)) <= 2);
			传送(事件玩家, 矢量(-146.780, 0.750, 118.350));
		Else If(相距距离(所选位置(事件玩家), 矢量(-146.780, 0.750, 118.350)) <= 2);
			传送(事件玩家, 矢量(-144.760, 0.750, 113.550));
		Else If(相距距离(所选位置(事件玩家), 矢量(-72.160, 1.750, 156.250)) <= 2);
			传送(事件玩家, 矢量(-72.970, 1.750, 160.480));
		Else If(相距距离(所选位置(事件玩家), 矢量(-72.970, 1.750, 160.480)) <= 2);
			传送(事件玩家, 矢量(-72.160, 1.750, 156.250));
	}
}

规则("传送操作--釜山")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 假;
		按钮被按下(事件玩家, 按钮(装填)) == 假;
		按钮被按下(事件玩家, 按钮(技能2)) == 假;
		按钮被按下(事件玩家, 按钮(终极技能)) == 假;
		当前地图 == 地图(釜山);
		(事件玩家.AlreadyFaultTimes == 全局.FaultTimes + 1) == 假;
	}

	动作
	{
		If(相距距离(所选位置(事件玩家), 矢量(-412.390, 10.110, 157.530)) <= 2);
			传送(事件玩家, 矢量(-406.850, 10.070, 156.910));
		Else If(相距距离(所选位置(事件玩家), 矢量(-406.850, 10.070, 156.910)) <= 2);
			传送(事件玩家, 矢量(-412.390, 10.110, 157.530));
		Else If(相距距离(所选位置(事件玩家), 矢量(-250.480, 10.350, 170.950)) <= 2);
			传送(事件玩家, 矢量(-245.880, 10.360, 171.240));
		Else If(相距距离(所选位置(事件玩家), 矢量(-245.880, 10.360, 171.240)) <= 2);
			传送(事件玩家, 矢量(-250.480, 10.350, 170.950));
		Else If(相距距离(所选位置(事件玩家), 矢量(156.070, 11.100, 261.940)) <= 2);
			传送(事件玩家, 矢量(160.340, 10.100, 260.110));
		Else If(相距距离(所选位置(事件玩家), 矢量(160.340, 10.100, 260.110)) <= 2);
			传送(事件玩家, 矢量(156.070, 11.100, 261.940));
		Else If(相距距离(所选位置(事件玩家), 矢量(283.030, 11.090, 207.640)) <= 2);
			传送(事件玩家, 矢量(278.850, 10.100, 209.360));
		Else If(相距距离(所选位置(事件玩家), 矢量(278.850, 10.100, 209.360)) <= 2);
			传送(事件玩家, 矢量(283.030, 11.090, 207.640));
		Else If(相距距离(所选位置(事件玩家), 矢量(121, 17, -125.350)) <= 2);
			传送(事件玩家, 矢量(116.110, 16.250, -125.490));
		Else If(相距距离(所选位置(事件玩家), 矢量(116.110, 16.250, -125.490)) <= 2);
			传送(事件玩家, 矢量(121, 17, -125.350));
		Else If(相距距离(所选位置(事件玩家), 矢量(-12.090, 16.130, -125.560)) <= 2);
			传送(事件玩家, 矢量(-17.280, 17, -125.590));
		Else If(相距距离(所选位置(事件玩家), 矢量(-17.280, 17, -125.590)) <= 2);
			传送(事件玩家, 矢量(-12.090, 16.130, -125.560));
	}
}

规则("传送操作--月球基地")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 假;
		按钮被按下(事件玩家, 按钮(装填)) == 假;
		按钮被按下(事件玩家, 按钮(技能2)) == 假;
		按钮被按下(事件玩家, 按钮(终极技能)) == 假;
		当前地图 == 地图(“地平线”月球基地);
		(事件玩家.AlreadyFaultTimes == 全局.FaultTimes + 1) == 假;
	}

	动作
	{
		If(相距距离(所选位置(事件玩家), 矢量(12.170, 9, -9.430)) <= 2);
			传送(事件玩家, 矢量(15.940, 9, -11.130));
		Else If(相距距离(所选位置(事件玩家), 矢量(15.940, 9, -11.130)) <= 2);
			传送(事件玩家, 矢量(12.170, 9, -9.430));
		Else If(相距距离(所选位置(事件玩家), 矢量(58.700, 8.990, -92.990)) <= 2);
			传送(事件玩家, 矢量(63.710, 9, -92.660));
		Else If(相距距离(所选位置(事件玩家), 矢量(63.710, 9, -92.660)) <= 2);
			传送(事件玩家, 矢量(58.700, 8.990, -92.990));
		Else If(相距距离(所选位置(事件玩家), 矢量(-47.890, 5, -137.350)) <= 2);
			传送(事件玩家, 矢量(-44.150, 5, -140.270));
		Else If(相距距离(所选位置(事件玩家), 矢量(-44.150, 5, -140.270)) <= 2);
			传送(事件玩家, 矢量(-47.890, 5, -137.350));
	}
}

规则("传送操作--哈瓦那")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 假;
		按钮被按下(事件玩家, 按钮(装填)) == 假;
		按钮被按下(事件玩家, 按钮(技能2)) == 假;
		按钮被按下(事件玩家, 按钮(终极技能)) == 假;
		(当前地图 == 地图(哈瓦那)) == 真;
		(事件玩家.AlreadyFaultTimes == 全局.FaultTimes + 1) == 假;
	}

	动作
	{
		If(相距距离(所选位置(事件玩家), 矢量(-82.460, 4, -65.590)) <= 2);
			传送(事件玩家, 矢量(-79.250, 4, -62.700));
		Else If(相距距离(所选位置(事件玩家), 矢量(-79.250, 4, -62.700)) <= 2);
			传送(事件玩家, 矢量(-82.460, 4, -65.590));
		Else If(相距距离(所选位置(事件玩家), 矢量(-43.290, 6, -86.130)) <= 2);
			传送(事件玩家, 矢量(-38.570, 6, -86.070));
		Else If(相距距离(所选位置(事件玩家), 矢量(-38.570, 6, -86.070)) <= 2);
			传送(事件玩家, 矢量(-43.290, 6, -86.130));
		Else If(相距距离(所选位置(事件玩家), 矢量(57.210, 4.870, -72.940)) <= 2);
			传送(事件玩家, 矢量(57.240, 6.060, -77.450));
		Else If(相距距离(所选位置(事件玩家), 矢量(57.240, 6.060, -77.450)) <= 2);
			传送(事件玩家, 矢量(57.210, 4.870, -72.940));
		Else If(相距距离(所选位置(事件玩家), 矢量(69.230, 5, -107.010)) <= 2);
			传送(事件玩家, 矢量(69.080, 4.990, -101.650));
		Else If(相距距离(所选位置(事件玩家), 矢量(69.080, 4.990, -101.650)) <= 2);
			传送(事件玩家, 矢量(69.230, 5, -107.010));
		Else If(相距距离(所选位置(事件玩家), 矢量(92.430, 8.030, -33.670)) <= 2);
			传送(事件玩家, 矢量(92.370, 9, -28.880));
		Else If(相距距离(所选位置(事件玩家), 矢量(92.370, 9, -28.880)) <= 2);
			传送(事件玩家, 矢量(92.430, 8.030, -33.670));
		Else If(相距距离(所选位置(事件玩家), 矢量(158.580, 11.010, -62.080)) <= 2);
			传送(事件玩家, 矢量(153.180, 9.990, -62.440));
		Else If(相距距离(所选位置(事件玩家), 矢量(153.180, 9.990, -62.440)) <= 2);
			传送(事件玩家, 矢量(158.580, 11.010, -62.080));
		Else If(相距距离(所选位置(事件玩家), 矢量(1.281, 7.250, -48.435)) <= 2);
			传送(事件玩家, 矢量(1.229, 7.250, -42.409));
		Else If(相距距离(所选位置(事件玩家), 矢量(1.229, 7.250, -42.409)) <= 2);
			传送(事件玩家, 矢量(1.281, 7.250, -48.435));
		Else If(相距距离(所选位置(事件玩家), 矢量(-35.657, 7.094, -17.142)) <= 2);
			传送(事件玩家, 矢量(-34.935, 7.093, -28.184));
		Else If(相距距离(所选位置(事件玩家), 矢量(-34.935, 7.093, -28.184)) <= 2);
			传送(事件玩家, 矢量(-35.657, 7.094, -17.142));
		Else If(相距距离(所选位置(事件玩家), 矢量(-106.240, 5.100, -28.772)) <= 2);
			传送(事件玩家, 矢量(-99.279, 5.100, -37.757));
		Else If(相距距离(所选位置(事件玩家), 矢量(-99.279, 5.100, -37.757)) <= 2);
			传送(事件玩家, 矢量(-106.240, 5.100, -28.772));
		Else If(相距距离(所选位置(事件玩家), 矢量(-79.281, 5.262, -93.094)) <= 2);
			传送(事件玩家, 矢量(-83.951, 5.250, -88.796));
		Else If(相距距离(所选位置(事件玩家), 矢量(-83.951, 5.250, -88.796)) <= 2);
			传送(事件玩家, 矢量(-79.281, 5.262, -93.094));
		Else If(相距距离(所选位置(事件玩家), 矢量(-114.377, 5.100, -85.357)) <= 2);
			传送(事件玩家, 矢量(-113.017, 5.250, -78.268));
		Else If(相距距离(所选位置(事件玩家), 矢量(-113.017, 5.250, -78.268)) <= 2);
			传送(事件玩家, 矢量(-114.377, 5.100, -85.357));
	}
}

规则("占点图地图中心点位")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	动作
	{
		If(当前地图 == 地图(漓江塔) || 当前地图 == 地图(春节漓江塔));
			事件玩家.TeleportE[0] = 矢量(-0.350, 270, 298.320);
			事件玩家.TeleportE[1] = 矢量(1.080, -1.140, -29.840);
			事件玩家.TeleportE[2] = 矢量(-0.450, 94.050, 134.360);
			事件玩家.TeleportName[0] = 自定义字符串("控制中心");
			事件玩家.TeleportName[1] = 自定义字符串("夜市");
			事件玩家.TeleportName[2] = 自定义字符串("庭院");
		Else If(当前地图 == 地图(釜山));
			事件玩家.TeleportE[0] = 矢量(-328.400, 8.210, 131.160);
			事件玩家.TeleportE[1] = 矢量(51.790, 10, -110.930);
			事件玩家.TeleportE[2] = 矢量(215.370, 17.190, 225.010);
			事件玩家.TeleportName[0] = 自定义字符串("寺院");
			事件玩家.TeleportName[1] = 自定义字符串("城区");
			事件玩家.TeleportName[2] = 自定义字符串("体育场");
	}
}

规则("占点图按E传送地图")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(技能2)) == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 假;
		按钮被按下(事件玩家, 按钮(跳跃)) == 假;
		按钮被按下(事件玩家, 按钮(互动)) == 假;
		(当前地图 == 地图(漓江塔) || 当前地图 == 地图(春节漓江塔) || 当前地图 == 地图(尼泊尔) || 当前地图 == 地图(伊利奥斯) || 当前地图 == 地图(绿洲城) || 当前地图 == 地图(釜山)) == 真;
		(事件玩家.AlreadyFaultTimes == 全局.FaultTimes + 1) == 假;
		存活(事件玩家) == 真;
	}

	动作
	{
		根据条件跳过(事件玩家.TeleportENum != 2, 1);
		事件玩家.TeleportENum = -1;
		传送(事件玩家, 事件玩家.TeleportE[事件玩家.TeleportENum + 1]);
		播放效果(所有玩家(所有队伍), 环状爆炸声音, 颜色(白色), 事件玩家, 100);
		事件玩家.TeleportENum += 1;
		禁用 If(当前地图 == 地图(春节漓江塔控制中心) || 当前地图 == 地图(漓江塔控制中心));
		禁用 传送(事件玩家, 矢量(1.080, -1.140, -29.840));
		禁用 Else If(事件玩家.TeleportENum == 2);
		禁用 传送(事件玩家, 矢量(-0.450, 94.050, 134.360));
		禁用 Else If(当前地图 == 地图(春节漓江塔庭院) || 当前地图 == 地图(漓江塔庭院));
		禁用 传送(事件玩家, 矢量(-0.350, 270, 298.320));
		大字体信息(事件玩家, 自定义字符串("传送至——{0}", 事件玩家.TeleportName[事件玩家.TeleportENum]));
		等待(1, 无视条件);
	}
}

规则("发你好提示是否在附近")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		正在交流(事件玩家, 问候) == 真;
		已重生(事件玩家) == 真;
		事件玩家.FinishGame == 假;
	}

	动作
	{
		If(相距距离(所选位置(事件玩家), 事件玩家.CurrentCheckpoints[事件玩家.CurrentCheckpointNum]) <= 全局.HelloTipRadius && 事件玩家.HelloTip == 0);
			小字体信息(事件玩家, 自定义字符串("在附近"));
			事件玩家.HelloTip = 全局.HelloTipTime;
			持续追踪玩家变量(事件玩家, HelloTip, 0, 全局.HelloTipTime, 终点及持续时间);
		Else If(相距距离(所选位置(事件玩家), 事件玩家.CurrentCheckpoints[事件玩家.CurrentCheckpointNum]) > 全局.HelloTipRadius && 事件玩家.HelloTip == 0);
			小字体信息(事件玩家, 自定义字符串("不在附近"));
			事件玩家.HelloTip = 全局.HelloTipTime;
			持续追踪玩家变量(事件玩家, HelloTip, 0, 全局.HelloTipTime, 终点及持续时间);
		Else;
			小字体信息(事件玩家, 自定义字符串("距离下次提示可用还有{0}分钟{1}秒", 取整(事件玩家.HelloTip / 60, 下), 取整(事件玩家.HelloTip % 60, 下)));
		End;
	}
}

禁用 规则("重置通关特效")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.FinishGame == 真;
		按钮被按下(事件玩家, 按钮(装填)) == 真;
		已重生(事件玩家) == 真;
	}

	动作
	{
		等待(2, 无视条件);
		如条件为“假”则中止;
		消除效果(事件玩家.FireEffect[0]);
		消除效果(事件玩家.FireEffect[1]);
		消除效果(事件玩家.FireEffect[2]);
		消除效果(事件玩家.FireEffect[3]);
		创建效果(所有玩家(所有队伍), 火花, 颜色(绿色), 事件玩家, 0.350, 可见，位置和半径);
		事件玩家.FireEffect[0] = 最后创建的实体;
		创建效果(所有玩家(所有队伍), 火花, 颜色(蓝色), 事件玩家, 0.350, 可见，位置和半径);
		事件玩家.FireEffect[1] = 最后创建的实体;
		创建效果(所有玩家(所有队伍), 火花, 颜色(亮紫色), 事件玩家, 0.350, 可见，位置和半径);
		事件玩家.FireEffect[2] = 最后创建的实体;
		创建效果(所有玩家(所有队伍), 火花, 颜色(橙色), 事件玩家, 0.350, 可见，位置和半径);
		事件玩家.FireEffect[3] = 最后创建的实体;
		小字体信息(事件玩家, 自定义字符串("已重置特效"));
	}
}

规则("顶部描述")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		While(真);
			设置目标点描述(所有玩家(所有队伍), 自定义字符串("按住右键看图，再按左键回看\r\n    互动键 F         确认图片\r\n  长按 SHIFT       加速移动\r\n    CTRL 键        进出传送门"), 可见和字符串);
			等待(5, 无视条件);
			设置目标点描述(所有玩家(所有队伍), 自定义字符串("  发送“你好”     关卡提示\r\n       F+E             进入观战\r\n       R+V            强制传送\r\n30关之后，长按空格键可飞行"),
				可见和字符串);
			等待(5, 无视条件);
			设置目标点描述(所有玩家(所有队伍), 自定义字符串("作者：{0}\r\n代码：{1}", 全局.MapDesigner, 全局.ShareCode, 全局.ThanksList), 可见和字符串);
			等待(5, 无视条件);
		End;
	}
}

规则("编辑器代码：5DVHH")
{
	事件
	{
		持续 - 全局;
	}
}

规则("地图传送点位圈圈设置")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		If(当前地图 == 地图(万圣节艾兴瓦尔德) || 当前地图 == 地图(艾兴瓦尔德));
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-11.720, 0, -9.070), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-12.530, 1, -4.470), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-6.630, 3.550, -85.450), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-11.950, 5.300, -87.800), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(74.740, 10.700, -109.200), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(73.390, 10.720, -115.110), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(115.040, 10.720, -13.410), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(112.580, 10.740, -9.720), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(87.070, 12.860, -101.270), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(91.980, 12.720, -103.740), 2, 可见，位置和半径);
		Else If(当前地图 == 地图(圣诞节花村) || 当前地图 == 地图(花村));
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(76.470, -2, 0.150), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(71.460, -1.950, 0.040), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(13.990, -1, 13.530), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(14.060, 0, 8.360), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-38.150, 1, -86.960), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-42.120, 1, -90.140), 2, 可见，位置和半径);
		Else If(当前地图 == 地图(漓江塔) || 当前地图 == 地图(春节漓江塔));
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-54.280, 266.760, 335.240), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-57.890, 267.600, 338.520), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(53.810, 266.950, 334.770), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(57.190, 267.590, 338.100), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(72.960, 4.470, -31.500), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(67.680, 3.750, -32.570), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-69.240, 95.880, 145.790), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-74.320, 96.570, 145.060), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(74.510, 96.570, 145.380), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(69.220, 95.920, 145.650), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-65.570, 3.750, -31.460), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-70.520, 4.480, -30.710), 2, 可见，位置和半径);
		Else If(当前地图 == 地图(国王大道) || 当前地图 == 地图(圣诞节国王大道));
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-3.040, 1.150, 22.330), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-3.960, 0.070, 17.560), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-1.130, 0.040, -38.250), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(3.750, -0.770, -38.940), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-90.130, 0.940, -27.950), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-93.920, 1.500, -29.430), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-166.340, 0.070, 15.370), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-165.900, 0.070, 20.130), 2, 可见，位置和半径);
		Else If(当前地图 == 地图(渣客镇));
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(45.470, 10, -76.780), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(40.170, 10, -76.380), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-39.950, 7.290, -114.920), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-42.750, 6.420, -119.620), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-79.920, 7.430, -171.760), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-80.950, 7.440, -176.630), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-38.620, 4.060, -16.050), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-39.300, 4.270, -10.100), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-56.330, 7.510, -84.990), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-55.250, 9.060, -79.770), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-106.830, 6.440, -107.880), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-111.420, 6.440, -106.840), 2, 可见，位置和半径);
		Else If(当前地图 == 地图(里阿尔托));
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(0.740, -0.250, -86.310), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-4.610, -0.380, -85.920), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(67.140, -0.250, -57.050), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(72.110, -0.250, -59.360), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-15.700, -1.250, -30.500), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-16.440, -1.230, -24.750), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-74.200, 4.750, -148.720), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-74.250, 4.750, -153.080), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-40.860, 1.750, -110.390), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-41.050, 0.530, -115.450), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(119.120, -1.240, -20.550), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(113.270, -1.250, -21.090), 2, 可见，位置和半径);
		Else If(当前地图 == 地图(暴雪世界) || 当前地图 == 地图(圣诞节暴雪世界));
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(3.020, -3.990, -22.900), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(2.900, -4.100, -18.260), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-79.090, 0.790, 96.660), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-83.900, 0.750, 96.870), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-53.550, -0.250, 141.870), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-58.590, 0.750, 140.320), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-144.760, 0.750, 113.550), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-146.780, 0.750, 118.350), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-72.160, 1.750, 156.250), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-72.970, 1.750, 160.480), 2, 可见，位置和半径);
		Else If(当前地图 == 地图(釜山));
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-412.390, 10.110, 157.530), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-406.850, 10.070, 156.910), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-250.480, 10.350, 170.950), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-245.880, 10.360, 171.240), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(156.070, 11.100, 261.940), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(160.340, 10.100, 260.110), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(283.030, 11.090, 207.640), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(278.850, 10.100, 209.360), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(121, 17, -125.350), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(116.110, 16.250, -125.490), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-12.090, 16.130, -125.560), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-17.280, 17, -125.590), 2, 可见，位置和半径);
		Else If(当前地图 == 地图(“地平线”月球基地));
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(12.170, 9, -9.430), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(15.940, 9, -11.130), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(58.700, 8.990, -92.990), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(63.710, 9, -92.660), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-47.890, 5, -137.350), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-44.150, 5, -140.270), 2, 可见，位置和半径);
		Else If(当前地图 == 地图(哈瓦那));
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-82.460, 4, -65.590), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-79.250, 4, -62.700), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-43.290, 6, -86.130), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-38.570, 6, -86.070), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(57.210, 4.870, -72.940), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(57.240, 6.060, -77.450), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(69.230, 5, -107.010), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(69.080, 4.990, -101.650), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(92.430, 8.030, -33.670), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(92.370, 9, -28.880), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(158.580, 11.010, -62.080), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(153.180, 9.990, -62.440), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(1.281, 7.250, -48.435), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(1.229, 7.250, -42.409), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-35.657, 7.094, -17.142), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-34.935, 7.093, -28.184), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-106.240, 5.100, -28.772), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-99.279, 5.100, -37.757), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-79.390, 5.250, -93.697), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-83.951, 5.250, -88.796), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-114.377, 5.100, -85.357), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-113.017, 5.250, -78.268), 2, 可见，位置和半径);
		Else If(当前地图 == 地图(好莱坞) || 当前地图 == 地图(万圣节好莱坞));
			创建效果(所有玩家(所有队伍), 环, 颜色(青绿色), 矢量(-12.238, 2.257, 70.968), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(青绿色), 矢量(-12.168, 3.250, 78.201), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(青绿色), 矢量(-47.659, 3, -3.396), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(青绿色), 矢量(-51.450, 3, -5.555), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(青绿色), 矢量(-9.271, 2.980, -53.173), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(青绿色), 矢量(-11.991, 3, -48.274), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(青绿色), 矢量(-36.930, 5, -146.763), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(青绿色), 矢量(-38.745, 5, -154.229), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(青绿色), 矢量(35.890, 4, -53.152), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(青绿色), 矢量(-6.104, 4, -126.797), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(青绿色), 矢量(-7.157, 4, -130.950), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(青绿色), 矢量(26.792, 3.981, -53.181), 2, 可见，位置和半径);
		Else If(当前地图 == 地图(阿努比斯神殿));
			创建效果(所有玩家(所有队伍), 环, 颜色(白色), 矢量(-46.776, 2.962, 35.473), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(白色), 矢量(-50.267, 2.959, 33.216), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(白色), 矢量(2.352, 1.665, -19.185), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(白色), 矢量(5.179, 2.223, -23.878), 2, 可见，位置和半径);
		Else If(当前地图 == 地图(多拉多));
			创建效果(所有玩家(所有队伍), 环, 颜色(亮紫色), 矢量(55.032, 8.212, -35.447), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(亮紫色), 矢量(41.668, 8.462, -55.982), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(亮紫色), 矢量(142.771, 11.450, -1.233), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(亮紫色), 矢量(162.216, 11.462, -6.691), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(亮紫色), 矢量(80.706, 14.450, 25.674), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(亮紫色), 矢量(65.702, 15.462, 14.122), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(亮紫色), 矢量(168.155, 12.450, 46.767), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(亮紫色), 矢量(173.264, 10.934, 47.945), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(亮紫色), 矢量(207.007, 16.450, 47.105), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(亮紫色), 矢量(243.184, 16.460, 48.640), 2, 可见，位置和半径);
	}
}

规则("传送操作--好莱坞&万圣节好莱坞")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 假;
		按钮被按下(事件玩家, 按钮(装填)) == 假;
		按钮被按下(事件玩家, 按钮(技能2)) == 假;
		按钮被按下(事件玩家, 按钮(终极技能)) == 假;
		(当前地图 == 地图(万圣节好莱坞) || 当前地图 == 地图(好莱坞)) == 真;
		(事件玩家.AlreadyFaultTimes == 全局.FaultTimes + 1) == 假;
	}

	动作
	{
		If(相距距离(所选位置(事件玩家), 矢量(-12.238, 2.257, 70.968)) <= 2);
			传送(事件玩家, 矢量(-12.168, 3.250, 78.201));
		Else If(相距距离(所选位置(事件玩家), 矢量(-12.168, 3.250, 78.201)) <= 2);
			传送(事件玩家, 矢量(-12.238, 2.250, 70.968));
		Else If(相距距离(所选位置(事件玩家), 矢量(-47.659, 3, -3.396)) <= 2);
			传送(事件玩家, 矢量(-51.450, 3, -5.555));
		Else If(相距距离(所选位置(事件玩家), 矢量(-51.450, 3, -5.555)) <= 2);
			传送(事件玩家, 矢量(-47.659, 3, -3.396));
		Else If(相距距离(所选位置(事件玩家), 矢量(-9.271, 2.980, -53.173)) <= 2);
			传送(事件玩家, 矢量(-11.991, 3, -48.274));
		Else If(相距距离(所选位置(事件玩家), 矢量(-11.991, 3, -48.274)) <= 2);
			传送(事件玩家, 矢量(-9.271, 2.980, -53.173));
		Else If(相距距离(所选位置(事件玩家), 矢量(-36.930, 5, -146.763)) <= 2);
			传送(事件玩家, 矢量(-38.745, 5, -154.229));
		Else If(相距距离(所选位置(事件玩家), 矢量(-38.745, 5, -154.229)) <= 2);
			传送(事件玩家, 矢量(-36.930, 5, -146.763));
		Else If(相距距离(所选位置(事件玩家), 矢量(35.830, 4, -53.152)) <= 2);
			传送(事件玩家, 矢量(26.792, 3.981, -53.181));
		Else If(相距距离(所选位置(事件玩家), 矢量(26.792, 3.981, -53.181)) <= 2);
			传送(事件玩家, 矢量(35.890, 4, -53.152));
		Else If(相距距离(所选位置(事件玩家), 矢量(-6.104, 4, -126.797)) <= 2);
			传送(事件玩家, 矢量(-7.157, 4, -130.950));
		Else If(相距距离(所选位置(事件玩家), 矢量(-7.157, 4, -130.950)) <= 2);
			传送(事件玩家, 矢量(-6.104, 4, -126.797));
	}
}

规则("遇到bug或者卡主的操作，每个地图在这里设置")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		(事件玩家.AlreadyFaultTimes == 全局.FaultTimes + 1) == 假;
		事件玩家.EditCamMode == 假;
		按钮被按下(事件玩家, 按钮(装填)) == 真;
		按钮被按下(事件玩家, 按钮(近身攻击)) == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 假;
		按钮被按下(事件玩家, 按钮(互动)) == 假;
	}

	动作
	{
		传送(事件玩家, 矢量(64.064, 15.005, -17.488));
	}
}

禁用 规则("操作提示提醒")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
	}

	动作
	{
		创建HUD文本(事件玩家, 自定义字符串("↑上方操作提示，我看谁还看不见！！！！↑"), 空, 空, 顶部, 10, 颜色(玫红), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		等待(30, 无视条件);
		消除HUD文本(上一个文本ID);
	}
}

规则("传送操作--阿努比斯神殿")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 假;
		按钮被按下(事件玩家, 按钮(装填)) == 假;
		按钮被按下(事件玩家, 按钮(技能2)) == 假;
		按钮被按下(事件玩家, 按钮(终极技能)) == 假;
		(当前地图 == 地图(阿努比斯神殿)) == 真;
		(事件玩家.AlreadyFaultTimes == 全局.FaultTimes + 1) == 假;
	}

	动作
	{
		If(相距距离(所选位置(事件玩家), 矢量(-46.776, 2.962, 35.473)) <= 2);
			传送(事件玩家, 矢量(-50.267, 2.959, 33.216));
		Else If(相距距离(所选位置(事件玩家), 矢量(-50.267, 2.959, 33.216)) <= 2);
			传送(事件玩家, 矢量(-46.776, 2.962, 35.473));
		Else If(相距距离(所选位置(事件玩家), 矢量(2.352, 1.665, -19.185)) <= 2);
			传送(事件玩家, 矢量(5.179, 2.223, -23.878));
		Else If(相距距离(所选位置(事件玩家), 矢量(5.179, 2.223, -23.878)) <= 2);
			传送(事件玩家, 矢量(2.352, 1.665, -19.185));
	}
}

规则("传送操作--多拉多")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 假;
		按钮被按下(事件玩家, 按钮(装填)) == 假;
		按钮被按下(事件玩家, 按钮(技能2)) == 假;
		按钮被按下(事件玩家, 按钮(终极技能)) == 假;
		(当前地图 == 地图(多拉多)) == 真;
		(事件玩家.AlreadyFaultTimes == 全局.FaultTimes + 1) == 假;
	}

	动作
	{
		If(相距距离(所选位置(事件玩家), 矢量(55.032, 8.212, -35.447)) <= 2);
			传送(事件玩家, 矢量(41.668, 8.462, -55.982));
		Else If(相距距离(所选位置(事件玩家), 矢量(41.668, 8.462, -55.982)) <= 2);
			传送(事件玩家, 矢量(55.032, 8.212, -35.447));
		Else If(相距距离(所选位置(事件玩家), 矢量(142.771, 11.450, -1.233)) <= 2);
			传送(事件玩家, 矢量(162.216, 11.462, -6.691));
		Else If(相距距离(所选位置(事件玩家), 矢量(162.216, 11.462, -6.691)) <= 2);
			传送(事件玩家, 矢量(142.771, 11.450, -1.233));
		Else If(相距距离(所选位置(事件玩家), 矢量(80.706, 14.450, 25.674)) <= 2);
			传送(事件玩家, 矢量(65.702, 15.462, 14.122));
		Else If(相距距离(所选位置(事件玩家), 矢量(65.702, 15.462, 14.122)) <= 2);
			传送(事件玩家, 矢量(80.706, 14.450, 25.674));
		Else If(相距距离(所选位置(事件玩家), 矢量(168.155, 12.450, 46.767)) <= 2);
			传送(事件玩家, 矢量(173.264, 10.934, 47.945));
		Else If(相距距离(所选位置(事件玩家), 矢量(173.264, 10.934, 47.945)) <= 2);
			传送(事件玩家, 矢量(168.155, 12.450, 46.767));
		Else If(相距距离(所选位置(事件玩家), 矢量(207.007, 16.450, 47.105)) <= 2);
			传送(事件玩家, 矢量(243.184, 16.460, 48.640));
		Else If(相距距离(所选位置(事件玩家), 矢量(243.184, 16.460, 48.640)) <= 2);
			传送(事件玩家, 矢量(207.007, 16.450, 47.105));
	}
}

规则("通关彩蛋")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.FinishGame == 真;
	}

	动作
	{
		创建效果(事件玩家, 云, 颜色(黑色), 矢量(31.749, 5.462, -35.749), 1, 可见，位置和半径);
		创建HUD文本(事件玩家, 自定义字符串("请寻找隐藏在地图某处的彩蛋吧！彩蛋用云状特效标识"), 空, 空, 顶部, 0, 颜色(红色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
	}
}

规则("通关彩蛋传送")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.FinishGame == 真;
		按钮被按下(事件玩家, 按钮(互动)) == 真;
	}

	动作
	{
		If(相距距离(所选位置(事件玩家), 矢量(31.758, 5.265, -35.759)) <= 2);
			传送(事件玩家, 矢量(167.504, 126.537, 36.320));
			创建地图文本(事件玩家, 自定义字符串("恭喜通关~  感谢游玩！"), 矢量(160.568, 125.781, 45.320), 3, 根据表面截取, 可见，位置和字符串, 颜色(橙色), 默认可见度);
			创建地图文本(事件玩家, 自定义字符串(
				"昨 夜 星 辰 昨 夜 风，画 楼 西 畔 桂 堂 东。\r\n身 无 彩 凤 双 飞 翼，心 有 灵 犀 一 点 通。\r\n                           OwO\r\n       请尽情欣赏多拉多的美丽夜景吧~"),
				矢量(160.568, 125.781, 33.320), 2, 根据表面截取, 可见，位置和字符串, 颜色(水绿色), 默认可见度);
			创建地图文本(事件玩家, 自定义字符串(
				"其他地图：\r\nSWWJV    花村\r\nDGBBT     好莱坞\r\n4B4S9      国王大道\r\nDZMYN   哈瓦那\r\n1796C      月球基地\r\nR0HX2     66号公路\r\n02B4V     哈瓦那（不出图）\r\n{0}",
				自定义字符串("FGDSZ     里阿尔托\r\n3CPBG    阿努比斯神殿")), 矢量(160.568, 125.781, 5.320), 2, 根据表面截取, 可见，位置和字符串, 颜色(玫红), 默认可见度);
			隐藏英雄HUD(事件玩家);
			隐藏游戏模式HUD(事件玩家);
			隐藏信息(事件玩家);
			事件玩家.CAIDAN = 1;
	}
}

规则("消除文本")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.FinishGame == 真;
		按钮被按下(事件玩家, 按钮(装填)) == 真;
		按钮被按下(事件玩家, 按钮(近身攻击)) == 真;
		事件玩家.CAIDAN == 真;
	}

	动作
	{
		消除所有地图文本;
		显示英雄HUD(事件玩家);
		显示游戏模式HUD(事件玩家);
		显示信息(事件玩家);
	}
}

规则("星星弹幕自动")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.CAIDAN == 真;
	}

	动作
	{
		创建效果(事件玩家, 火花, 颜色(黄色), 矢量(X方向分量(眼睛位置(事件玩家)), Y方向分量(眼睛位置(事件玩家)) + 1, Z方向分量(眼睛位置(事件玩家))), 300, 可见，位置和半径);
		创建效果(事件玩家, 火花, 颜色(绿色), 矢量(X方向分量(眼睛位置(事件玩家)), Y方向分量(眼睛位置(事件玩家)) + 2, Z方向分量(眼睛位置(事件玩家))), 300, 可见，位置和半径);
		创建效果(事件玩家, 火花, 颜色(紫色), 矢量(X方向分量(眼睛位置(事件玩家)), Y方向分量(眼睛位置(事件玩家)) + 3, Z方向分量(眼睛位置(事件玩家))), 300, 可见，位置和半径);
		创建效果(事件玩家, 火花, 颜色(红色), 矢量(X方向分量(眼睛位置(事件玩家)), Y方向分量(眼睛位置(事件玩家)) + 4, Z方向分量(眼睛位置(事件玩家))), 300, 可见，位置和半径);
		创建效果(事件玩家, 火花, 颜色(蓝色), 矢量(X方向分量(眼睛位置(事件玩家)), Y方向分量(眼睛位置(事件玩家)) + 5, Z方向分量(眼睛位置(事件玩家))), 300, 可见，位置和半径);
		创建效果(事件玩家, 火花, 颜色(蓝色), 矢量(X方向分量(眼睛位置(事件玩家)), Y方向分量(眼睛位置(事件玩家)) + -1, Z方向分量(眼睛位置(事件玩家))), 300, 可见，位置和半径);
		创建效果(事件玩家, 火花, 颜色(红色), 矢量(X方向分量(眼睛位置(事件玩家)), Y方向分量(眼睛位置(事件玩家)) + -2, Z方向分量(眼睛位置(事件玩家))), 300, 可见，位置和半径);
		创建效果(事件玩家, 火花, 颜色(紫色), 矢量(X方向分量(眼睛位置(事件玩家)), Y方向分量(眼睛位置(事件玩家)) + -3, Z方向分量(眼睛位置(事件玩家))), 300, 可见，位置和半径);
		创建效果(事件玩家, 火花, 颜色(绿色), 矢量(X方向分量(眼睛位置(事件玩家)), Y方向分量(眼睛位置(事件玩家)) + -4, Z方向分量(眼睛位置(事件玩家))), 300, 可见，位置和半径);
		创建效果(事件玩家, 火花, 颜色(黄色), 矢量(X方向分量(眼睛位置(事件玩家)), Y方向分量(眼睛位置(事件玩家)) + -5, Z方向分量(眼睛位置(事件玩家))), 300, 可见，位置和半径);
		创建效果(事件玩家, 火花, 颜色(亮紫色), 矢量(X方向分量(眼睛位置(事件玩家)), Y方向分量(眼睛位置(事件玩家)) + 6, Z方向分量(眼睛位置(事件玩家))), 300, 可见，位置和半径);
		创建效果(事件玩家, 火花, 颜色(天蓝色), 矢量(X方向分量(眼睛位置(事件玩家)), Y方向分量(眼睛位置(事件玩家)) + 7, Z方向分量(眼睛位置(事件玩家))), 300, 可见，位置和半径);
		创建效果(事件玩家, 火花, 颜色(玫红), 矢量(X方向分量(眼睛位置(事件玩家)), Y方向分量(眼睛位置(事件玩家)) + -6, Z方向分量(眼睛位置(事件玩家))), 300, 可见，位置和半径);
		创建效果(事件玩家, 火花, 颜色(青绿色), 矢量(X方向分量(眼睛位置(事件玩家)), Y方向分量(眼睛位置(事件玩家)) + -7, Z方向分量(眼睛位置(事件玩家))), 300, 可见，位置和半径);
	}
}