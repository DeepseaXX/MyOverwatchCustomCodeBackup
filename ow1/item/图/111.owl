变量
{
	全局:
		0: AllowInvisible
		1: Checkpoints
		2: DesignMode
		3: RestartHourLeft
		4: CheckCampoints
		5: DistanceToPoint
		6: CamSpeed
		7: FaultTimes
		8: MapDesigner
		9: ShareCode
		10: ThanksList
		11: RankList
		12: PlayerList
		13: UnlockFlyNum
		14: HelloTipTime
		15: HelloTipRadius

	玩家:
		0: PlayerName
		1: Invisible
		3: FinishGame
		4: CurrentCheckpoints
		5: CurrentCheckpointNum
		6: CurrentPlayerpoint
		7: Getit
		8: CurrentCheckCampoints
		9: PicNum
		10: TempNum
		11: EditCamMode
		12: EditCampoint
		13: TempCampoint
		14: TempCamSpeed
		15: CamSpeedLevel
		16: AlreadyFaultTimes
		17: HUDdescribe1
		18: HUDdescribe2
		19: HUDdescribe3
		21: CounterI
		22: CurrentRankList
		23: PlayerListpoint
		24: HUDdescribe4
		25: PicView
		26: HUDdescribe5
		27: HUDdescribe6
		28: TeleportE
		29: TeleportENum
		30: ObserverMode
		31: TempHorizontalAngle
		32: TempNum2
		33: HelloTip
		34: FireEffect
		35: GetitEffect
		36: TeleportName
		37: TIME
		38: timer
		39: range
		40: tip
		41: pos
}

子程序
{
	0: SetInvisible
	2: SetNum
	3: InitialHUDdescribe
	4: RefreshPlayerList
	5: GameStartTeleport
}

规则("编辑器代码：5DVHH，原编辑器由机智的阁下#5771 原创，我在此基础上进行修改添加")
{
	事件
	{
		持续 - 全局;
	}
}

规则("关于彩蛋-----------------请联系二创作者 衾岚喵#5486 具体询问，由于初衷是每个地图都不一样所以没有详细代码")
{
	事件
	{
		持续 - 全局;
	}
}

规则("------点位粘贴在这里！导出并复制后，点开规则在右边动作里全选清空后按亮黄色按钮粘贴------")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.AllowInvisible = 假;
		全局.Checkpoints = 数组(矢量(-116.753, 0.304, 23.601), 矢量(-92.494, -2.664, 69.487), 矢量(-48.934, -1.629, 68.810), 矢量(17.194, -0.412,
			61.864), 矢量(-37.017, 2.538, 27.109), 矢量(-45.081, -4.712, 6.376), 矢量(12.332, -3.683, 4.041), 矢量(-30.745, 2.905, 88.105), 矢量(
			-74.437, -1.200, 32.044), 矢量(-10.887, 5.040, 53.139), 矢量(-89.655, -3.581, 82.519), 矢量(-81.518, 3.341, 39.118), 矢量(35.598,
			2.280, 68.632), 矢量(13.432, -3.683, 25.240), 矢量(-137.476, -0.921, 45.712), 矢量(17.174, -3.647, 90.198), 矢量(-35.856, 3.292,
			26.767), 矢量(-3.108, -1.358, 90.310), 矢量(-124.120, 8.940, 32.988), 矢量(17.867, -2.640, -1.773), 矢量(-13.217, -3.343, 74.705), 矢量(
			-64.589, 3.315, 103.811), 矢量(-88.762, 3.047, 64.908), 矢量(-109.058, 2.224, 53.681), 矢量(-10.329, -2.417, 46.702), 矢量(-80.023,
			5.017, 79.924), 矢量(-62.879, 0.441, 45.110), 矢量(-13.838, -3.499, 101.011), 矢量(-38.157, -4.527, 9.992), 矢量(-94.186, -1.467,
			49.199), 矢量(-72.992, 17.022, 62.107), 矢量(12.999, 3.853, 67.600), 矢量(29.116, 6.818, 6.283), 矢量(-14.158, 20.238, 109.321), 矢量(
			26.992, 7.065, 12.633), 矢量(-39.816, 18.158, 53.171), 矢量(-83.239, -1.820, 19.637), 矢量(-26.792, 10.349, 65.914), 矢量(-38.586,
			-1.954, 37.450), 矢量(-25.333, -2.334, 51.531), 矢量(-35.464, -4.119, 90.252), 矢量(21.144, 12.336, 77.675), 矢量(-109.084, -0.265,
			16.678), 矢量(-120.728, -0.573, 48.535), 矢量(-59.144, 17.262, 8.791), 矢量(-113.830, 7.760, 43.279), 矢量(3.951, -5.809, -18.006), 矢量(
			-105.995, 3.198, 54.110), 矢量(-26.301, 17.062, 59.515), 矢量(-7.341, 2.242, 77.654));
		禁用 全局.DesignMode = 真;
		全局.RestartHourLeft = 2;
		全局.CheckCampoints = 数组(矢量(-116.322, -0.198, 22.851), 矢量(-93.050, -2.587, 70.315), 矢量(-48.689, -1.805, 69.764), 矢量(18.192, -0.466,
			61.895), 矢量(-36.409, 1.745, 27.135), 矢量(-46.058, -4.773, 6.174), 矢量(12.721, -4.602, 4.111), 矢量(-30.738, 2.177, 88.790), 矢量(
			-75.277, -1.245, 31.504), 矢量(-10.888, 5.070, 54.138), 矢量(-90.188, -3.733, 83.351), 矢量(-82.326, 3.464, 38.541), 矢量(35.616,
			1.280, 68.632), 矢量(12.875, -4.286, 24.669), 矢量(-138.237, -1.399, 46.151), 矢量(17.743, -3.574, 89.379), 矢量(-36.229, 2.373,
			26.898), 矢量(-2.114, -1.404, 90.408), 矢量(-124.848, 9.420, 32.500), 矢量(17.855, -3.640, -1.786), 矢量(-14.166, -3.584, 74.912), 矢量(
			-65.089, 2.813, 104.517), 矢量(-88.189, 2.584, 64.232), 矢量(-109.070, 1.243, 53.483), 矢量(-10.164, -2.244, 45.731), 矢量(-79.675,
			5.331, 79.041), 矢量(-63.387, 0.853, 45.866), 矢量(-13.932, -3.778, 100.055), 矢量(-38.140, -5.527, 9.992), 矢量(-94.208, -0.468,
			49.236), 矢量(-72.351, 17.639, 62.565), 矢量(12.854, 3.891, 66.611), 矢量(29.453, 7.683, 6.654), 矢量(-14.081, 20.076, 108.338), 矢量(
			27.990, 7.030, 12.585), 矢量(-40.175, 17.986, 52.254), 矢量(-83.225, -0.820, 19.647), 矢量(-26.785, 11.213, 65.412), 矢量(-38.672,
			-2.498, 38.285), 矢量(-25.372, -2.355, 52.530), 矢量(-35.600, -3.128, 90.234), 矢量(21.230, 12.616, 78.631), 矢量(-110.048, -0.084,
			16.875), 矢量(-120.218, 0.221, 48.864), 矢量(-58.156, 17.188, 8.931), 矢量(-114.672, 7.825, 42.744), 矢量(4.597, -5.752, -18.767), 矢量(
			-105.542, 3.695, 53.370), 矢量(-27.289, 16.919, 59.445), 矢量(-7.323, 1.242, 77.653));
		全局.DistanceToPoint = 4;
		全局.CamSpeed = 1;
		全局.FaultTimes = 4;
		全局.MapDesigner = 自定义字符串("衾岚喵#5486");
		全局.ShareCode = 自定义字符串("");
		全局.RankList = 数组();
		全局.PlayerList = 数组();
		全局.UnlockFlyNum = 30;
		全局.HelloTipTime = 60;
		全局.HelloTipRadius = 30;
	}
}

规则("---作--者--信--息---")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		"作者名只改这个"
		全局.MapDesigner = 自定义字符串("泠泠七弦上#51804");
		"分享码，如“A7306”"
		全局.ShareCode = 自定义字符串("ZNQ6V");
		禁用 全局.ThanksList = 自定义字符串("编辑器作者：机智的阁下#5771");
	}
}

规则("全局初始化")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		关闭游戏预设完成条件;
		关闭游戏预设计分模式;
		关闭游戏预设通告模式;
		关闭游戏预设音乐模式;
		设置比赛时间(2);
		全局.RestartHourLeft = 当前游戏模式 == 游戏模式(突击模式) ? 4 : 1.500;
		If(全局.Checkpoints == 0 && 全局.CheckCampoints == 0);
			全局.Checkpoints = 空数组;
			全局.CheckCampoints = 空数组;
		End;
		全局.RankList = 空数组;
		全局.PlayerList = 空数组;
	}
}

规则("玩家初始化")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
	}

	动作
	{
		禁用查看器录制;
		设置最大复生时间(事件玩家, 4);
		设置状态(事件玩家, 无, 无敌, 6 * 3600);
		事件玩家.CurrentCheckpoints = 全局.Checkpoints;
		事件玩家.CurrentCheckCampoints = 全局.CheckCampoints;
		禁用 事件玩家.CurrentPlayerpoint = 矢量(0, 0, 0);
		事件玩家.PlayerName = 自定义字符串("{0}", 事件玩家);
		事件玩家.ObserverMode = 0;
		事件玩家.CurrentCheckpointNum = 0;
		事件玩家.PicNum = 事件玩家.CurrentCheckpointNum;
		事件玩家.TempNum = 事件玩家.PicNum;
		事件玩家.TeleportENum = 0;
		事件玩家.FinishGame = 0;
		事件玩家.Invisible = 真;
		事件玩家.Getit = 假;
		事件玩家.GetitEffect = -1;
		事件玩家.FireEffect[0] = -1;
		事件玩家.PicView = 0;
		事件玩家.HelloTip = 0;
		事件玩家.TempHorizontalAngle = 水平朝向角度(事件玩家);
		根据条件跳过(全局.AllowInvisible, 1);
		事件玩家.Invisible = 假;
		调用子程序(SetInvisible);
		调用子程序(GameStartTeleport);
		禁用 传送(事件玩家, 全局.Checkpoints[0]);
		禁用 传送(事件玩家, 最近的可行走位置(矢量(0, 0, 0)));
		事件玩家.AlreadyFaultTimes = 0;
		调用子程序(InitialHUDdescribe);
		If(全局.DesignMode);
			创建HUD文本(事件玩家, 图标字符串(感叹号), 无, 自定义字符串("编辑规则已被打开，主机玩家可修改点位"), 左边, -1, 颜色(红色), 颜色(白色), 颜色(橙色), 可见和字符串, 默认可见度);
			禁用 Else;
		End;
		禁用 在索引处修改全局变量(RankList, 栏位(事件玩家), 添加至数组, 事件玩家.CurrentCheckpointNum);
		禁用 修改全局变量(PlayerList, 添加至数组, 矢量(事件玩家.CurrentCheckpointNum, 0, 栏位(事件玩家)));
		禁用 事件玩家.PlayerListpoint = 数组值的索引(全局.PlayerList * 前, 栏位(事件玩家));
		禁用 事件玩家.PlayerListpoint = 数组值的索引(Z方向分量(全局.PlayerList), 栏位(事件玩家));
		创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串("{0}  {1}/{2}", 事件玩家.PlayerName, 事件玩家.CurrentCheckpointNum, 数量(事件玩家.CurrentCheckpoints)), 右边, -1,
			颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		事件玩家.HUDdescribe5 = 上一个文本ID;
		小字体信息(事件玩家, 自定义字符串("欢迎进来玩看图找物"));
		等待(2, 无视条件);
		小字体信息(事件玩家, 自定义字符串("顶部有滚动操作提示"));
		对所有玩家启用死亡回放(事件玩家);
		启用死亡回放时目标的HUD(事件玩家);
		事件玩家.tip = 0;
	}
}

规则("[选项]--容错次数")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.FaultTimes = 4;
	}
}

规则("[选项]--飞行模式解锁关卡数")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.UnlockFlyNum = 30;
	}
}

规则("[黑名单]-------可自动踢出伞兵")
{
	事件
	{
		玩家加入比赛;
		双方;
		全部;
	}

	动作
	{
		"写上加入黑名单玩家的名字"
		If(自定义字符串("盖伊") == 自定义字符串("{0}", 事件玩家));
			移除玩家(事件玩家);
			大字体信息(所有玩家(所有队伍), 自定义字符串("伞兵{0}给爷爪巴！", 事件玩家));
		"添加人数请复制以下三条动作"
		Else If(自定义字符串("") == 自定义字符串("{0}", 事件玩家));
			移除玩家(事件玩家);
			大字体信息(所有玩家(所有队伍), 自定义字符串("伞兵{0}给爷爪巴！", 事件玩家));
	}
}

规则("[开关选项]--隐身开关")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		"真为隐身，假则不隐身"
		全局.AllowInvisible = 假;
	}
}

规则("[自定义选项]点位的距离")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.DistanceToPoint = 4;
	}
}

规则("[自定义选项]遇到bug或者被地形卡住时强制传送的位置")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		(事件玩家.AlreadyFaultTimes == 全局.FaultTimes + 1) == 假;
		事件玩家.EditCamMode == 假;
		按钮被按下(事件玩家, 按钮(装填)) == 真;
		按钮被按下(事件玩家, 按钮(近身攻击)) == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 假;
		按钮被按下(事件玩家, 按钮(互动)) == 假;
	}

	动作
	{
		传送(事件玩家, 矢量(-16.159, 3.764, 78.743));
	}
}

规则("[自定义选项]你好提示范围指示【两种模式：1.玩家不动，自身为中心扩展；2.玩家可动，发你好时的位置为中心扩展】 默认模式一，更改时请关闭另一个模式")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		正在交流(事件玩家, 问候) == 真;
		已重生(事件玩家) == 真;
		事件玩家.FinishGame == 假;
	}

	动作
	{
		事件玩家.pos = 所选位置(事件玩家);
		"模式一（IF-END）"
		If(事件玩家.HelloTip == 0);
			设置移动速度(事件玩家, 0);
			追踪玩家变量频率(事件玩家, range, 全局.HelloTipRadius, 全局.HelloTipRadius / 1.500, 速率及最终值);
			创建效果(事件玩家, 球体, 颜色(红色), 事件玩家.pos, 事件玩家.range, 可见，位置和半径);
			事件玩家.tip = 最后创建的实体;
			等待(2.500, 无视条件);
			消除效果(事件玩家.tip);
			事件玩家.tip = 0;
			停止追踪玩家变量(事件玩家, range);
			事件玩家.range = 0;
			设置移动速度(事件玩家, 150);
		End;
		"模式二（IF-END）"
		禁用 If(事件玩家.HelloTip == 0);
		禁用 追踪玩家变量频率(事件玩家, range, 全局.HelloTipRadius, 全局.HelloTipRadius / 1.500, 速率及最终值);
		禁用 创建效果(事件玩家, 球体, 颜色(红色), 事件玩家.pos, 事件玩家.range, 可见，位置和半径);
		禁用 事件玩家.tip = 最后创建的实体;
		禁用 等待(2.500, 无视条件);
		禁用 消除效果(事件玩家.tip);
		禁用 事件玩家.tip = 0;
		禁用 停止追踪玩家变量(事件玩家, range);
		禁用 事件玩家.range = 0;
		禁用 End;
		If(相距距离(事件玩家.pos, 事件玩家.CurrentCheckpoints[事件玩家.CurrentCheckpointNum]) <= 全局.HelloTipRadius && 事件玩家.HelloTip == 0);
			小字体信息(事件玩家, 自定义字符串("在附近"));
			事件玩家.HelloTip = 全局.HelloTipTime;
			持续追踪玩家变量(事件玩家, HelloTip, 0, 全局.HelloTipTime, 终点及持续时间);
		Else If(相距距离(事件玩家.pos, 事件玩家.CurrentCheckpoints[事件玩家.CurrentCheckpointNum]) > 全局.HelloTipRadius && 事件玩家.HelloTip == 0);
			小字体信息(事件玩家, 自定义字符串("不在附近"));
			事件玩家.HelloTip = 全局.HelloTipTime;
			持续追踪玩家变量(事件玩家, HelloTip, 0, 全局.HelloTipTime, 终点及持续时间);
		Else;
			小字体信息(事件玩家, 自定义字符串("距离下次提示可用还有{0}分钟{1}秒", 取整(事件玩家.HelloTip / 60, 下), 取整(事件玩家.HelloTip % 60, 下)));
		End;
	}
}

规则("[自定义选项]--每次提示是否附近的间隔时间/秒-以及提示附近的范围")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		"这是间隔时间/秒"
		全局.HelloTipTime = 60;
		"这是提示附近的范围"
		全局.HelloTipRadius = 30;
	}
}

规则("[自定义选项]计时器--------------------------------------------（请按需求打开或关闭，默认关闭）")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.Getit == 真;
	}

	动作
	{
		事件玩家.timer = 1;
		创建HUD文本(事件玩家, 无, 无, 自定义字符串("已用时间：{0} 秒", 事件玩家.TIME), 左边, 6662, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		If(事件玩家.CurrentCheckpointNum == 0);
			追踪玩家变量频率(事件玩家, TIME, 999999, 1, 速率及最终值);
		End;
		等待直到 (事件玩家.CurrentCheckpointNum == 数量(事件玩家.CurrentCheckpoints), 999999);
		停止追踪玩家变量(事件玩家, TIME);
	}
}

禁用 规则("启用编辑规则！---如发图请关闭此规则--或把真改为假")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.DesignMode = 真;
	}
}

规则("子程序SetInvisible")
{
	事件
	{
		子程序;
		SetInvisible;
	}

	动作
	{
		If(事件玩家.Invisible);
			设置不可见(事件玩家, 全部);
		Else;
			设置不可见(事件玩家, 无);
		End;
	}
}

规则("禁用技能")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
	}

	动作
	{
		设置启用技能 1(事件玩家, 假);
		设置启用技能 2(事件玩家, 假);
		设置启用终极技能(事件玩家, 假);
		设置辅助攻击模式启用(事件玩家, 假);
		设置主要攻击模式启用(事件玩家, 假);
		设置启用近战攻击(事件玩家, 假);
	}
}

规则("开关编辑模式")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		全局.DesignMode == 真;
		事件玩家 == 主机玩家;
		按钮被按下(事件玩家, 按钮(装填)) == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 假;
		按钮被按下(事件玩家, 按钮(跳跃)) == 假;
	}

	动作
	{
		根据条件跳过(事件玩家.EditCamMode, 1);
		事件玩家.EditCampoint = 眼睛位置(事件玩家);
		If(事件玩家.EditCamMode);
			传送(事件玩家, 事件玩家.EditCampoint);
			设置移动速度(事件玩家, 100);
			禁用 传送(事件玩家, 最近的可行走位置(事件玩家.EditCampoint));
			停止镜头(事件玩家);
			事件玩家.EditCampoint = 眼睛位置(事件玩家);
			事件玩家.TempCampoint = 事件玩家.EditCampoint;
			事件玩家.EditCamMode = 0;
			根据条件跳过(事件玩家.CurrentCheckpointNum == 数量(事件玩家.CurrentCheckpoints), 1);
			消除效果(最后创建的实体);
			禁用 启用查看器录制;
		Else;
			开始镜头(事件玩家, 事件玩家.EditCampoint, 事件玩家.EditCampoint + 面朝方向(事件玩家), 400);
			设置移动速度(事件玩家, 0);
			事件玩家.EditCamMode = 1;
			根据条件跳过(事件玩家.CurrentCheckpointNum == 数量(事件玩家.CurrentCheckpoints), 1);
			创建效果(事件玩家, 球体, 颜色(亮紫色), 事件玩家.CurrentCheckpoints[事件玩家.CurrentCheckpointNum], 1, 可见，位置和半径);
			禁用 禁用查看器录制;
		End;
		事件玩家.TempCamSpeed = 全局.CamSpeed;
		事件玩家.CamSpeedLevel = 2;
	}
}

规则("观战")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(互动)) == 真;
		按钮被按下(事件玩家, 按钮(技能2)) == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 假;
		按钮被按下(事件玩家, 按钮(跳跃)) == 假;
	}

	动作
	{
		If(事件玩家.ObserverMode);
			开启游戏预设复生模式(事件玩家);
			设置主要攻击模式启用(事件玩家, 假);
			复活(事件玩家);
			等待(0.100, 无视条件);
			小字体信息(所有玩家(所有队伍), 自定义字符串("已关闭观战模式"));
			事件玩家.ObserverMode = 0;
		Else;
			事件玩家.ObserverMode = 1;
			关闭游戏预设复生模式(事件玩家);
			击杀(事件玩家, 无);
			设置主要攻击模式启用(事件玩家, 真);
			小字体信息(事件玩家, 自定义字符串("已开启观战模式，按左右键切换观战对象"));
		End;
		等待(1, 无视条件);
	}
}

规则("游戏时间")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		当前游戏模式 == 游戏模式(突击模式);
		比赛时间 == 0;
	}

	动作
	{
		If(全局.RestartHourLeft == 0);
			比赛时间暂停;
		Else;
			设置比赛时间(60 * 3600);
		End;
		全局.RestartHourLeft = 全局.RestartHourLeft - 1;
	}
}

规则("重生")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		死亡(事件玩家) == 真;
		事件玩家.ObserverMode == 假;
	}

	动作
	{
		传送(事件玩家, 最近的可行走位置(所选位置(事件玩家)));
		等待(3, 无视条件);
		复活(事件玩家);
		设置启用技能 1(事件玩家, 假);
		设置启用技能 2(事件玩家, 假);
		设置启用终极技能(事件玩家, 假);
		设置辅助攻击模式启用(事件玩家, 假);
		设置主要攻击模式启用(事件玩家, 假);
		设置启用近战攻击(事件玩家, 假);
	}
}

禁用 规则("调试规则")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
		事件玩家 == 主机玩家;
	}

	动作
	{
		创建HUD文本(主机玩家, 自定义字符串("当前位置：{0}     眼睛位置{1}      面朝方向{2}", 所选位置(事件玩家), 眼睛位置(事件玩家), 面朝方向(事件玩家)), 无, 无, 左边, 0, 颜色(橙色), 颜色(白色), 颜色(白色),
			可见和字符串, 默认可见度);
		创建HUD文本(主机玩家, 自定义字符串("当前Num：{0}   Pic：{1}   Currentpoints数{2}", 事件玩家.CurrentCheckpointNum, 事件玩家.PicNum, 数量(
			事件玩家.CurrentCheckpoints)), 无, 无, 左边, 0, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		创建HUD文本(主机玩家, 自定义字符串("X{0}  Y{1}  Z{2}", X方向分量(阈值(事件玩家)), Y方向分量(阈值(事件玩家)), Z方向分量(阈值(事件玩家))), 无, 无, 左边, 0, 颜色(白色), 颜色(白色), 颜色(白色),
			可见和字符串, 默认可见度);
		创建HUD文本(主机玩家, 自定义字符串("EdCamp{0}   EdCamMo{1}   CamSpLe{2}", 事件玩家.EditCampoint, 事件玩家.EditCamMode, 事件玩家.CamSpeedLevel), 无, 无, 左边, 0,
			颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		创建HUD文本(所有玩家(所有队伍), 自定义字符串("当前地图{0}", 当前地图), 无, 无, 左边, 0, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		创建效果(事件玩家, 环, 颜色(绿色), 所选位置(事件玩家), 2, 可见，位置和半径);
		创建HUD文本(事件玩家, 自定义字符串("所在队伍{0}  快速跳跃图片{1}  水平朝向角度{2}", 所在队伍(事件玩家), 取整(绝对值(与此方向的水平角度(面朝方向(事件玩家))) * (数量(事件玩家.CurrentCheckpointNum)
			/ 180), 上), 水平朝向角度(事件玩家)), 无, 无, 左边, 0, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		创建HUD文本(事件玩家, 自定义字符串("Effect0：{0}   Effect1：{1}", 事件玩家.FireEffect[0], 事件玩家.FireEffect[1]), 无, 无, 左边, 0, 颜色(白色), 颜色(白色), 颜色(白色),
			可见和字符串, 默认可见度);
	}
}

规则("索取关卡位置")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.Getit == 真;
	}

	动作
	{
		根据条件跳过(事件玩家.CurrentCheckpointNum == 数量(事件玩家.CurrentCheckpoints), 1);
		事件玩家.CurrentCheckpointNum += 1;
		事件玩家.Getit = 假;
		根据条件跳过(事件玩家.CurrentCheckpointNum == 数量(事件玩家.CurrentCheckpoints), 1);
		事件玩家.PicNum = 事件玩家.CurrentCheckpointNum;
		事件玩家.TempNum = 事件玩家.PicNum;
		根据条件跳过(事件玩家.CurrentCheckpointNum != 全局.UnlockFlyNum, 1);
		小字体信息(事件玩家, 自定义字符串("已解锁飞行模式，按住跳跃可进行飞行"));
		停止追踪玩家变量(事件玩家, HelloTip);
		事件玩家.HelloTip = 0;
	}
}

规则("找到点位")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(互动)) == 真;
		(事件玩家.CurrentCheckpointNum < 数量(事件玩家.CurrentCheckpoints)) == 真;
		按钮被按下(事件玩家, 按钮(辅助攻击模式)) == 假;
		事件玩家.EditCamMode == 假;
		存活(事件玩家) == 真;
	}

	动作
	{
		If(相距距离(眼睛位置(事件玩家), 事件玩家.CurrentCheckpoints[事件玩家.CurrentCheckpointNum]) <= 全局.DistanceToPoint);
			小字体信息(事件玩家, 自定义字符串("选对了哟，继续努力"));
			播放效果(事件玩家, 有益爆炸, 颜色(橙色), 事件玩家.CurrentCheckpoints[事件玩家.CurrentCheckpointNum], 1);
			根据条件跳过(!实体存在(事件玩家.GetitEffect), 1);
			消除效果(事件玩家.GetitEffect);
			创建效果(事件玩家, 有益光环, 颜色(橙色), 事件玩家.CurrentCheckpoints[事件玩家.CurrentCheckpointNum - 1], 1, 可见，位置和半径);
			事件玩家.GetitEffect = 最后创建的实体;
			播放效果(事件玩家, 正面状态施加声音, 颜色(白色), 事件玩家.CurrentCheckpoints[事件玩家.CurrentCheckpointNum], 200);
			播放效果(事件玩家, 有益选择效果 , 颜色(白色), 事件玩家, 100);
			事件玩家.AlreadyFaultTimes = 0;
			事件玩家.Getit = 真;
		Else;
			设置状态(事件玩家, 无, 冰冻, 1);
			小字体信息(事件玩家, 自定义字符串("选错啦！再仔细找找"));
			事件玩家.AlreadyFaultTimes += 1;
		End;
	}
}

规则("右键查看图片")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(辅助攻击模式)) == 真;
		按钮被按下(事件玩家, 按钮(主要攻击模式)) == 假;
		事件玩家.PicView == 0;
		死亡(事件玩家) == 假;
	}

	动作
	{
		禁用查看器录制;
		事件玩家.TempNum = 事件玩家.PicNum;
		事件玩家.TempNum2 = 水平朝向角度(事件玩家);
		开始镜头(事件玩家, 事件玩家.CurrentCheckpoints[事件玩家.PicNum], 事件玩家.CurrentCheckCampoints[事件玩家.PicNum], 0);
		根据条件跳过(事件玩家.HUDdescribe4 == 0, 1);
		消除HUD文本(事件玩家.HUDdescribe4);
		创建HUD文本(事件玩家, 自定义字符串("正在查看第{0}张图片", 1 + 事件玩家.PicNum), 无, 无, 左边, 0, 颜色(黄色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		事件玩家.HUDdescribe4 = 上一个文本ID;
		事件玩家.PicView = 1;
	}
}

规则("左键回退图片")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(主要攻击模式)) == 真;
		按钮被按下(事件玩家, 按钮(辅助攻击模式)) == 真;
		按钮被按下(事件玩家, 按钮(互动)) == 假;
		事件玩家.PicNum > 0;
		死亡(事件玩家) == 假;
		事件玩家.PicView == 1;
	}

	动作
	{
		事件玩家.PicNum -= 1;
		禁用 开始镜头(事件玩家, 事件玩家.CurrentCheckpoints[事件玩家.PicNum], 事件玩家.CurrentCheckCampoints[事件玩家.PicNum], 0);
	}
}

规则("停止查看图片")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(辅助攻击模式)) == 假;
		死亡(事件玩家) == 假;
	}

	动作
	{
		停止镜头(事件玩家);
		事件玩家.PicNum = 事件玩家.TempNum;
		根据条件跳过(事件玩家.HUDdescribe4 == 0, 1);
		消除HUD文本(事件玩家.HUDdescribe4);
		事件玩家.PicView = 0;
		根据条件跳过(全局.DesignMode == 假, 1);
		禁用 启用查看器录制;
		根据条件跳过(事件玩家.EditCamMode == 假, 2);
		开始镜头(事件玩家, 事件玩家.EditCampoint, 事件玩家.EditCampoint + 面朝方向(事件玩家), 400);
		禁用查看器录制;
	}
}

规则("移动镜头")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.EditCamMode == 真;
		全局.DesignMode == 真;
		(绝对值(X方向分量(阈值(事件玩家))) || 绝对值(Z方向分量(阈值(事件玩家)))) == 真;
	}

	动作
	{
		禁用查看器录制;
		If(Z方向分量(阈值(事件玩家)) != 0);
			事件玩家.TempCampoint = 事件玩家.EditCampoint;
			追踪玩家变量频率(事件玩家, EditCampoint, 事件玩家.TempCampoint + 面朝方向(事件玩家) * 事件玩家.TempCamSpeed * Z方向分量(归一化(阈值(事件玩家))), 事件玩家.TempCamSpeed * 10,
				速率及最终值);
			禁用 事件玩家.EditCampoint += 面朝方向(事件玩家) * 0.500;
			禁用 Else If(Z方向分量(阈值(事件玩家)) < 0);
			禁用 事件玩家.TempCampoint = 事件玩家.EditCampoint;
			禁用 追踪玩家变量频率(事件玩家, EditCampoint, 事件玩家.TempCampoint + 面朝方向(事件玩家) * 事件玩家.TempCamSpeed * -1, 事件玩家.TempCamSpeed * 10, 速率及最终值);
		Else If(X方向分量(阈值(事件玩家)) != 0);
			事件玩家.TempCampoint = 事件玩家.EditCampoint;
			禁用 追踪玩家变量频率(事件玩家, EditCampoint, 事件玩家.TempCampoint + 地图矢量(矢量(X方向分量(归一化(阈值(事件玩家))), 0, 0), 事件玩家, 旋转) * 事件玩家.TempCamSpeed,
				事件玩家.TempCamSpeed * 10, 速率及最终值);
			追踪玩家变量频率(事件玩家, EditCampoint, 事件玩家.TempCampoint + 地图矢量(矢量(1, 0, 0) * X方向分量(归一化(阈值(事件玩家))), 事件玩家, 旋转) * 事件玩家.TempCamSpeed,
				事件玩家.TempCamSpeed * 10, 速率及最终值);
		End;
		等待(0.020, 无视条件);
		如条件为“假”则中止;
		循环;
	}
}

规则("新建关卡")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		全局.DesignMode == 真;
		事件玩家.EditCamMode == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 真;
		按钮被按下(事件玩家, 按钮(装填)) == 真;
		事件玩家 == 主机玩家;
	}

	动作
	{
		消除效果(最后创建的实体);
		修改全局变量(CheckCampoints, 添加至数组, 事件玩家.EditCampoint + 面朝方向(事件玩家));
		修改全局变量(Checkpoints, 添加至数组, 事件玩家.EditCampoint);
		启用查看器录制;
		禁用查看器录制;
		调用子程序(SetNum);
		小字体信息(事件玩家, 自定义字符串("新建最后一关成功"));
	}
}

规则("替换关卡")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		全局.DesignMode == 真;
		事件玩家.EditCamMode == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 真;
		按钮被按下(事件玩家, 按钮(技能2)) == 真;
		事件玩家 == 主机玩家;
	}

	动作
	{
		小字体信息(事件玩家, 自定义字符串("长按1s替换关卡"));
		等待(1, 无视条件);
		如条件为“假”则中止;
		全局.Checkpoints[事件玩家.PicNum] = 事件玩家.EditCampoint;
		全局.CheckCampoints[事件玩家.PicNum] = 事件玩家.EditCampoint + 面朝方向(事件玩家);
		启用查看器录制;
		禁用查看器录制;
		事件玩家.CurrentCheckpoints = 全局.Checkpoints;
		事件玩家.CurrentCheckCampoints = 全局.CheckCampoints;
		小字体信息(事件玩家, 自定义字符串("替换成功"));
	}
}

规则("删除关卡")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		全局.DesignMode == 真;
		事件玩家.EditCamMode == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 真;
		按钮被按下(事件玩家, 按钮(终极技能)) == 真;
		事件玩家 == 主机玩家;
	}

	动作
	{
		禁用 根据条件跳过(全局.Checkpoints == 1, 1);
		小字体信息(事件玩家, 自定义字符串("长按1s删除关卡"));
		等待(1, 无视条件);
		如条件为“假”则中止;
		禁用 修改全局变量(Checkpoints, 根据索引从数组中移除, 数量(全局.Checkpoints) - 1);
		禁用 修改全局变量(CheckCampoints, 根据索引从数组中移除, 全局.CheckCampoints - 1);
		修改全局变量(Checkpoints, 根据索引从数组中移除, 事件玩家.PicNum);
		修改全局变量(CheckCampoints, 根据索引从数组中移除, 事件玩家.PicNum);
		启用查看器录制;
		禁用查看器录制;
		消除效果(最后创建的实体);
		调用子程序(SetNum);
	}
}

规则("子程序SetNum")
{
	事件
	{
		子程序;
		SetNum;
	}

	动作
	{
		事件玩家.CurrentCheckpoints = 全局.Checkpoints;
		事件玩家.CurrentCheckCampoints = 全局.CheckCampoints;
		事件玩家.CurrentCheckpointNum = 数量(事件玩家.CurrentCheckpoints) + 0;
		事件玩家.PicNum = 事件玩家.CurrentCheckpointNum - 1;
		事件玩家.TempNum = 事件玩家.PicNum;
	}
}

规则("镜头默认速度")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.CamSpeed = 1;
	}
}

规则("降镜头速度")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.EditCamMode == 真;
		全局.DesignMode == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 假;
		按钮被按下(事件玩家, 按钮(互动)) == 假;
		事件玩家 == 主机玩家;
	}

	动作
	{
		等待(1, 无视条件);
		如条件为“假”则中止;
		根据条件跳过(事件玩家.CamSpeedLevel == 0, 3);
		事件玩家.TempCamSpeed *= 0.100;
		事件玩家.CamSpeedLevel -= 1;
		小字体信息(事件玩家, 自定义字符串("速度已减一档"));
		根据条件跳过(事件玩家.CamSpeedLevel > 0, 1);
		小字体信息(事件玩家, 自定义字符串("不能再减了"));
	}
}

规则("升镜头速度")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.EditCamMode == 真;
		全局.DesignMode == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 假;
		按钮被按下(事件玩家, 按钮(跳跃)) == 真;
		按钮被按下(事件玩家, 按钮(互动)) == 假;
		事件玩家 == 主机玩家;
	}

	动作
	{
		等待(1, 无视条件);
		如条件为“假”则中止;
		根据条件跳过(事件玩家.CamSpeedLevel == 3, 3);
		事件玩家.TempCamSpeed *= 10;
		事件玩家.CamSpeedLevel += 1;
		小字体信息(事件玩家, 自定义字符串("速度已升一档"));
		根据条件跳过(事件玩家.CamSpeedLevel < 3, 1);
		小字体信息(事件玩家, 自定义字符串("不能再升了"));
	}
}

规则("移动加速")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(技能1)) == 真;
		事件玩家.EditCamMode == 假;
		事件玩家.tip == 0;
	}

	动作
	{
		设置移动速度(事件玩家, 300);
	}
}

规则("取消移动加速")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(技能1)) == 假;
	}

	动作
	{
		If(事件玩家.tip == 0);
			设置移动速度(事件玩家, 150);
		Else;
			设置移动速度(事件玩家, 0);
	}
}

规则("编辑模式下跳关")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		全局.DesignMode == 真;
		禁用 事件玩家.EditCamMode == 真;
		按钮被按下(事件玩家, 按钮(互动)) == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 真;
		按钮被按下(事件玩家, 按钮(辅助攻击模式)) == 真;
		事件玩家 == 主机玩家;
	}

	动作
	{
		If(事件玩家.CurrentCheckpointNum < 数量(事件玩家.CurrentCheckpoints));
			事件玩家.CurrentCheckpointNum += 1;
			根据条件跳过(事件玩家.CurrentCheckpointNum == 数量(事件玩家.CurrentCheckpoints), 1);
			事件玩家.PicNum = 事件玩家.CurrentCheckpointNum;
		Else;
			事件玩家.CurrentCheckpointNum = 0;
			事件玩家.PicNum = 事件玩家.CurrentCheckpointNum;
		End;
		事件玩家.TempNum = 事件玩家.PicNum;
		小字体信息(事件玩家, 自定义字符串("已跳至{0}关", 事件玩家.CurrentCheckpointNum));
		传送(事件玩家, 最近的可行走位置(事件玩家.CurrentCheckpoints[事件玩家.CurrentCheckpointNum]));
		根据条件跳过(事件玩家.CurrentCheckpointNum < 数量(事件玩家.CurrentCheckpoints), 1);
		传送(事件玩家, 最近的可行走位置(事件玩家.CurrentCheckpoints[事件玩家.CurrentCheckpointNum - 1]));
		根据条件跳过(事件玩家.CurrentCheckpointNum != 全局.UnlockFlyNum, 1);
		小字体信息(事件玩家, 自定义字符串("已解锁飞行模式，按住跳跃可进行飞行"));
	}
}

规则("编辑模式下退关")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		全局.DesignMode == 真;
		禁用 事件玩家.EditCamMode == 真;
		按钮被按下(事件玩家, 按钮(互动)) == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		按钮被按下(事件玩家, 按钮(辅助攻击模式)) == 真;
		事件玩家 == 主机玩家;
	}

	动作
	{
		If(事件玩家.CurrentCheckpointNum > 0);
			禁用 根据条件跳过(事件玩家.CurrentCheckpointNum == 数量(事件玩家.CurrentCheckpoints), 1);
			事件玩家.CurrentCheckpointNum -= 1;
			根据条件跳过(事件玩家.CurrentCheckpointNum == 数量(事件玩家.CurrentCheckpoints), 1);
			事件玩家.PicNum = 事件玩家.CurrentCheckpointNum;
		Else;
			禁用 根据条件跳过(事件玩家.CurrentCheckpointNum < 数量(事件玩家.CurrentCheckpoints), 1);
			事件玩家.CurrentCheckpointNum = 数量(事件玩家.CurrentCheckpoints);
			事件玩家.PicNum = 事件玩家.CurrentCheckpointNum - 1;
		End;
		事件玩家.TempNum = 事件玩家.PicNum;
		小字体信息(事件玩家, 自定义字符串("已跳至{0}关", 事件玩家.CurrentCheckpointNum));
		传送(事件玩家, 最近的可行走位置(事件玩家.CurrentCheckpoints[事件玩家.CurrentCheckpointNum]));
		根据条件跳过(事件玩家.CurrentCheckpointNum < 数量(事件玩家.CurrentCheckpoints), 1);
		传送(事件玩家, 最近的可行走位置(事件玩家.CurrentCheckpoints[事件玩家.CurrentCheckpointNum - 1]));
		根据条件跳过(事件玩家.CurrentCheckpointNum != 全局.UnlockFlyNum, 1);
		小字体信息(事件玩家, 自定义字符串("已解锁飞行模式，按住跳跃可进行飞行"));
	}
}

规则("左边进度文字")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
	}

	动作
	{
		禁用 创建HUD文本(事件玩家, 自定义字符串("「关卡进度」{0} / {1}", 事件玩家.CurrentCheckpointNum, 数量(事件玩家.CurrentCheckpoints)), 无, 无, 顶部, 100, 颜色(白色), 颜色(白色), 颜色(
			白色), 可见和字符串, 默认可见度);
		创建HUD文本(事件玩家, 自定义字符串("「你已找到」{0} / {1}", 事件玩家.CurrentCheckpointNum, 数量(事件玩家.CurrentCheckpoints)), 无, 无, 左边, 300, 颜色(玫红), 颜色(绿色), 颜色(
			玫红), 可见和字符串, 默认可见度);
	}
}

禁用 规则("默认右边描述")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
	}

	动作
	{
		禁用 创建HUD文本(事件玩家, 无, 无, 自定义字符串("\r\n编辑器1.0.2  编辑器作者：机智的阁下#5771"), 右边, -1 * 993, 颜色(白色), 颜色(白色), 颜色(绿色), 可见, 默认可见度);
		禁用 创建HUD文本(事件玩家, 无, 无, 自定义字符串(
			"按住右键看图，再按左键回看\r\n  长按 SHIFT       加速移动\r\n  发送“你好”    关卡提示\r\n     CTRL 键       进出传送门\r\n30关之后，长按空格键可飞行进行传送"), 右边, -1 * 994,
			颜色(白色), 颜色(白色), 颜色(绿色), 可见, 默认可见度);
		禁用 创建HUD文本(事件玩家, 无, 无, 自定义字符串(
			"按住右键看图，再按左键回看\r\n  长按 SHIFT       加速移动\r\n  发送“你好”      关卡提示\n    CTRL 键        进出传送门\r\n30关之后，长按空格键可飞行"), 右边, -1 * 995, 颜色(
			白色), 颜色(白色), 颜色(绿色), 可见, 默认可见度);
		禁用 创建HUD文本(事件玩家, 自定义字符串("作者：{0}\r\n代码：{1}\r\n{2}", 全局.MapDesigner, 全局.ShareCode, 全局.ThanksList), 无, 无, 左边, -1 * 996, 颜色(橙色), 颜色(白色),
			颜色(天蓝色), 可见, 默认可见度);
	}
}

规则("关卡效果显示")
{
	事件
	{
		持续 - 全局;
	}
}

规则("右边编辑模式描述")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.EditCamMode == 真;
		全局.DesignMode == 真;
		事件玩家 == 主机玩家;
		已重生(事件玩家) == 真;
	}

	动作
	{
		禁用 根据条件跳过(!事件玩家.HUDdescribe3, 1);
		消除HUD文本(事件玩家.HUDdescribe3);
		创建HUD文本(事件玩家, 无, 无, 自定义字符串(
			"         长按CTRL       镜头减速一档\r\n         长按空格         镜头加速一档\r\n          按WSAD移动镜头，按R退出\r\n          使用（语音：感谢）导出点位"), 右边,
			-1 * 997, 颜色(白色), 颜色(白色), 颜色(橙色), 可见, 默认可见度);
		事件玩家.HUDdescribe1 = 上一个文本ID;
		创建HUD文本(事件玩家, 无, 无, 自定义字符串(
			"已进入编辑模式\r\n       CTRL+空格+R         新建最后一关\r\n长按CTRL+空格+E         替换当前关卡\r\n长按CTRL+空格+Q         删除当前关卡"), 右边, -1 * 997, 颜色(
			白色), 颜色(白色), 颜色(橙色), 可见, 默认可见度);
		事件玩家.HUDdescribe2 = 上一个文本ID;
	}
}

规则("右边编辑模式描述关闭")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.EditCamMode == 假;
		全局.DesignMode == 真;
		已重生(事件玩家) == 真;
		事件玩家 == 主机玩家;
	}

	动作
	{
		根据条件跳过(!事件玩家.HUDdescribe1, 1);
		消除HUD文本(事件玩家.HUDdescribe1);
		根据条件跳过(!事件玩家.HUDdescribe2, 1);
		消除HUD文本(事件玩家.HUDdescribe2);
		创建HUD文本(事件玩家, 无, 无, 自定义字符串("已开启编辑规则，玩家可修改关卡\r\n按R可进入编辑模式\r\n右键+F+空格              跳至下一关\r\n右键+F+CTRL            跳至上一关"), 右边,
			-1 * 997, 颜色(白色), 颜色(白色), 颜色(橙色), 可见, 默认可见度);
		事件玩家.HUDdescribe3 = 上一个文本ID;
	}
}

规则("子程序InitialHUDdescribe")
{
	事件
	{
		子程序;
		InitialHUDdescribe;
	}

	动作
	{
		事件玩家.HUDdescribe1 = 0;
		事件玩家.HUDdescribe2 = 0;
		事件玩家.HUDdescribe3 = 0;
		事件玩家.HUDdescribe4 = 0;
		事件玩家.HUDdescribe6 = 0;
	}
}

规则("查看器全局点位导出")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家 == 主机玩家;
		全局.DesignMode == 真;
		禁用 按钮被按下(事件玩家, 按钮(互动)) == 真;
		正在交流(事件玩家, 感谢) == 真;
	}

	动作
	{
		启用查看器录制;
		全局.DesignMode = 假;
		禁用查看器录制;
		全局.DesignMode = 真;
		小字体信息(事件玩家, 自定义字符串("已导出，请到20s内到查看器复制全局变量"));
		等待(2, 无视条件);
		小字体信息(事件玩家, 自定义字符串("20s内请不要进行修改，否则无法保证准确导出"));
		等待(2, 无视条件);
		小字体信息(事件玩家, 自定义字符串("如有后续更改，请更新导出"));
		等待(20, 无视条件);
		禁用 启用查看器录制;
	}
}

规则("通关效果")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.CurrentCheckpointNum == 数量(事件玩家.CurrentCheckpoints);
		已重生(事件玩家) == 真;
		事件玩家.CurrentCheckpointNum != 0;
		事件玩家.FinishGame == 假;
	}

	动作
	{
		事件玩家.FinishGame = 1;
		事件玩家.Invisible = 假;
		调用子程序(SetInvisible);
		大字体信息(所有玩家(所有队伍), 自定义字符串("恭喜小可爱{0}已通关！！", 事件玩家));
		根据条件跳过(实体存在(事件玩家.FireEffect[0]), 8);
		创建效果(所有玩家(所有队伍), 火花, 颜色(绿色), 事件玩家, 0.350, 可见，位置和半径);
		事件玩家.FireEffect[0] = 最后创建的实体;
		创建效果(所有玩家(所有队伍), 火花, 颜色(蓝色), 事件玩家, 0.350, 可见，位置和半径);
		事件玩家.FireEffect[1] = 最后创建的实体;
		创建效果(所有玩家(所有队伍), 火花, 颜色(亮紫色), 事件玩家, 0.350, 可见，位置和半径);
		事件玩家.FireEffect[2] = 最后创建的实体;
		创建效果(所有玩家(所有队伍), 火花, 颜色(橙色), 事件玩家, 0.350, 可见，位置和半径);
		事件玩家.FireEffect[3] = 最后创建的实体;
		消除HUD文本(事件玩家.HUDdescribe5);
		If(事件玩家.timer == 真);
			创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串("{0}  {1}   已完成 ，用时 {2} 秒", 事件玩家.PlayerName, 自定义字符串("{0}/{1}", 事件玩家.CurrentCheckpointNum, 数量(
				事件玩家.CurrentCheckpoints)), 事件玩家.TIME), 右边, -2, 颜色(白色), 颜色(白色), 颜色(绿色), 可见和字符串, 默认可见度);
		Else;
			创建HUD文本(所有玩家(所有队伍), 无, 无, 自定义字符串("{0}  {1}/{2}   已完成 ", 事件玩家.PlayerName, 事件玩家.CurrentCheckpointNum, 数量(事件玩家.CurrentCheckpoints)),
				右边, -2, 颜色(白色), 颜色(白色), 颜色(绿色), 可见和字符串, 默认可见度);
		End;
		根据条件跳过(事件玩家.HUDdescribe6 != 0, 2);
		禁用 创建HUD文本(所有玩家(所有队伍), 自定义字符串("{0}{1}{2}", 英雄图标字符串(所用英雄(事件玩家)), 事件玩家.PlayerName, 图标字符串(旗帜)), 无, 无, 左边, 1, 颜色(橙色), 颜色(白色), 颜色(白色),
			可见和字符串, 默认可见度);
		事件玩家.HUDdescribe6 = 上一个文本ID;
		禁用 修改全局变量(PlayerList, 根据索引从数组中移除, 事件玩家.PlayerListpoint);
		禁用 调用子程序(RefreshPlayerList);
	}
}

规则("消除通关效果")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.CurrentCheckpointNum != 数量(事件玩家.CurrentCheckpoints);
		事件玩家 == 主机玩家;
		禁用 事件玩家.CurrentCheckpointNum != 0;
		事件玩家.FinishGame == 真;
		全局.DesignMode == 真;
	}

	动作
	{
		事件玩家.FinishGame = 0;
		根据条件跳过(全局.AllowInvisible == 假, 2);
		事件玩家.Invisible = 真;
		调用子程序(SetInvisible);
		禁用 消除效果(事件玩家);
	}
}

禁用 规则("右上角排名")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
		禁用 事件玩家 == 主机玩家;
		禁用 按钮被按下(事件玩家, 按钮(技能1)) == 真;
		禁用 按钮被按下(事件玩家, 按钮(技能2)) == 真;
	}

	动作
	{
		禁用 For 玩家变量(事件玩家, CounterI, 0, 数量(全局.RankList), 1);
		禁用 If(此栏位的玩家(事件玩家.CounterI, 所有队伍).CurrentCheckpointNum >= 此栏位的玩家(事件玩家.CounterI + 1, 所有队伍).CurrentCheckpointNum);
		禁用 修改全局变量(RankList, 添加至数组, 矢量(事件玩家.CurrentCheckpointNum, 0, 栏位(事件玩家)));
		禁用 事件玩家.CurrentRankList = 已排序的数组(全局.RankList, 当前数组元素);
		禁用 创建HUD文本(事件玩家, 自定义字符串("{0} {1}/{2}", 此栏位的玩家(Z方向分量(全局.RankList)[0], 所有队伍).PlayerName, 事件玩家.CurrentCheckpointNum, 数量(全局.Checkpoints)),
			无, 无, 右边, 0, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		禁用 创建HUD文本(事件玩家, 自定义字符串("{0} {1}/{2}", 此栏位的玩家(Z方向分量(全局.RankList)[0], 所有队伍).PlayerName, 此栏位的玩家(Z方向分量(全局.RankList)[0], 所有队伍)
			.CurrentCheckpointNum, 数量(事件玩家.CurrentCheckpoints)), 无, 无, 左边, 10, 颜色(橙色), 颜色(紫色), 颜色(玫红), 可见和字符串, 默认可见度);
	}
}

禁用 规则("存进PlayList")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
		事件玩家.Getit == 假;
	}

	动作
	{
		全局.PlayerList[事件玩家.PlayerListpoint] = 矢量(事件玩家.CurrentCheckpointNum, 0, 栏位(事件玩家));
		禁用 事件玩家.CurrentRankList = 已排序的数组(全局.PlayerList, 当前数组元素);
		禁用 全局.RankList = 事件玩家.CurrentRankList;
		调用子程序(RefreshPlayerList);
	}
}

规则("玩家退出")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 假;
	}

	动作
	{
		禁用 修改全局变量(PlayerList, 根据索引从数组中移除, 事件玩家.PlayerListpoint);
		禁用 调用子程序(RefreshPlayerList);
		禁用 消除所有HUD文本;
	}
}

禁用 规则("子程序RefreshPlayerList")
{
	事件
	{
		子程序;
		RefreshPlayerList;
	}

	动作
	{
		事件玩家.CurrentRankList = 已排序的数组(全局.PlayerList, 当前数组元素);
		全局.RankList = 事件玩家.CurrentRankList;
	}
}

规则("飞行模式")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		死亡(事件玩家) == 假;
		(事件玩家.CurrentCheckpointNum >= 全局.UnlockFlyNum) == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 真;
		事件玩家.EditCamMode == 假;
		(事件玩家.AlreadyFaultTimes == 全局.FaultTimes + 1) == 假;
	}

	动作
	{
		设置引力(事件玩家, 0);
		While(按钮被按下(事件玩家, 按钮(跳跃)));
			施加推力(事件玩家, 上, 3, 至地图, 取消相反运动);
			等待(0.200, 无视条件);
		End;
		设置引力(事件玩家, 100);
	}
}

规则("每10s启用一次查看器并且同步关卡")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		全局.DesignMode == 真;
	}

	动作
	{
		启用查看器录制;
		禁用查看器录制;
		等待(10, 无视条件);
		事件玩家.CurrentCheckpoints = 全局.Checkpoints;
		事件玩家.CurrentCheckCampoints = 全局.CheckCampoints;
		禁用 根据条件跳过(事件玩家 != 主机玩家 && 事件玩家.CurrentCheckpointNum > 数量(事件玩家.CurrentCheckpoints), 1);
		禁用 事件玩家.CurrentCheckpointNum = 数量(事件玩家.CurrentCheckpoints);
		循环;
	}
}

规则("禁用半藏源氏爬墙DJ滑墙回声天使滑行1")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		(在墙上(事件玩家) || 正在空中(事件玩家)) == 真;
		数组包含(数组(英雄(半藏), 英雄(源氏), 英雄(卢西奥), 英雄(回声), 英雄(天使)), 所用英雄(事件玩家)) == 真;
	}

	动作
	{
		禁用按钮(事件玩家, 按钮(跳跃));
		取消主要动作(事件玩家);
	}
}

规则("禁用半藏源氏爬墙DJ滑墙回声天使滑行2")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		在地面上(事件玩家) == 真;
		数组包含(数组(英雄(半藏), 英雄(源氏), 英雄(卢西奥), 英雄(回声), 英雄(天使)), 所用英雄(事件玩家)) == 真;
	}

	动作
	{
		可用按钮(事件玩家, 按钮(跳跃));
	}
}

规则("按住V快速切换图片")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(近身攻击)) == 真;
		按钮被按下(事件玩家, 按钮(辅助攻击模式)) == 真;
		(取整(事件玩家.TempHorizontalAngle, 至最近) != 取整(水平朝向角度(事件玩家), 至最近)) == 真;
	}

	动作
	{
		事件玩家.PicNum = 绝对值(取整((事件玩家.TempNum2 - 水平朝向角度(事件玩家)) * 3 * 数量(事件玩家.CurrentCheckpoints) / 180 + 事件玩家.TempNum, 至最近)) % (
			事件玩家.TempNum + 1);
		事件玩家.TempHorizontalAngle = 水平朝向角度(事件玩家);
	}
}

规则("错误惩罚措施（送小黑屋喔）")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.AlreadyFaultTimes == 全局.FaultTimes + 1;
		已重生(事件玩家) == 真;
	}

	动作
	{
		事件玩家.CurrentPlayerpoint = 所选位置(事件玩家);
		If(当前地图 == 地图(沃斯卡娅工业区) || 当前地图 == 地图(沃斯卡娅工业区));
			传送(事件玩家, 矢量(-119.987, 7.320, 33.807));
		Else If(当前地图 == 地图(“地平线”月球基地));
			传送(事件玩家, 矢量(74.050, 9.500, -93.570));
		Else If(当前地图 == 地图(圣诞节花村) || 当前地图 == 地图(花村));
			传送(事件玩家, 矢量(1.870, -1.500, 26.170));
		Else If(当前地图 == 地图(国王大道) || 当前地图 == 地图(圣诞节国王大道));
			传送(事件玩家, 矢量(-59.763, 1.252, 4.371));
		Else If(当前地图 == 地图(暴雪世界) || 当前地图 == 地图(圣诞节暴雪世界));
			传送(事件玩家, 矢量(-35.050, -2.210, 146.480));
		Else If(当前地图 == 地图(渣客镇));
			传送(事件玩家, 矢量(-43.750, 4.270, -5.580));
		Else If(当前地图 == 地图(多拉多));
			传送(事件玩家, 矢量(-43.650, 27.362, -74.604));
		Else If(当前地图 == 地图(里阿尔托));
			传送(事件玩家, 矢量(-23.630, -0.230, -13.060));
		Else If(当前地图 == 地图(哈瓦那));
			传送(事件玩家, 矢量(-13.626, 27.730, -45.243));
		Else If(当前地图 == 地图(漓江塔) || 当前地图 == 地图(春节漓江塔) || 当前地图 == 地图(尼泊尔) || 当前地图 == 地图(伊利奥斯) || 当前地图 == 地图(绿洲城) || 当前地图 == 地图(釜山));
			设置状态(事件玩家, 无, 冰冻, 10);
		Else If(当前地图 == 地图(好莱坞) || 当前地图 == 地图(万圣节好莱坞));
			传送(事件玩家, 矢量(-33.448, 43.571, -17.049));
		Else If(当前地图 == 地图(阿努比斯神殿));
			传送(事件玩家, 矢量(-3.512, 122.172, 177.412));
		End;
		If(当前地图 == 地图(漓江塔) || 当前地图 == 地图(春节漓江塔) || 当前地图 == 地图(尼泊尔) || 当前地图 == 地图(伊利奥斯) || 当前地图 == 地图(绿洲城) || 当前地图 == 地图(釜山));
			小字体信息(事件玩家, 自定义字符串("太笨啦，被冻成冰雕了，不要再选错了哦"));
			大字体信息(所有玩家(所有队伍), 自定义字符串("{0}因为太笨被冻成冰雕啦，心疼一秒", 事件玩家.PlayerName));
		Else;
			小字体信息(事件玩家, 自定义字符串("选错太多啦，进小黑屋反省下吧！"));
			大字体信息(所有玩家(所有队伍), 自定义字符串("{0}因为打星际太多被关进小黑屋了，心疼1秒", 事件玩家.PlayerName));
		End;
		事件玩家.Invisible = 假;
		调用子程序(SetInvisible);
		等待(10, 无视条件);
		传送(事件玩家, 事件玩家.CurrentPlayerpoint);
		根据条件跳过(全局.AllowInvisible == 假, 2);
		事件玩家.Invisible = 真;
		调用子程序(SetInvisible);
		事件玩家.AlreadyFaultTimes = 0;
		小字体信息(事件玩家, 自定义字符串("这次先放过你，下次可不能再进来啦！"));
	}
}

规则("传送起始点")
{
	事件
	{
		子程序;
		GameStartTeleport;
	}

	动作
	{
		If(当前地图 == 地图(万圣节艾兴瓦尔德) || 当前地图 == 地图(艾兴瓦尔德));
			传送(事件玩家, 矢量(-15.360, 1, 18.800));
			设置朝向(事件玩家, 矢量(0.120, 0, -0.990), 至地图);
		Else If(当前地图 == 地图(圣诞节花村) || 当前地图 == 地图(花村));
			传送(事件玩家, 矢量(104.240, 1, -0.740));
			设置朝向(事件玩家, 矢量(-0.990, -0.120, 0), 至地图);
		Else If(当前地图 == 地图(漓江塔) || 当前地图 == 地图(春节漓江塔));
			传送(事件玩家, 矢量(-62.260, 267.580, 342.580));
			设置朝向(事件玩家, 矢量(0.720, 0.010, -0.700), 至地图);
		Else If(当前地图 == 地图(国王大道) || 当前地图 == 地图(圣诞节国王大道));
			传送(事件玩家, 矢量(4.020, 2, 54.080));
			设置朝向(事件玩家, 矢量(-0.190, -0.050, -0.980), 至地图);
		Else If(当前地图 == 地图(渣客镇));
			传送(事件玩家, 矢量(62.970, 9, -79.270));
			设置朝向(事件玩家, 矢量(-0.990, -0.040, 0.150), 至地图);
		Else If(当前地图 == 地图(里阿尔托));
			传送(事件玩家, 矢量(141.610, -1.490, -21.570));
			设置朝向(事件玩家, 矢量(-1, 0.040, 0.020), 至地图);
		Else If(当前地图 == 地图(暴雪世界) || 当前地图 == 地图(圣诞节暴雪世界));
			传送(事件玩家, 矢量(3.310, -4.950, -42.910));
			设置朝向(事件玩家, 矢量(0, 0.050, 1), 至地图);
		Else If(当前地图 == 地图(釜山));
			传送(事件玩家, 矢量(-426.880, 11.110, 165.760));
			设置朝向(事件玩家, 矢量(0.990, 0.010, -0.110), 至地图);
		Else If(当前地图 == 地图(“地平线”月球基地));
			传送(事件玩家, 矢量(-24.930, 17.880, 10.170));
			设置朝向(事件玩家, 矢量(0.880, -0.130, -0.460), 至地图);
		Else If(当前地图 == 地图(哈瓦那));
			传送(事件玩家, 矢量(-105.060, 4, -75.890));
			设置朝向(事件玩家, 矢量(0.730, -0.070, 0.680), 至地图);
		Else If(当前地图 == 地图(好莱坞) || 当前地图 == 地图(万圣节好莱坞));
			传送(事件玩家, 矢量(-12.137, 3.250, 90.621));
			设置朝向(事件玩家, 矢量(-12.024, 3.254, 85.976), 至地图);
		Else If(当前地图 == 地图(阿努比斯神殿));
			传送(事件玩家, 矢量(-1.875, 3.223, -41.622));
			设置朝向(事件玩家, 矢量(-1.875, 3.223, -41.622), 至地图);
		Else If(当前地图 == 地图(多拉多));
			传送(事件玩家, 矢量(-23.316, 1.049, -12.331));
			设置朝向(事件玩家, 矢量(-16.064, 1.650, -6.654), 至地图);
	}
}

规则("地图传送点位圈圈设置")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		If(当前地图 == 地图(万圣节艾兴瓦尔德) || 当前地图 == 地图(艾兴瓦尔德));
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-11.720, 0, -9.070), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-12.530, 1, -4.470), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-6.630, 3.550, -85.450), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-11.950, 5.300, -87.800), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(74.740, 10.700, -109.200), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(73.390, 10.720, -115.110), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(115.040, 10.720, -13.410), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(112.580, 10.740, -9.720), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(87.070, 12.860, -101.270), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(91.980, 12.720, -103.740), 2, 可见，位置和半径);
		Else If(当前地图 == 地图(圣诞节花村) || 当前地图 == 地图(花村));
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(76.470, -2, 0.150), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(71.460, -1.950, 0.040), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(13.990, -1, 13.530), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(14.060, 0, 8.360), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-38.150, 1, -86.960), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-42.120, 1, -90.140), 2, 可见，位置和半径);
		Else If(当前地图 == 地图(漓江塔) || 当前地图 == 地图(春节漓江塔));
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-54.280, 266.760, 335.240), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-57.890, 267.600, 338.520), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(53.810, 266.950, 334.770), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(57.190, 267.590, 338.100), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(72.960, 4.470, -31.500), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(67.680, 3.750, -32.570), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-69.240, 95.880, 145.790), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-74.320, 96.570, 145.060), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(74.510, 96.570, 145.380), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(69.220, 95.920, 145.650), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-65.570, 3.750, -31.460), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-70.520, 4.480, -30.710), 2, 可见，位置和半径);
		Else If(当前地图 == 地图(国王大道) || 当前地图 == 地图(圣诞节国王大道));
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-3.040, 1.150, 22.330), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-3.960, 0.070, 17.560), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-1.130, 0.040, -38.250), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(3.750, -0.770, -38.940), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-90.130, 0.940, -27.950), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-93.920, 1.500, -29.430), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-166.340, 0.070, 15.370), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-165.900, 0.070, 20.130), 2, 可见，位置和半径);
		Else If(当前地图 == 地图(渣客镇));
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(45.470, 10, -76.780), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(40.170, 10, -76.380), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-39.950, 7.290, -114.920), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-42.750, 6.420, -119.620), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-79.920, 7.430, -171.760), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-80.950, 7.440, -176.630), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-38.620, 4.060, -16.050), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-39.300, 4.270, -10.100), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-56.330, 7.510, -84.990), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-55.250, 9.060, -79.770), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-106.830, 6.440, -107.880), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-111.420, 6.440, -106.840), 2, 可见，位置和半径);
		Else If(当前地图 == 地图(里阿尔托));
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(0.740, -0.250, -86.310), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-4.610, -0.380, -85.920), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(67.140, -0.250, -57.050), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(72.110, -0.250, -59.360), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-15.700, -1.250, -30.500), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-16.440, -1.230, -24.750), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-74.200, 4.750, -148.720), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-74.250, 4.750, -153.080), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-40.860, 1.750, -110.390), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-41.050, 0.530, -115.450), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(119.120, -1.240, -20.550), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(113.270, -1.250, -21.090), 2, 可见，位置和半径);
		Else If(当前地图 == 地图(暴雪世界) || 当前地图 == 地图(圣诞节暴雪世界));
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(3.020, -3.990, -22.900), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(2.900, -4.100, -18.260), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-79.090, 0.790, 96.660), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-83.900, 0.750, 96.870), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-53.550, -0.250, 141.870), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-58.590, 0.750, 140.320), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-144.760, 0.750, 113.550), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-146.780, 0.750, 118.350), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-72.160, 1.750, 156.250), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-72.970, 1.750, 160.480), 2, 可见，位置和半径);
		Else If(当前地图 == 地图(釜山));
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-412.390, 10.110, 157.530), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-406.850, 10.070, 156.910), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-250.480, 10.350, 170.950), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-245.880, 10.360, 171.240), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(156.070, 11.100, 261.940), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(160.340, 10.100, 260.110), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(283.030, 11.090, 207.640), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(278.850, 10.100, 209.360), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(121, 17, -125.350), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(116.110, 16.250, -125.490), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-12.090, 16.130, -125.560), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-17.280, 17, -125.590), 2, 可见，位置和半径);
		Else If(当前地图 == 地图(“地平线”月球基地));
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(12.170, 9, -9.430), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(15.940, 9, -11.130), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(58.700, 8.990, -92.990), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(63.710, 9, -92.660), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-47.890, 5, -137.350), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-44.150, 5, -140.270), 2, 可见，位置和半径);
		Else If(当前地图 == 地图(哈瓦那));
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-82.460, 4, -65.590), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-79.250, 4, -62.700), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-43.290, 6, -86.130), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-38.570, 6, -86.070), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(57.210, 4.870, -72.940), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(57.240, 6.060, -77.450), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(69.230, 5, -107.010), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(69.080, 4.990, -101.650), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(92.430, 8.030, -33.670), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(92.370, 9, -28.880), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(158.580, 11.010, -62.080), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(153.180, 9.990, -62.440), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(1.281, 7.250, -48.435), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(1.229, 7.250, -42.409), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-35.657, 7.094, -17.142), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-34.935, 7.093, -28.184), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-106.240, 5.100, -28.772), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-99.279, 5.100, -37.757), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-79.390, 5.250, -93.697), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-83.951, 5.250, -88.796), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-114.377, 5.100, -85.357), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-113.017, 5.250, -78.268), 2, 可见，位置和半径);
		Else If(当前地图 == 地图(好莱坞) || 当前地图 == 地图(万圣节好莱坞));
			创建效果(所有玩家(所有队伍), 环, 颜色(青绿色), 矢量(-12.238, 2.257, 70.968), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(青绿色), 矢量(-12.168, 3.250, 78.201), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(青绿色), 矢量(-47.659, 3, -3.396), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(青绿色), 矢量(-51.450, 3, -5.555), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(青绿色), 矢量(-9.271, 2.980, -53.173), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(青绿色), 矢量(-11.991, 3, -48.274), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(青绿色), 矢量(-36.930, 5, -146.763), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(青绿色), 矢量(-38.745, 5, -154.229), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(青绿色), 矢量(35.890, 4, -53.152), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(青绿色), 矢量(-6.104, 4, -126.797), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(青绿色), 矢量(-7.157, 4, -130.950), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(青绿色), 矢量(26.792, 3.981, -53.181), 2, 可见，位置和半径);
		Else If(当前地图 == 地图(阿努比斯神殿));
			创建效果(所有玩家(所有队伍), 环, 颜色(白色), 矢量(-46.776, 2.962, 35.473), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(白色), 矢量(-50.267, 2.959, 33.216), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(白色), 矢量(2.352, 1.665, -19.185), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(白色), 矢量(5.179, 2.223, -23.878), 2, 可见，位置和半径);
		Else If(当前地图 == 地图(多拉多));
			创建效果(所有玩家(所有队伍), 环, 颜色(亮紫色), 矢量(55.032, 8.212, -35.447), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(亮紫色), 矢量(41.668, 8.462, -55.982), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(亮紫色), 矢量(142.771, 11.450, -1.233), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(亮紫色), 矢量(162.216, 11.462, -6.691), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(亮紫色), 矢量(80.706, 14.450, 25.674), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(亮紫色), 矢量(65.702, 15.462, 14.122), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(亮紫色), 矢量(168.155, 12.450, 46.767), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(亮紫色), 矢量(173.264, 10.934, 47.945), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(亮紫色), 矢量(207.007, 16.450, 47.105), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(亮紫色), 矢量(243.184, 16.460, 48.640), 2, 可见，位置和半径);
	}
}

规则("传送操作--艾兴瓦尔德")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 假;
		按钮被按下(事件玩家, 按钮(装填)) == 假;
		按钮被按下(事件玩家, 按钮(技能2)) == 假;
		按钮被按下(事件玩家, 按钮(终极技能)) == 假;
		(当前地图 == 地图(万圣节艾兴瓦尔德) || 当前地图 == 地图(艾兴瓦尔德)) == 真;
		(事件玩家.AlreadyFaultTimes == 全局.FaultTimes + 1) == 假;
	}

	动作
	{
		禁用 If(相距距离(所选位置(事件玩家), 矢量(0, 0, 0)) <= 2);
		禁用 传送(事件玩家, 矢量(0, 0, 0));
		禁用 Else If(相距距离(所选位置(事件玩家), 矢量(0, 0, 0)) <= 2);
		禁用 传送(事件玩家, 矢量(0, 0, 0));
		If(相距距离(所选位置(事件玩家), 矢量(-11.720, 0, -9.070)) <= 2);
			传送(事件玩家, 矢量(-12.530, 1, -4.470));
		Else If(相距距离(所选位置(事件玩家), 矢量(-12.530, 1, -4.470)) <= 2);
			传送(事件玩家, 矢量(-11.720, 0, -9.070));
		Else If(相距距离(所选位置(事件玩家), 矢量(-6.630, 3.550, -85.450)) <= 2);
			传送(事件玩家, 矢量(-11.950, 5.300, -87.800));
		Else If(相距距离(所选位置(事件玩家), 矢量(-11.950, 5.300, -87.800)) <= 2);
			传送(事件玩家, 矢量(-6.630, 3.550, -85.450));
		Else If(相距距离(所选位置(事件玩家), 矢量(74.740, 10.700, -109.200)) <= 2);
			传送(事件玩家, 矢量(73.390, 10.720, -115.110));
		Else If(相距距离(所选位置(事件玩家), 矢量(73.390, 10.720, -115.110)) <= 2);
			传送(事件玩家, 矢量(74.740, 10.700, -109.200));
		Else If(相距距离(所选位置(事件玩家), 矢量(115.040, 10.720, -13.410)) <= 2);
			传送(事件玩家, 矢量(112.580, 10.740, -9.720));
		Else If(相距距离(所选位置(事件玩家), 矢量(112.580, 10.740, -9.720)) <= 2);
			传送(事件玩家, 矢量(115.040, 10.720, -13.410));
		Else If(相距距离(所选位置(事件玩家), 矢量(91.980, 12.720, -103.740)) <= 2);
			传送(事件玩家, 矢量(87.070, 12.860, -101.270));
		Else If(相距距离(所选位置(事件玩家), 矢量(87.070, 12.860, -101.270)) <= 2);
			传送(事件玩家, 矢量(91.980, 12.720, -103.740));
	}
}

规则("传送操作--花村")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 假;
		按钮被按下(事件玩家, 按钮(装填)) == 假;
		按钮被按下(事件玩家, 按钮(技能2)) == 假;
		按钮被按下(事件玩家, 按钮(终极技能)) == 假;
		(当前地图 == 地图(圣诞节花村) || 当前地图 == 地图(花村)) == 真;
		(事件玩家.AlreadyFaultTimes == 全局.FaultTimes + 1) == 假;
	}

	动作
	{
		If(相距距离(所选位置(事件玩家), 矢量(76.470, -2, 0.150)) <= 2);
			传送(事件玩家, 矢量(71.460, -1.950, 0.040));
		Else If(相距距离(所选位置(事件玩家), 矢量(71.460, -1.950, 0.040)) <= 2);
			传送(事件玩家, 矢量(76.470, -2, 0.150));
		Else If(相距距离(所选位置(事件玩家), 矢量(13.990, -1, 13.530)) <= 2);
			传送(事件玩家, 矢量(14.060, 0, 8.360));
		Else If(相距距离(所选位置(事件玩家), 矢量(14.060, 0, 8.360)) <= 2);
			传送(事件玩家, 矢量(13.990, -1, 13.530));
		Else If(相距距离(所选位置(事件玩家), 矢量(-38.150, 1, -86.960)) <= 2);
			传送(事件玩家, 矢量(-42.120, 1, -90.140));
		Else If(相距距离(所选位置(事件玩家), 矢量(-42.120, 1, -90.140)) <= 2);
			传送(事件玩家, 矢量(-38.150, 1, -86.960));
	}
}

规则("传送操作--漓江塔")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 假;
		按钮被按下(事件玩家, 按钮(装填)) == 假;
		按钮被按下(事件玩家, 按钮(技能2)) == 假;
		按钮被按下(事件玩家, 按钮(终极技能)) == 假;
		(当前地图 == 地图(漓江塔) || 当前地图 == 地图(春节漓江塔)) == 真;
		(事件玩家.AlreadyFaultTimes == 全局.FaultTimes + 1) == 假;
	}

	动作
	{
		If(相距距离(所选位置(事件玩家), 矢量(-54.280, 266.760, 335.240)) <= 2);
			传送(事件玩家, 矢量(-57.890, 267.600, 338.520));
		Else If(相距距离(所选位置(事件玩家), 矢量(-57.890, 267.600, 338.520)) <= 2);
			传送(事件玩家, 矢量(-54.280, 266.760, 335.240));
		Else If(相距距离(所选位置(事件玩家), 矢量(53.810, 266.950, 334.770)) <= 2);
			传送(事件玩家, 矢量(57.190, 267.590, 338.100));
		Else If(相距距离(所选位置(事件玩家), 矢量(57.190, 267.590, 338.100)) <= 2);
			传送(事件玩家, 矢量(53.810, 266.950, 334.770));
		Else If(相距距离(所选位置(事件玩家), 矢量(-65.570, 3.750, -31.460)) <= 2);
			传送(事件玩家, 矢量(-70.520, 4.480, -30.710));
		Else If(相距距离(所选位置(事件玩家), 矢量(-70.520, 4.480, -30.710)) <= 2);
			传送(事件玩家, 矢量(-65.570, 3.750, -31.460));
		Else If(相距距离(所选位置(事件玩家), 矢量(72.960, 4.470, -31.500)) <= 2);
			传送(事件玩家, 矢量(67.680, 3.750, -32.570));
		Else If(相距距离(所选位置(事件玩家), 矢量(67.680, 3.750, -32.570)) <= 2);
			传送(事件玩家, 矢量(72.960, 4.470, -31.500));
		Else If(相距距离(所选位置(事件玩家), 矢量(-69.240, 95.880, 145.790)) <= 2);
			传送(事件玩家, 矢量(-74.320, 96.570, 145.060));
		Else If(相距距离(所选位置(事件玩家), 矢量(-74.320, 96.570, 145.060)) <= 2);
			传送(事件玩家, 矢量(-69.240, 95.880, 145.790));
		Else If(相距距离(所选位置(事件玩家), 矢量(74.510, 96.570, 145.380)) <= 2);
			传送(事件玩家, 矢量(69.220, 95.920, 145.650));
		Else If(相距距离(所选位置(事件玩家), 矢量(69.220, 95.920, 145.650)) <= 2);
			传送(事件玩家, 矢量(74.510, 96.570, 145.380));
	}
}

规则("传送操作--国王大道")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 假;
		按钮被按下(事件玩家, 按钮(装填)) == 假;
		按钮被按下(事件玩家, 按钮(技能2)) == 假;
		按钮被按下(事件玩家, 按钮(终极技能)) == 假;
		(当前地图 == 地图(国王大道) || 当前地图 == 地图(圣诞节国王大道)) == 真;
		(事件玩家.AlreadyFaultTimes == 全局.FaultTimes + 1) == 假;
	}

	动作
	{
		If(相距距离(所选位置(事件玩家), 矢量(-3.040, 1.150, 22.330)) <= 2);
			传送(事件玩家, 矢量(-3.960, 0.070, 17.560));
		Else If(相距距离(所选位置(事件玩家), 矢量(-3.960, 0.070, 17.560)) <= 2);
			传送(事件玩家, 矢量(-3.040, 1.150, 22.330));
		Else If(相距距离(所选位置(事件玩家), 矢量(-1.130, 0.040, -38.250)) <= 2);
			传送(事件玩家, 矢量(3.750, -0.770, -38.940));
		Else If(相距距离(所选位置(事件玩家), 矢量(3.750, -0.770, -38.940)) <= 2);
			传送(事件玩家, 矢量(-1.130, 0.040, -38.250));
		Else If(相距距离(所选位置(事件玩家), 矢量(-90.130, 0.940, -27.950)) <= 2);
			传送(事件玩家, 矢量(-93.920, 1.500, -29.430));
		Else If(相距距离(所选位置(事件玩家), 矢量(-93.920, 1.500, -29.430)) <= 2);
			传送(事件玩家, 矢量(-90.130, 0.940, -27.950));
		Else If(相距距离(所选位置(事件玩家), 矢量(-166.340, 0.070, 15.370)) <= 2);
			传送(事件玩家, 矢量(-165.900, 0.070, 20.130));
		Else If(相距距离(所选位置(事件玩家), 矢量(-165.900, 0.070, 20.130)) <= 2);
			传送(事件玩家, 矢量(-166.340, 0.070, 15.370));
	}
}

规则("传送操作--渣客镇")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 假;
		按钮被按下(事件玩家, 按钮(装填)) == 假;
		按钮被按下(事件玩家, 按钮(技能2)) == 假;
		按钮被按下(事件玩家, 按钮(终极技能)) == 假;
		(当前地图 == 地图(渣客镇)) == 真;
		(事件玩家.AlreadyFaultTimes == 全局.FaultTimes + 1) == 假;
	}

	动作
	{
		If(相距距离(所选位置(事件玩家), 矢量(45.470, 10, -76.780)) <= 2);
			传送(事件玩家, 矢量(40.170, 10, -76.380));
		Else If(相距距离(所选位置(事件玩家), 矢量(40.170, 10, -76.380)) <= 2);
			传送(事件玩家, 矢量(45.470, 10, -76.780));
		Else If(相距距离(所选位置(事件玩家), 矢量(-39.950, 7.290, -114.920)) <= 2);
			传送(事件玩家, 矢量(-42.750, 6.420, -119.620));
		Else If(相距距离(所选位置(事件玩家), 矢量(-42.750, 6.420, -119.620)) <= 2);
			传送(事件玩家, 矢量(-39.950, 7.290, -114.920));
		Else If(相距距离(所选位置(事件玩家), 矢量(-79.920, 7.430, -171.760)) <= 2);
			传送(事件玩家, 矢量(-80.950, 7.440, -176.630));
		Else If(相距距离(所选位置(事件玩家), 矢量(-80.950, 7.440, -176.630)) <= 2);
			传送(事件玩家, 矢量(-79.920, 7.430, -171.760));
		Else If(相距距离(所选位置(事件玩家), 矢量(-38.620, 4.060, -16.050)) <= 2);
			传送(事件玩家, 矢量(-39.300, 4.270, -10.100));
		Else If(相距距离(所选位置(事件玩家), 矢量(-39.300, 4.270, -10.100)) <= 2);
			传送(事件玩家, 矢量(-38.620, 4.060, -16.050));
		Else If(相距距离(所选位置(事件玩家), 矢量(-56.330, 7.510, -84.990)) <= 2);
			传送(事件玩家, 矢量(-55.250, 9.060, -79.770));
		Else If(相距距离(所选位置(事件玩家), 矢量(-55.250, 9.060, -79.770)) <= 2);
			传送(事件玩家, 矢量(-56.330, 7.510, -84.990));
		Else If(相距距离(所选位置(事件玩家), 矢量(-106.830, 6.440, -107.880)) <= 2);
			传送(事件玩家, 矢量(-111.420, 6.440, -106.840));
		Else If(相距距离(所选位置(事件玩家), 矢量(-111.420, 6.440, -106.840)) <= 2);
			传送(事件玩家, 矢量(-106.830, 6.440, -107.880));
	}
}

规则("传送操作--里阿尔托")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 假;
		按钮被按下(事件玩家, 按钮(装填)) == 假;
		按钮被按下(事件玩家, 按钮(技能2)) == 假;
		按钮被按下(事件玩家, 按钮(终极技能)) == 假;
		(当前地图 == 地图(里阿尔托)) == 真;
		(事件玩家.AlreadyFaultTimes == 全局.FaultTimes + 1) == 假;
	}

	动作
	{
		If(相距距离(所选位置(事件玩家), 矢量(119.120, -1.240, -20.550)) <= 2);
			传送(事件玩家, 矢量(113.270, -1.250, -21.090));
		Else If(相距距离(所选位置(事件玩家), 矢量(113.270, -1.250, -21.090)) <= 2);
			传送(事件玩家, 矢量(119.120, -1.240, -20.550));
		Else If(相距距离(所选位置(事件玩家), 矢量(0.740, -0.250, -86.310)) <= 2);
			传送(事件玩家, 矢量(-4.610, -0.380, -85.920));
		Else If(相距距离(所选位置(事件玩家), 矢量(-4.610, -0.380, -85.920)) <= 2);
			传送(事件玩家, 矢量(0.740, -0.250, -86.310));
		Else If(相距距离(所选位置(事件玩家), 矢量(67.140, -0.250, -57.050)) <= 2);
			传送(事件玩家, 矢量(72.110, -0.250, -59.360));
		Else If(相距距离(所选位置(事件玩家), 矢量(72.110, -0.250, -59.360)) <= 2);
			传送(事件玩家, 矢量(67.140, -0.250, -57.050));
		Else If(相距距离(所选位置(事件玩家), 矢量(-15.700, -1.250, -30.500)) <= 2);
			传送(事件玩家, 矢量(-16.440, -1.230, -24.750));
		Else If(相距距离(所选位置(事件玩家), 矢量(-16.440, -1.230, -24.750)) <= 2);
			传送(事件玩家, 矢量(-15.700, -1.250, -30.500));
		Else If(相距距离(所选位置(事件玩家), 矢量(-74.200, 4.750, -148.720)) <= 2);
			传送(事件玩家, 矢量(-74.250, 4.750, -153.080));
		Else If(相距距离(所选位置(事件玩家), 矢量(-74.250, 4.750, -153.080)) <= 2);
			传送(事件玩家, 矢量(-74.200, 4.750, -148.720));
		Else If(相距距离(所选位置(事件玩家), 矢量(-40.860, 1.750, -110.390)) <= 2);
			传送(事件玩家, 矢量(-41.050, 0.530, -115.450));
		Else If(相距距离(所选位置(事件玩家), 矢量(-41.050, 0.530, -115.450)) <= 2);
			传送(事件玩家, 矢量(-40.860, 1.750, -110.390));
	}
}

规则("传送操作--暴-雪世界")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 假;
		按钮被按下(事件玩家, 按钮(装填)) == 假;
		按钮被按下(事件玩家, 按钮(技能2)) == 假;
		按钮被按下(事件玩家, 按钮(终极技能)) == 假;
		(当前地图 == 地图(暴雪世界) || 当前地图 == 地图(圣诞节暴雪世界)) == 真;
		(事件玩家.AlreadyFaultTimes == 全局.FaultTimes + 1) == 假;
	}

	动作
	{
		If(相距距离(所选位置(事件玩家), 矢量(3.020, -3.990, -22.900)) <= 2);
			传送(事件玩家, 矢量(2.900, -4.100, -18.260));
		Else If(相距距离(所选位置(事件玩家), 矢量(2.900, -4.100, -18.260)) <= 2);
			传送(事件玩家, 矢量(3.020, -3.990, -22.900));
		Else If(相距距离(所选位置(事件玩家), 矢量(-79.090, 0.790, 96.660)) <= 2);
			传送(事件玩家, 矢量(-83.900, 0.750, 96.870));
		Else If(相距距离(所选位置(事件玩家), 矢量(-83.900, 0.750, 96.870)) <= 2);
			传送(事件玩家, 矢量(-79.090, 0.790, 96.660));
		Else If(相距距离(所选位置(事件玩家), 矢量(-53.550, -0.250, 141.870)) <= 2);
			传送(事件玩家, 矢量(-58.590, 0.750, 140.320));
		Else If(相距距离(所选位置(事件玩家), 矢量(-58.590, 0.750, 140.320)) <= 2);
			传送(事件玩家, 矢量(-53.550, -0.250, 141.870));
		Else If(相距距离(所选位置(事件玩家), 矢量(-144.760, 0.750, 113.550)) <= 2);
			传送(事件玩家, 矢量(-146.780, 0.750, 118.350));
		Else If(相距距离(所选位置(事件玩家), 矢量(-146.780, 0.750, 118.350)) <= 2);
			传送(事件玩家, 矢量(-144.760, 0.750, 113.550));
		Else If(相距距离(所选位置(事件玩家), 矢量(-72.160, 1.750, 156.250)) <= 2);
			传送(事件玩家, 矢量(-72.970, 1.750, 160.480));
		Else If(相距距离(所选位置(事件玩家), 矢量(-72.970, 1.750, 160.480)) <= 2);
			传送(事件玩家, 矢量(-72.160, 1.750, 156.250));
	}
}

规则("传送操作--釜山")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 假;
		按钮被按下(事件玩家, 按钮(装填)) == 假;
		按钮被按下(事件玩家, 按钮(技能2)) == 假;
		按钮被按下(事件玩家, 按钮(终极技能)) == 假;
		当前地图 == 地图(釜山);
		(事件玩家.AlreadyFaultTimes == 全局.FaultTimes + 1) == 假;
	}

	动作
	{
		If(相距距离(所选位置(事件玩家), 矢量(-412.390, 10.110, 157.530)) <= 2);
			传送(事件玩家, 矢量(-406.850, 10.070, 156.910));
		Else If(相距距离(所选位置(事件玩家), 矢量(-406.850, 10.070, 156.910)) <= 2);
			传送(事件玩家, 矢量(-412.390, 10.110, 157.530));
		Else If(相距距离(所选位置(事件玩家), 矢量(-250.480, 10.350, 170.950)) <= 2);
			传送(事件玩家, 矢量(-245.880, 10.360, 171.240));
		Else If(相距距离(所选位置(事件玩家), 矢量(-245.880, 10.360, 171.240)) <= 2);
			传送(事件玩家, 矢量(-250.480, 10.350, 170.950));
		Else If(相距距离(所选位置(事件玩家), 矢量(156.070, 11.100, 261.940)) <= 2);
			传送(事件玩家, 矢量(160.340, 10.100, 260.110));
		Else If(相距距离(所选位置(事件玩家), 矢量(160.340, 10.100, 260.110)) <= 2);
			传送(事件玩家, 矢量(156.070, 11.100, 261.940));
		Else If(相距距离(所选位置(事件玩家), 矢量(283.030, 11.090, 207.640)) <= 2);
			传送(事件玩家, 矢量(278.850, 10.100, 209.360));
		Else If(相距距离(所选位置(事件玩家), 矢量(278.850, 10.100, 209.360)) <= 2);
			传送(事件玩家, 矢量(283.030, 11.090, 207.640));
		Else If(相距距离(所选位置(事件玩家), 矢量(121, 17, -125.350)) <= 2);
			传送(事件玩家, 矢量(116.110, 16.250, -125.490));
		Else If(相距距离(所选位置(事件玩家), 矢量(116.110, 16.250, -125.490)) <= 2);
			传送(事件玩家, 矢量(121, 17, -125.350));
		Else If(相距距离(所选位置(事件玩家), 矢量(-12.090, 16.130, -125.560)) <= 2);
			传送(事件玩家, 矢量(-17.280, 17, -125.590));
		Else If(相距距离(所选位置(事件玩家), 矢量(-17.280, 17, -125.590)) <= 2);
			传送(事件玩家, 矢量(-12.090, 16.130, -125.560));
	}
}

规则("传送操作--月球基地")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 假;
		按钮被按下(事件玩家, 按钮(装填)) == 假;
		按钮被按下(事件玩家, 按钮(技能2)) == 假;
		按钮被按下(事件玩家, 按钮(终极技能)) == 假;
		当前地图 == 地图(“地平线”月球基地);
		(事件玩家.AlreadyFaultTimes == 全局.FaultTimes + 1) == 假;
	}

	动作
	{
		If(相距距离(所选位置(事件玩家), 矢量(12.170, 9, -9.430)) <= 2);
			传送(事件玩家, 矢量(15.940, 9, -11.130));
		Else If(相距距离(所选位置(事件玩家), 矢量(15.940, 9, -11.130)) <= 2);
			传送(事件玩家, 矢量(12.170, 9, -9.430));
		Else If(相距距离(所选位置(事件玩家), 矢量(58.700, 8.990, -92.990)) <= 2);
			传送(事件玩家, 矢量(63.710, 9, -92.660));
		Else If(相距距离(所选位置(事件玩家), 矢量(63.710, 9, -92.660)) <= 2);
			传送(事件玩家, 矢量(58.700, 8.990, -92.990));
		Else If(相距距离(所选位置(事件玩家), 矢量(-47.890, 5, -137.350)) <= 2);
			传送(事件玩家, 矢量(-44.150, 5, -140.270));
		Else If(相距距离(所选位置(事件玩家), 矢量(-44.150, 5, -140.270)) <= 2);
			传送(事件玩家, 矢量(-47.890, 5, -137.350));
	}
}

规则("传送操作--哈瓦那")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 假;
		按钮被按下(事件玩家, 按钮(装填)) == 假;
		按钮被按下(事件玩家, 按钮(技能2)) == 假;
		按钮被按下(事件玩家, 按钮(终极技能)) == 假;
		(当前地图 == 地图(哈瓦那)) == 真;
		(事件玩家.AlreadyFaultTimes == 全局.FaultTimes + 1) == 假;
	}

	动作
	{
		If(相距距离(所选位置(事件玩家), 矢量(-82.460, 4, -65.590)) <= 2);
			传送(事件玩家, 矢量(-79.250, 4, -62.700));
		Else If(相距距离(所选位置(事件玩家), 矢量(-79.250, 4, -62.700)) <= 2);
			传送(事件玩家, 矢量(-82.460, 4, -65.590));
		Else If(相距距离(所选位置(事件玩家), 矢量(-43.290, 6, -86.130)) <= 2);
			传送(事件玩家, 矢量(-38.570, 6, -86.070));
		Else If(相距距离(所选位置(事件玩家), 矢量(-38.570, 6, -86.070)) <= 2);
			传送(事件玩家, 矢量(-43.290, 6, -86.130));
		Else If(相距距离(所选位置(事件玩家), 矢量(57.210, 4.870, -72.940)) <= 2);
			传送(事件玩家, 矢量(57.240, 6.060, -77.450));
		Else If(相距距离(所选位置(事件玩家), 矢量(57.240, 6.060, -77.450)) <= 2);
			传送(事件玩家, 矢量(57.210, 4.870, -72.940));
		Else If(相距距离(所选位置(事件玩家), 矢量(69.230, 5, -107.010)) <= 2);
			传送(事件玩家, 矢量(69.080, 4.990, -101.650));
		Else If(相距距离(所选位置(事件玩家), 矢量(69.080, 4.990, -101.650)) <= 2);
			传送(事件玩家, 矢量(69.230, 5, -107.010));
		Else If(相距距离(所选位置(事件玩家), 矢量(92.430, 8.030, -33.670)) <= 2);
			传送(事件玩家, 矢量(92.370, 9, -28.880));
		Else If(相距距离(所选位置(事件玩家), 矢量(92.370, 9, -28.880)) <= 2);
			传送(事件玩家, 矢量(92.430, 8.030, -33.670));
		Else If(相距距离(所选位置(事件玩家), 矢量(158.580, 11.010, -62.080)) <= 2);
			传送(事件玩家, 矢量(153.180, 9.990, -62.440));
		Else If(相距距离(所选位置(事件玩家), 矢量(153.180, 9.990, -62.440)) <= 2);
			传送(事件玩家, 矢量(158.580, 11.010, -62.080));
		Else If(相距距离(所选位置(事件玩家), 矢量(1.281, 7.250, -48.435)) <= 2);
			传送(事件玩家, 矢量(1.229, 7.250, -42.409));
		Else If(相距距离(所选位置(事件玩家), 矢量(1.229, 7.250, -42.409)) <= 2);
			传送(事件玩家, 矢量(1.281, 7.250, -48.435));
		Else If(相距距离(所选位置(事件玩家), 矢量(-35.657, 7.094, -17.142)) <= 2);
			传送(事件玩家, 矢量(-34.935, 7.093, -28.184));
		Else If(相距距离(所选位置(事件玩家), 矢量(-34.935, 7.093, -28.184)) <= 2);
			传送(事件玩家, 矢量(-35.657, 7.094, -17.142));
		Else If(相距距离(所选位置(事件玩家), 矢量(-106.240, 5.100, -28.772)) <= 2);
			传送(事件玩家, 矢量(-99.279, 5.100, -37.757));
		Else If(相距距离(所选位置(事件玩家), 矢量(-99.279, 5.100, -37.757)) <= 2);
			传送(事件玩家, 矢量(-106.240, 5.100, -28.772));
		Else If(相距距离(所选位置(事件玩家), 矢量(-79.281, 5.262, -93.094)) <= 2);
			传送(事件玩家, 矢量(-83.951, 5.250, -88.796));
		Else If(相距距离(所选位置(事件玩家), 矢量(-83.951, 5.250, -88.796)) <= 2);
			传送(事件玩家, 矢量(-79.281, 5.262, -93.094));
		Else If(相距距离(所选位置(事件玩家), 矢量(-114.377, 5.100, -85.357)) <= 2);
			传送(事件玩家, 矢量(-113.017, 5.250, -78.268));
		Else If(相距距离(所选位置(事件玩家), 矢量(-113.017, 5.250, -78.268)) <= 2);
			传送(事件玩家, 矢量(-114.377, 5.100, -85.357));
	}
}

规则("传送操作--阿努比斯神殿")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 假;
		按钮被按下(事件玩家, 按钮(装填)) == 假;
		按钮被按下(事件玩家, 按钮(技能2)) == 假;
		按钮被按下(事件玩家, 按钮(终极技能)) == 假;
		(当前地图 == 地图(阿努比斯神殿)) == 真;
		(事件玩家.AlreadyFaultTimes == 全局.FaultTimes + 1) == 假;
	}

	动作
	{
		If(相距距离(所选位置(事件玩家), 矢量(-46.776, 2.962, 35.473)) <= 2);
			传送(事件玩家, 矢量(-50.267, 2.959, 33.216));
		Else If(相距距离(所选位置(事件玩家), 矢量(-50.267, 2.959, 33.216)) <= 2);
			传送(事件玩家, 矢量(-46.776, 2.962, 35.473));
		Else If(相距距离(所选位置(事件玩家), 矢量(2.352, 1.665, -19.185)) <= 2);
			传送(事件玩家, 矢量(5.179, 2.223, -23.878));
		Else If(相距距离(所选位置(事件玩家), 矢量(5.179, 2.223, -23.878)) <= 2);
			传送(事件玩家, 矢量(2.352, 1.665, -19.185));
	}
}

规则("传送操作--多拉多")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 假;
		按钮被按下(事件玩家, 按钮(装填)) == 假;
		按钮被按下(事件玩家, 按钮(技能2)) == 假;
		按钮被按下(事件玩家, 按钮(终极技能)) == 假;
		(当前地图 == 地图(多拉多)) == 真;
		(事件玩家.AlreadyFaultTimes == 全局.FaultTimes + 1) == 假;
	}

	动作
	{
		If(相距距离(所选位置(事件玩家), 矢量(55.032, 8.212, -35.447)) <= 2);
			传送(事件玩家, 矢量(41.668, 8.462, -55.982));
		Else If(相距距离(所选位置(事件玩家), 矢量(41.668, 8.462, -55.982)) <= 2);
			传送(事件玩家, 矢量(55.032, 8.212, -35.447));
		Else If(相距距离(所选位置(事件玩家), 矢量(142.771, 11.450, -1.233)) <= 2);
			传送(事件玩家, 矢量(162.216, 11.462, -6.691));
		Else If(相距距离(所选位置(事件玩家), 矢量(162.216, 11.462, -6.691)) <= 2);
			传送(事件玩家, 矢量(142.771, 11.450, -1.233));
		Else If(相距距离(所选位置(事件玩家), 矢量(80.706, 14.450, 25.674)) <= 2);
			传送(事件玩家, 矢量(65.702, 15.462, 14.122));
		Else If(相距距离(所选位置(事件玩家), 矢量(65.702, 15.462, 14.122)) <= 2);
			传送(事件玩家, 矢量(80.706, 14.450, 25.674));
		Else If(相距距离(所选位置(事件玩家), 矢量(168.155, 12.450, 46.767)) <= 2);
			传送(事件玩家, 矢量(173.264, 10.934, 47.945));
		Else If(相距距离(所选位置(事件玩家), 矢量(173.264, 10.934, 47.945)) <= 2);
			传送(事件玩家, 矢量(168.155, 12.450, 46.767));
		Else If(相距距离(所选位置(事件玩家), 矢量(207.007, 16.450, 47.105)) <= 2);
			传送(事件玩家, 矢量(243.184, 16.460, 48.640));
		Else If(相距距离(所选位置(事件玩家), 矢量(243.184, 16.460, 48.640)) <= 2);
			传送(事件玩家, 矢量(207.007, 16.450, 47.105));
	}
}

规则("传送操作--好莱坞&万圣节好莱坞")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 假;
		按钮被按下(事件玩家, 按钮(装填)) == 假;
		按钮被按下(事件玩家, 按钮(技能2)) == 假;
		按钮被按下(事件玩家, 按钮(终极技能)) == 假;
		(当前地图 == 地图(万圣节好莱坞) || 当前地图 == 地图(好莱坞)) == 真;
		(事件玩家.AlreadyFaultTimes == 全局.FaultTimes + 1) == 假;
	}

	动作
	{
		If(相距距离(所选位置(事件玩家), 矢量(-12.238, 2.257, 70.968)) <= 2);
			传送(事件玩家, 矢量(-12.168, 3.250, 78.201));
		Else If(相距距离(所选位置(事件玩家), 矢量(-12.168, 3.250, 78.201)) <= 2);
			传送(事件玩家, 矢量(-12.238, 2.250, 70.968));
		Else If(相距距离(所选位置(事件玩家), 矢量(-47.659, 3, -3.396)) <= 2);
			传送(事件玩家, 矢量(-51.450, 3, -5.555));
		Else If(相距距离(所选位置(事件玩家), 矢量(-51.450, 3, -5.555)) <= 2);
			传送(事件玩家, 矢量(-47.659, 3, -3.396));
		Else If(相距距离(所选位置(事件玩家), 矢量(-9.271, 2.980, -53.173)) <= 2);
			传送(事件玩家, 矢量(-11.991, 3, -48.274));
		Else If(相距距离(所选位置(事件玩家), 矢量(-11.991, 3, -48.274)) <= 2);
			传送(事件玩家, 矢量(-9.271, 2.980, -53.173));
		Else If(相距距离(所选位置(事件玩家), 矢量(-36.930, 5, -146.763)) <= 2);
			传送(事件玩家, 矢量(-38.745, 5, -154.229));
		Else If(相距距离(所选位置(事件玩家), 矢量(-38.745, 5, -154.229)) <= 2);
			传送(事件玩家, 矢量(-36.930, 5, -146.763));
		Else If(相距距离(所选位置(事件玩家), 矢量(35.830, 4, -53.152)) <= 2);
			传送(事件玩家, 矢量(26.792, 3.981, -53.181));
		Else If(相距距离(所选位置(事件玩家), 矢量(26.792, 3.981, -53.181)) <= 2);
			传送(事件玩家, 矢量(35.890, 4, -53.152));
		Else If(相距距离(所选位置(事件玩家), 矢量(-6.104, 4, -126.797)) <= 2);
			传送(事件玩家, 矢量(-7.157, 4, -130.950));
		Else If(相距距离(所选位置(事件玩家), 矢量(-7.157, 4, -130.950)) <= 2);
			传送(事件玩家, 矢量(-6.104, 4, -126.797));
	}
}

规则("占点图地图中心点位")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	动作
	{
		If(当前地图 == 地图(漓江塔) || 当前地图 == 地图(春节漓江塔));
			事件玩家.TeleportE[0] = 矢量(-0.350, 270, 298.320);
			事件玩家.TeleportE[1] = 矢量(1.080, -1.140, -29.840);
			事件玩家.TeleportE[2] = 矢量(-0.450, 94.050, 134.360);
			事件玩家.TeleportName[0] = 自定义字符串("控制中心");
			事件玩家.TeleportName[1] = 自定义字符串("夜市");
			事件玩家.TeleportName[2] = 自定义字符串("庭院");
		Else If(当前地图 == 地图(釜山));
			事件玩家.TeleportE[0] = 矢量(-328.400, 8.210, 131.160);
			事件玩家.TeleportE[1] = 矢量(51.790, 10, -110.930);
			事件玩家.TeleportE[2] = 矢量(215.370, 17.190, 225.010);
			事件玩家.TeleportName[0] = 自定义字符串("寺院");
			事件玩家.TeleportName[1] = 自定义字符串("城区");
			事件玩家.TeleportName[2] = 自定义字符串("体育场");
	}
}

规则("占点图按E传送地图")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(技能2)) == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 假;
		按钮被按下(事件玩家, 按钮(跳跃)) == 假;
		按钮被按下(事件玩家, 按钮(互动)) == 假;
		(当前地图 == 地图(漓江塔) || 当前地图 == 地图(春节漓江塔) || 当前地图 == 地图(尼泊尔) || 当前地图 == 地图(伊利奥斯) || 当前地图 == 地图(绿洲城) || 当前地图 == 地图(釜山)) == 真;
		(事件玩家.AlreadyFaultTimes == 全局.FaultTimes + 1) == 假;
		存活(事件玩家) == 真;
	}

	动作
	{
		根据条件跳过(事件玩家.TeleportENum != 2, 1);
		事件玩家.TeleportENum = -1;
		传送(事件玩家, 事件玩家.TeleportE[事件玩家.TeleportENum + 1]);
		播放效果(所有玩家(所有队伍), 环状爆炸声音, 颜色(白色), 事件玩家, 100);
		事件玩家.TeleportENum += 1;
		禁用 If(当前地图 == 地图(春节漓江塔控制中心) || 当前地图 == 地图(漓江塔控制中心));
		禁用 传送(事件玩家, 矢量(1.080, -1.140, -29.840));
		禁用 Else If(事件玩家.TeleportENum == 2);
		禁用 传送(事件玩家, 矢量(-0.450, 94.050, 134.360));
		禁用 Else If(当前地图 == 地图(春节漓江塔庭院) || 当前地图 == 地图(漓江塔庭院));
		禁用 传送(事件玩家, 矢量(-0.350, 270, 298.320));
		大字体信息(事件玩家, 自定义字符串("传送至——{0}", 事件玩家.TeleportName[事件玩家.TeleportENum]));
		等待(1, 无视条件);
	}
}

禁用 规则("重置通关特效")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.FinishGame == 真;
		按钮被按下(事件玩家, 按钮(装填)) == 真;
		已重生(事件玩家) == 真;
	}

	动作
	{
		等待(2, 无视条件);
		如条件为“假”则中止;
		消除效果(事件玩家.FireEffect[0]);
		消除效果(事件玩家.FireEffect[1]);
		消除效果(事件玩家.FireEffect[2]);
		消除效果(事件玩家.FireEffect[3]);
		创建效果(所有玩家(所有队伍), 火花, 颜色(绿色), 事件玩家, 0.350, 可见，位置和半径);
		事件玩家.FireEffect[0] = 最后创建的实体;
		创建效果(所有玩家(所有队伍), 火花, 颜色(蓝色), 事件玩家, 0.350, 可见，位置和半径);
		事件玩家.FireEffect[1] = 最后创建的实体;
		创建效果(所有玩家(所有队伍), 火花, 颜色(亮紫色), 事件玩家, 0.350, 可见，位置和半径);
		事件玩家.FireEffect[2] = 最后创建的实体;
		创建效果(所有玩家(所有队伍), 火花, 颜色(橙色), 事件玩家, 0.350, 可见，位置和半径);
		事件玩家.FireEffect[3] = 最后创建的实体;
		小字体信息(事件玩家, 自定义字符串("已重置特效"));
	}
}

规则("顶部描述")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		While(真);
			设置目标点描述(所有玩家(所有队伍), 自定义字符串("按住右键看图，再按左键回看\r\n    互动键 F         确认图片\r\n  长按 SHIFT       加速移动\r\n    CTRL 键        进出传送门"), 可见和字符串);
			等待(5, 无视条件);
			设置目标点描述(所有玩家(所有队伍), 自定义字符串("  发送“你好”     关卡提示\r\n       F+E             进入观战\r\n       R+V            强制传送\r\n30关之后，长按空格键可飞行"),
				可见和字符串);
			等待(5, 无视条件);
			设置目标点描述(所有玩家(所有队伍), 自定义字符串("作者：{0}\r\n代码：{1}", 全局.MapDesigner, 全局.ShareCode, 全局.ThanksList), 可见和字符串);
			等待(5, 无视条件);
		End;
	}
}

规则("操作提示提醒")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
	}

	动作
	{
		创建HUD文本(事件玩家, 自定义字符串("↑上方操作提示，我看谁还看不见！！！！↑"), 无, 无, 顶部, 10, 颜色(玫红), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		等待(30, 无视条件);
		消除HUD文本(上一个文本ID);
	}
}

禁用 规则("【掉崖弹起】")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		(Y方向分量(所选位置(事件玩家)) <= -6) == 真;
	}

	动作
	{
		施加推力(事件玩家, 上, 10, 至地图, 取消相反运动);
	}
}

规则("地图传送点位圈圈设置")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		If(当前地图 == 地图(沃斯卡娅工业区) || 当前地图 == 地图(沃斯卡娅工业区));
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(-0.304, -4.468, 14.309), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(2.601, -3.980, 11.779), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(15.330, -0.980, 72.682), 2, 可见，位置和半径);
			创建效果(所有玩家(所有队伍), 环, 颜色(绿色), 矢量(18.619, -0.722, 72.781), 2, 可见，位置和半径);
	}
}

规则("传送操作--艾兴瓦尔德")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 假;
		按钮被按下(事件玩家, 按钮(装填)) == 假;
		按钮被按下(事件玩家, 按钮(技能2)) == 假;
		按钮被按下(事件玩家, 按钮(终极技能)) == 假;
		(当前地图 == 地图(沃斯卡娅工业区) || 当前地图 == 地图(沃斯卡娅工业区)) == 真;
	}

	动作
	{
		If(相距距离(所选位置(事件玩家), 矢量(15.330, -0.980, 72.682)) <= 2);
			传送(事件玩家, 矢量(18.619, -0.722, 72.781));
		Else If(相距距离(所选位置(事件玩家), 矢量(18.619, -0.722, 72.781)) <= 2);
			传送(事件玩家, 矢量(15.330, -0.980, 72.682));
		Else If(相距距离(所选位置(事件玩家), 矢量(0.176, -4.047, 14.334)) <= 2);
			传送(事件玩家, 矢量(2.601, -3.730, 11.779));
		Else If(相距距离(所选位置(事件玩家), 矢量(2.601, -3.805, 11.779)) <= 2);
			传送(事件玩家, 矢量(-0.304, -4.293, 14.309));
	}
}