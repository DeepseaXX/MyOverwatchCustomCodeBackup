设置
{
	主程序
	{
		描述: "列文虎克找东西-南极洲★找到物品并按[F]★3个乒乓球拍★27件带守望先锋标志的物品（不用跳！不用跳！）★8只雪怪★2幅自画像★11个黄色气瓶★7个单品：生**糕、外星人、没有女王的国王、雪球、可爱的小狗、书签、虚构的国旗★按 [SHIFT] 奔跑 ★ 按[L] 返回大厅 ★ 务必在画面设置设定中或高的模型细节和100%的渲染★Made by Foren#2660 授权搬运by KDLin#5710 提示在owmod.net搜索本图"
	}

	大厅
	{
		地图轮换: 暂停轮换
		比赛结束后转换队伍: 否
		比赛语音聊天: 启用
		自由混战人数上限: 6
		观战者人数上限: 0
		返回大厅: 从不
	}

	模式
	{
		死斗
		{
			比赛时长（分钟）: 5
			获胜得分: 1

			启用地图
			{
				生态监测站：南极洲
			}
		}

		突击模式
		{
			启用地图
			{
			}
		}

		综合
		{
			允许切换英雄: 关闭
			复生时间: 0%
			急救包刷新: 禁用
			消灭提示: 关闭
			消灭镜头: 关闭
			游戏模式开始: 即时
			英雄限制: 关闭
			随机英雄复生: 开启
		}
	}

	英雄
	{
		综合
		{
			主要攻击模式: 关闭
			仅爆头有效: 开启
			战斗时终极技能充能速度: 0%
			技能冷却时间: 50%
			移动速度: 110%
			终极技能充能速度: 10%
			终极技能自动充能速度: 0%
			近身攻击: 关闭

			禅雅塔
			{
				主要攻击模式: 关闭
				乱: 关闭
				谐: 关闭
				辅助攻击模式: 关闭
				近身攻击: 关闭
			}

			启用英雄
			{
				禅雅塔
			}
		}
	}
}

变量
{
	玩家:
		26: AA
		27: AB
		28: ThisNode
        29: ThisPoint
		30: SpeedToggle
}


规则("// copy and paste the following line into the game title:")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(装填)) == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		按钮被按下(事件玩家, 按钮(技能2)) == 假;
		按钮被按下(事件玩家, 按钮(跳跃)) == 假;
		按钮被按下(事件玩家, 按钮(互动)) == 假;
	}

	动作
	{
        事件玩家.ThisPoint = 1;
		While(事件玩家.ThisPoint > 0 && 事件玩家.ThisPoint <= 数量(全局.A));
			If(事件玩家.F[事件玩家.ThisPoint] != 真&& 全局.A[事件玩家.ThisPoint]!=0);
					传送(事件玩家, 最近的可行走位置(全局.A[事件玩家.ThisPoint]));
					事件玩家.ThisPoint = 数量(全局.P) + 1000;
			Else;
				事件玩家.ThisPoint = 事件玩家.ThisPoint + 1;
			End;
		End;
	}
}


规则("★ Find 58 items in Antarctica ★ (list in description)")
{
	事件
	{
		持续 - 全局;
	}
}

规则("// don't add spectators, they see all spoilers!")
{
	事件
	{
		持续 - 全局;
	}
}

规则("// \"Find Items\" ver. 1.1")
{
	事件
	{
		持续 - 全局;
	}
}

规则("// all maps and additional info: bit.do/finditems")
{
	事件
	{
		持续 - 全局;
	}
}

规则("// original mode is made by Foren#2660")
{
	事件
	{
		持续 - 全局;
	}
}

规则("beginning of the game")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		关闭游戏预设音乐模式;
		关闭游戏预设通告模式;
		关闭游戏预设完成条件;
		关闭游戏预设计分模式;
		全局.N = 1;
		全局.G = 0;
		全局.H = 矢量(0, -99, 0);
		全局.T = -1;
		全局.Q = 0;
		设置比赛时间(1);
		等待(2, 无视条件);
		设置比赛时间(3600);
		创建HUD文本(所有玩家(所有队伍), 无, 字符串("尝试"), 无, 顶部, 0, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
	}
}

规则("Antarctica ===================================================================")
{
	事件
	{
		持续 - 全局;
	}
}

规则("3 ping pong rackets")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.G += 1;
		全局.I = 0;
		全局.A[全局.N] = 矢量(15.396, 8.946, -45.114);
		全局.X[全局.N] = 全局.G;
		全局.I += 1;
		全局.N += 1;
		全局.A[全局.N] = 矢量(13.391, 9.082, 54.774);
		全局.X[全局.N] = 全局.G;
		全局.I += 1;
		全局.N += 1;
		全局.A[全局.N] = 矢量(11.570, 9.082, 56.204);
		全局.X[全局.N] = 全局.G;
		全局.I += 1;
		全局.N += 1;
		全局.C[全局.G] = 全局.I;
	}
}

规则("27 items with Overwatch symbol (no need to jump)")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.G += 1;
		全局.I = 0;
		全局.A[全局.N] = 矢量(8.715, 8.301, -60.382);
		全局.X[全局.N] = 全局.G;
		全局.I += 1;
		全局.N += 1;
		全局.A[全局.N] = 矢量(7.424, 9.207, 24.040);
		全局.X[全局.N] = 全局.G;
		全局.I += 1;
		全局.N += 1;
		全局.A[全局.N] = 矢量(-0.136, 9.773, 22.470);
		全局.X[全局.N] = 全局.G;
		全局.I += 1;
		全局.N += 1;
		全局.A[全局.N] = 矢量(9.674, 9.406, 61.418);
		全局.X[全局.N] = 全局.G;
		全局.I += 1;
		全局.N += 1;
		全局.A[全局.N] = 矢量(-27.694, 9.272, -2.760);
		全局.X[全局.N] = 全局.G;
		全局.I += 1;
		全局.N += 1;
		全局.A[全局.N] = 矢量(-13.091, 7.312, -43.660);
		全局.X[全局.N] = 全局.G;
		全局.I += 1;
		全局.N += 1;
		全局.A[全局.N] = 矢量(-0.011, 8.414, -22.476);
		全局.X[全局.N] = 全局.G;
		全局.I += 1;
		全局.N += 1;
		全局.A[全局.N] = 矢量(20.782, 9.614, 57.977);
		全局.X[全局.N] = 全局.G;
		全局.I += 1;
		全局.N += 1;
		全局.A[全局.N] = 矢量(20.787, 9.611, 57.759);
		全局.X[全局.N] = 全局.G;
		全局.I += 1;
		全局.N += 1;
		全局.A[全局.N] = 矢量(20.710, 9.623, 57.517);
		全局.X[全局.N] = 全局.G;
		全局.I += 1;
		全局.N += 1;
		全局.A[全局.N] = 矢量(20.562, 9.620, 58.016);
		全局.X[全局.N] = 全局.G;
		全局.I += 1;
		全局.N += 1;
		全局.A[全局.N] = 矢量(20.537, 9.617, 57.833);
		全局.X[全局.N] = 全局.G;
		全局.I += 1;
		全局.N += 1;
		全局.A[全局.N] = 矢量(20.427, 9.606, 57.563);
		全局.X[全局.N] = 全局.G;
		全局.I += 1;
		全局.N += 1;
		全局.A[全局.N] = 矢量(8.640, 8.974, 59.841);
		全局.X[全局.N] = 全局.G;
		全局.I += 1;
		全局.N += 1;
		全局.A[全局.N] = 矢量(28.366, 3.657, -5.258);
		全局.X[全局.N] = 全局.G;
		全局.I += 1;
		全局.N += 1;
		全局.A[全局.N] = 矢量(7.480, 9.057, -58.184);
		全局.X[全局.N] = 全局.G;
		全局.I += 1;
		全局.N += 1;
		全局.A[全局.N] = 矢量(-4.877, 8.908, -35.835);
		全局.X[全局.N] = 全局.G;
		全局.I += 1;
		全局.N += 1;
		全局.A[全局.N] = 矢量(-2.690, 8.928, -33.629);
		全局.X[全局.N] = 全局.G;
		全局.I += 1;
		全局.N += 1;
		全局.A[全局.N] = 矢量(-7.417, 8.650, -2.209);
		全局.X[全局.N] = 全局.G;
		全局.I += 1;
		全局.N += 1;
		全局.A[全局.N] = 矢量(-7.233, 8.673, 1.099);
		全局.X[全局.N] = 全局.G;
		全局.I += 1;
		全局.N += 1;
		全局.A[全局.N] = 矢量(-6.031, 8.920, 30.195);
		全局.X[全局.N] = 全局.G;
		全局.I += 1;
		全局.N += 1;
		全局.A[全局.N] = 矢量(-8.267, 8.958, 32.432);
		全局.X[全局.N] = 全局.G;
		全局.I += 1;
		全局.N += 1;
		全局.A[全局.N] = 矢量(-0.299, 7.382, 0.132);
		全局.X[全局.N] = 全局.G;
		全局.I += 1;
		全局.N += 1;
		全局.A[全局.N] = 矢量(-8.203, 13.620, 7.985);
		全局.X[全局.N] = 全局.G;
		全局.I += 1;
		全局.N += 1;
		全局.A[全局.N] = 矢量(-8.204, 13.617, -7.940);
		全局.X[全局.N] = 全局.G;
		全局.I += 1;
		全局.N += 1;
		全局.A[全局.N] = 矢量(3.873, 11.652, -29.904);
		全局.X[全局.N] = 全局.G;
		全局.I += 1;
		全局.N += 1;
		全局.A[全局.N] = 矢量(5.722, 8.709, 47.191);
		全局.X[全局.N] = 全局.G;
		全局.I += 1;
		全局.N += 1;
		全局.C[全局.G] = 全局.I;
	}
}

规则("8 Yetis")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.G += 1;
		全局.I = 0;
		全局.A[全局.N] = 矢量(8.128, 8.225, -59.624);
		全局.X[全局.N] = 全局.G;
		全局.I += 1;
		全局.N += 1;
		全局.A[全局.N] = 矢量(7.972, 8.729, -59.772);
		全局.X[全局.N] = 全局.G;
		全局.I += 1;
		全局.N += 1;
		全局.A[全局.N] = 矢量(14.133, 10.148, -41.922);
		全局.X[全局.N] = 全局.G;
		全局.I += 1;
		全局.N += 1;
		全局.A[全局.N] = 矢量(13.076, 9.540, -42.228);
		全局.X[全局.N] = 全局.G;
		全局.I += 1;
		全局.N += 1;
		全局.A[全局.N] = 矢量(27.039, 3.253, 5.527);
		全局.X[全局.N] = 全局.G;
		全局.I += 1;
		全局.N += 1;
		全局.A[全局.N] = 矢量(27.105, 3.252, 5.339);
		全局.X[全局.N] = 全局.G;
		全局.I += 1;
		全局.N += 1;
		全局.A[全局.N] = 矢量(6.841, 8.129, 23.172);
		全局.X[全局.N] = 全局.G;
		全局.I += 1;
		全局.N += 1;
		全局.A[全局.N] = 矢量(6.869, 7.644, 23.275);
		全局.X[全局.N] = 全局.G;
		全局.I += 1;
		全局.N += 1;
		全局.C[全局.G] = 全局.I;
	}
}

规则("2 self-portraits")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.G += 1;
		全局.I = 0;
		全局.A[全局.N] = 矢量(18.012, 9.568, 58.558);
		全局.X[全局.N] = 全局.G;
		全局.I += 1;
		全局.N += 1;
		全局.A[全局.N] = 矢量(21.142, 3.988, 0.641);
		全局.X[全局.N] = 全局.G;
		全局.I += 1;
		全局.N += 1;
		全局.C[全局.G] = 全局.I;
	}
}

规则("11 yellow gas cylinders")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.G += 1;
		全局.I = 0;
		全局.A[全局.N] = 矢量(-18.677, 7.606, 9.440);
		全局.X[全局.N] = 全局.G;
		全局.I += 1;
		全局.N += 1;
		全局.A[全局.N] = 矢量(-18.593, 7.512, 9.030);
		全局.X[全局.N] = 全局.G;
		全局.I += 1;
		全局.N += 1;
		全局.A[全局.N] = 矢量(-20.455, 12.581, 9.396);
		全局.X[全局.N] = 全局.G;
		全局.I += 1;
		全局.N += 1;
		全局.A[全局.N] = 矢量(-20.455, 12.567, 9.046);
		全局.X[全局.N] = 全局.G;
		全局.I += 1;
		全局.N += 1;
		全局.A[全局.N] = 矢量(2.534, 12.290, 21.315);
		全局.X[全局.N] = 全局.G;
		全局.I += 1;
		全局.N += 1;
		全局.A[全局.N] = 矢量(2.563, 12.281, -21.265);
		全局.X[全局.N] = 全局.G;
		全局.I += 1;
		全局.N += 1;
		全局.A[全局.N] = 矢量(-11.519, 7.884, -48.975);
		全局.X[全局.N] = 全局.G;
		全局.I += 1;
		全局.N += 1;
		全局.A[全局.N] = 矢量(23.629, 6.629, 19.202);
		全局.X[全局.N] = 全局.G;
		全局.I += 1;
		全局.N += 1;
		全局.A[全局.N] = 矢量(21.057, 3.725, 5.452);
		全局.X[全局.N] = 全局.G;
		全局.I += 1;
		全局.N += 1;
		全局.A[全局.N] = 矢量(21.355, 3.725, 5.513);
		全局.X[全局.N] = 全局.G;
		全局.I += 1;
		全局.N += 1;
		全局.A[全局.N] = 矢量(21.728, 3.725, 5.372);
		全局.X[全局.N] = 全局.G;
		全局.I += 1;
		全局.N += 1;
		全局.C[全局.G] = 全局.I;
	}
}

规则("7 single items: birthday cake / alien / king without a queen / Snowball / cute puppy / bookmark / fictional country flag")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.G += 1;
		全局.I = 0;
		全局.A[全局.N] = 矢量(-13.895, 8.544, 43.804);
		全局.X[全局.N] = 全局.G;
		全局.I += 1;
		全局.N += 1;
		全局.A[全局.N] = 矢量(13.803, 9.092, -54.608);
		全局.X[全局.N] = 全局.G;
		全局.I += 1;
		全局.N += 1;
		全局.A[全局.N] = 矢量(15.533, 9.232, 43.711);
		全局.X[全局.N] = 全局.G;
		全局.I += 1;
		全局.N += 1;
		全局.A[全局.N] = 矢量(30.350, 3.550, -3.655);
		全局.X[全局.N] = 全局.G;
		全局.I += 1;
		全局.N += 1;
		全局.A[全局.N] = 矢量(32.338, 4.729, -1.185);
		全局.X[全局.N] = 全局.G;
		全局.I += 1;
		全局.N += 1;
		全局.A[全局.N] = 矢量(-21.602, 8.269, -0.569);
		全局.X[全局.N] = 全局.G;
		全局.I += 1;
		全局.N += 1;
		全局.A[全局.N] = 矢量(-21.178, 7.971, -0.337);
		全局.X[全局.N] = 全局.G;
		全局.I += 1;
		全局.N += 1;
		全局.C[全局.G] = 全局.I;
	}
}

规则("I=============================================================================")
{
	事件
	{
		持续 - 全局;
	}
}

规则("calculating total number of items")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.O == 无;
	}

	动作
	{
		全局.O = 全局.N - 1;
	}
}

规则("player found item")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(互动)) == 真;
		具有状态(事件玩家, 冰冻) == 假;
		事件玩家.Z == 无;
	}

	动作
	{
		根据条件跳过(事件玩家.L != 无, 1);
		事件玩家.L = 1;
		根据条件跳过(全局.A[事件玩家.L] == 无, 18);
		根据条件跳过(事件玩家.F[事件玩家.L] == 真, 17);
		根据条件跳过(相距距离(事件玩家, 全局.A[事件玩家.L]) > 2.500, 16);
		事件玩家.O = 全局.X[事件玩家.L];
		事件玩家.Z = 全局.A[事件玩家.L];
		在索引处修改全局变量(D, 事件玩家.L, 添加至数组, 事件玩家);
		事件玩家.K = 全局.A[事件玩家.L];
		事件玩家.Q += 1;
		事件玩家.F[事件玩家.L] = 真;
		事件玩家.G[全局.X[事件玩家.L]] += 1;
		事件玩家.M = 事件玩家.L;
		根据条件跳过(事件玩家.Q == 全局.O, 1);
		小字体信息(事件玩家, 字符串("{0} / {1}", 事件玩家.G[全局.X[事件玩家.M]], 全局.C[全局.X[事件玩家.M]]));
		根据条件跳过(事件玩家.G[事件玩家.O] < 全局.C[事件玩家.O], 4);
		事件玩家.A = 全局.X[事件玩家.L];
		播放效果(事件玩家, 环状爆炸, 颜色(亮紫色), 事件玩家.Z, 7);
		播放效果(事件玩家, 正面状态施加声音, 颜色(白色), 事件玩家, 30);
		播放效果(事件玩家, 有益选择效果 , 颜色(亮紫色), 事件玩家.Z, 1);
		事件玩家.L = 999;
		事件玩家.L += 1;
		根据条件跳过(事件玩家.L >= 全局.O - 4, 8);
		根据条件跳过(相距距离(事件玩家, 全局.A[事件玩家.L]) <= 3, 1);
		事件玩家.L += 1;
		根据条件跳过(相距距离(事件玩家, 全局.A[事件玩家.L]) <= 3, 1);
		事件玩家.L += 1;
		根据条件跳过(相距距离(事件玩家, 全局.A[事件玩家.L]) <= 3, 1);
		事件玩家.L += 1;
		根据条件跳过(相距距离(事件玩家, 全局.A[事件玩家.L]) <= 3, 1);
		事件玩家.L += 1;
		等待(0.001, 无视条件);
		根据条件跳过(事件玩家.L != 全局.O + 1, 1);
		事件玩家.J = 真;
		根据条件循环(事件玩家.L <= 全局.O);
		事件玩家.L = 1;
	}
}

规则("playing yellow effects")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.Z != 无;
	}

	动作
	{
		播放效果(事件玩家, 环状爆炸, 颜色(黄色), 事件玩家.Z, 3);
		播放效果(事件玩家, 状态爆炸声音, 颜色(黄色), 事件玩家, 20);
		等待(0.250, 无视条件);
		事件玩家.Z = 无;
		根据条件跳过(事件玩家.Q < 全局.O, 4);
		消除HUD文本(事件玩家.W[1]);
		创建HUD文本(所有玩家(所有队伍), 无, 无, 字符串("{0} {1} {2}", 字符串("{0} {1}", 英雄图标字符串(所用英雄(事件玩家)), 事件玩家), 自定义字符串("已找到"), 字符串("{0} / {1}", 事件玩家.Q,
			全局.O)), 右边, 60 - 事件玩家.Q, 颜色(白色), 颜色(白色), 颜色(绿色), 可见和字符串, 默认可见度);
		事件玩家.W[1] = 上一个文本ID;
		中止;
		消除HUD文本(事件玩家.W[1]);
		创建HUD文本(所有玩家(所有队伍), 无, 无, 字符串("{0} {1} {2}", 字符串("{0} {1}", 英雄图标字符串(所用英雄(事件玩家)), 事件玩家), 自定义字符串("已找到"), 字符串("{0} / {1}", 事件玩家.Q,
			全局.O)), 右边, 60 - 事件玩家.Q, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		事件玩家.W[1] = 上一个文本ID;
	}
}

规则("player spawn")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
	}

	动作
	{
		事件玩家.Q = 0;
		修改全局变量(S, 添加至数组, 事件玩家);
		创建HUD文本(所有玩家(所有队伍), 无, 无, 字符串("{0} {1} {2}", 字符串("{0} {1}", 英雄图标字符串(所用英雄(事件玩家)), 事件玩家), 自定义字符串("已找到"), 字符串("{0} / {1}", 事件玩家.Q,
			全局.O)), 右边, 60, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		事件玩家.W[1] = 上一个文本ID;
		事件玩家.J = 假;
		事件玩家.T = 0;
		事件玩家.S = 150;
		设置状态(事件玩家, 无, 无敌, 9999);
		创建效果(事件玩家, 火花, 颜色(黄色), 事件玩家.K, 2, 可见，位置和半径);
		全局.T = 0;
		全局.Q = 0;
		事件玩家.K = 矢量(0, -99, 0);
		等待(5, 无视条件);
		大字体信息(事件玩家, 字符串("{0} {1} {2}", 字符串("寻找"), 全局.O, 字符串("物品")));
		等待(3, 无视条件);
		小字体信息(事件玩家, 字符串("{0} - {1}", 字符串("技能1"), 字符串("运行")));
	}
}

规则("creating HUD text 1-5")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
	}

	动作
	{
		根据条件跳过(全局.G < 1, 2);
		创建HUD文本(事件玩家, 字符串("{0} {1}", 自定义字符串("乒乓球拍"), 字符串("{0} / {1}", 事件玩家.G[1], 全局.C[1]), 字符串("物品")), 无, 无, 左边, 1, 颜色(黄色), 颜色(白色), 颜色(白色),
			可见和字符串, 默认可见度);
		事件玩家.E[1] = 上一个文本ID;
		根据条件跳过(全局.G < 2, 2);
		创建HUD文本(事件玩家, 字符串("{0} {1}", 自定义字符串("守望先锋标志的物品（不用跳！不用跳！）"), 字符串("{0} / {1}", 事件玩家.G[2], 全局.C[2]), 字符串("物品")), 无, 无, 左边, 2, 颜色(黄色), 颜色(白色), 颜色(白色),
			可见和字符串, 默认可见度);
		事件玩家.E[2] = 上一个文本ID;
		根据条件跳过(全局.G < 3, 2);
		创建HUD文本(事件玩家, 字符串("{0} {1}", 自定义字符串("雪怪"), 字符串("{0} / {1}", 事件玩家.G[3], 全局.C[3]), 字符串("物品")), 无, 无, 左边, 3, 颜色(黄色), 颜色(白色), 颜色(白色),
			可见和字符串, 默认可见度);
		事件玩家.E[3] = 上一个文本ID;
		根据条件跳过(全局.G < 4, 2);
		创建HUD文本(事件玩家, 字符串("{0} {1}", 自定义字符串("自画像"), 字符串("{0} / {1}", 事件玩家.G[4], 全局.C[4]), 字符串("物品")), 无, 无, 左边, 4, 颜色(黄色), 颜色(白色), 颜色(白色),
			可见和字符串, 默认可见度);
		事件玩家.E[4] = 上一个文本ID;
		根据条件跳过(全局.G < 5, 2);
		创建HUD文本(事件玩家, 字符串("{0} {1}", 自定义字符串("黄色气瓶"), 字符串("{0} / {1}", 事件玩家.G[5], 全局.C[5]), 字符串("物品")), 无, 无, 左边, 5, 颜色(黄色), 颜色(白色), 颜色(白色),
			可见和字符串, 默认可见度);
		事件玩家.E[5] = 上一个文本ID;
	}
}

规则("creating HUD text 6-10")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
	}

	动作
	{
		根据条件跳过(全局.G < 6, 2);
		创建HUD文本(事件玩家, 字符串("{0} {1}", 自定义字符串("7个单品：生日 蛋糕\r\n外星人\r\n没有女王的国王\r\n雪球\r\n可爱的小狗\r\n书签\r\n虚构的国旗"), 字符串("{0} / {1}", 事件玩家.G[6], 全局.C[6]), 字符串("物品")), 无, 无, 左边, 6, 颜色(黄色), 颜色(白色), 颜色(白色),
			可见和字符串, 默认可见度);
		事件玩家.E[6] = 上一个文本ID;
		根据条件跳过(全局.G < 7, 2);
		创建HUD文本(事件玩家, 字符串("{0} {1}", 自定义字符串("已找到"), 字符串("{0} / {1}", 事件玩家.G[7], 全局.C[7]), 字符串("物品")), 无, 无, 左边, 7, 颜色(黄色), 颜色(白色), 颜色(白色),
			可见和字符串, 默认可见度);
		事件玩家.E[7] = 上一个文本ID;
		根据条件跳过(全局.G < 8, 2);
		创建HUD文本(事件玩家, 字符串("{0} {1}", 自定义字符串("已找到"), 字符串("{0} / {1}", 事件玩家.G[8], 全局.C[8]), 字符串("物品")), 无, 无, 左边, 8, 颜色(黄色), 颜色(白色), 颜色(白色),
			可见和字符串, 默认可见度);
		事件玩家.E[8] = 上一个文本ID;
		根据条件跳过(全局.G < 9, 2);
		创建HUD文本(事件玩家, 字符串("{0} {1}", 自定义字符串("已找到"), 字符串("{0} / {1}", 事件玩家.G[9], 全局.C[9]), 字符串("物品")), 无, 无, 左边, 9, 颜色(黄色), 颜色(白色), 颜色(白色),
			可见和字符串, 默认可见度);
		事件玩家.E[9] = 上一个文本ID;
		根据条件跳过(全局.G < 10, 2);
		创建HUD文本(事件玩家, 字符串("{0} {1}", 自定义字符串("已找到"), 字符串("{0} / {1}", 事件玩家.G[10], 全局.C[10]), 字符串("物品")), 无, 无, 左边, 10, 颜色(黄色), 颜色(白色), 颜色(白色),
			可见和字符串, 默认可见度);
		事件玩家.E[10] = 上一个文本ID;
		事件玩家.A = 0;
	}
}

规则("all items found (victory!)")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.Q == 全局.O;
		已重生(事件玩家) == 真;
	}

	动作
	{
		大字体信息(所有玩家(所有队伍), 字符串("{0} {1} {2}", 英雄图标字符串(所用英雄(事件玩家)), 事件玩家, 字符串("{0}！", 字符串("胜者"))));
		播放效果(事件玩家, 环状爆炸声音, 颜色(白色), 事件玩家, 20);
		播放效果(事件玩家, 有益爆炸, 颜色(黄色), 事件玩家, 10);
		播放效果(事件玩家, 环状爆炸, 颜色(亮紫色), 事件玩家, 20);
		全局.H = 事件玩家;
		交流(事件玩家, 表情（上）);
		设置慢动作(30);
		等待(1.250, 无视条件);
		设置慢动作(100);
		等待(3, 无视条件);
		小字体信息(事件玩家, 字符串("{0} {1}", 事件玩家, 字符串("{0}！", 字符串("可见"))));
	}
}

规则("player pressed \"F\" key on the empty place")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.J == 真;
		具有状态(事件玩家, 冰冻) == 假;
		事件玩家.Q != 全局.O;
	}

	动作
	{
		根据条件跳过(事件玩家.T > 4.500, 1);
		事件玩家.T += 0.500;
		播放效果(事件玩家, 负面状态施加声音, 颜色(白色), 事件玩家, 50);
		设置状态(事件玩家, 无, 冰冻, 事件玩家.T);
		事件玩家.R = 事件玩家.T;
		大字体信息(事件玩家, 字符串("{0} {1}", 字符串("否"), 字符串("物品")));
		小字体信息(事件玩家, 字符串("{0} {1}", 字符串("下一次尝试"), 字符串("{0}秒", 取整(事件玩家.R, 上))));
		等待(事件玩家.T, 无视条件);
		事件玩家.J = 假;
		修改玩家分数(事件玩家, -1);
	}
}

规则("player is frozen")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.J == 真;
	}

	动作
	{
		等待(1, 无视条件);
		事件玩家.R -= 1;
	}
}

规则("create all 60 effects at the beginning of the match")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		创建效果(所有玩家(所有队伍), 火花, 颜色(黄色), 全局.H, 2, 可见，位置和半径);
		创建效果(所有玩家(所有队伍), 火花, 颜色(亮紫色), 全局.H, 2, 可见，位置和半径);
		创建效果(全局.D[1], 有益光环, 颜色(黄色), 全局.A[1], 0.500, 可见);
		创建效果(全局.D[2], 有益光环, 颜色(黄色), 全局.A[2], 0.500, 可见);
		创建效果(全局.D[3], 有益光环, 颜色(黄色), 全局.A[3], 0.500, 可见);
		创建效果(全局.D[4], 有益光环, 颜色(黄色), 全局.A[4], 0.500, 可见);
		创建效果(全局.D[5], 有益光环, 颜色(黄色), 全局.A[5], 0.500, 可见);
		创建效果(全局.D[6], 有益光环, 颜色(黄色), 全局.A[6], 0.500, 可见);
		创建效果(全局.D[7], 有益光环, 颜色(黄色), 全局.A[7], 0.500, 可见);
		创建效果(全局.D[8], 有益光环, 颜色(黄色), 全局.A[8], 0.500, 可见);
		创建效果(全局.D[9], 有益光环, 颜色(黄色), 全局.A[9], 0.500, 可见);
		创建效果(全局.D[10], 有益光环, 颜色(黄色), 全局.A[10], 0.500, 可见);
		创建效果(全局.D[11], 有益光环, 颜色(黄色), 全局.A[11], 0.500, 可见);
		创建效果(全局.D[12], 有益光环, 颜色(黄色), 全局.A[12], 0.500, 可见);
		创建效果(全局.D[13], 有益光环, 颜色(黄色), 全局.A[13], 0.500, 可见);
		创建效果(全局.D[14], 有益光环, 颜色(黄色), 全局.A[14], 0.500, 可见);
		创建效果(全局.D[15], 有益光环, 颜色(黄色), 全局.A[15], 0.500, 可见);
		创建效果(全局.D[16], 有益光环, 颜色(黄色), 全局.A[16], 0.500, 可见);
		创建效果(全局.D[17], 有益光环, 颜色(黄色), 全局.A[17], 0.500, 可见);
		创建效果(全局.D[18], 有益光环, 颜色(黄色), 全局.A[18], 0.500, 可见);
		创建效果(全局.D[19], 有益光环, 颜色(黄色), 全局.A[19], 0.500, 可见);
		创建效果(全局.D[20], 有益光环, 颜色(黄色), 全局.A[20], 0.500, 可见);
		创建效果(全局.D[21], 有益光环, 颜色(黄色), 全局.A[21], 0.500, 可见);
		创建效果(全局.D[22], 有益光环, 颜色(黄色), 全局.A[22], 0.500, 可见);
		创建效果(全局.D[23], 有益光环, 颜色(黄色), 全局.A[23], 0.500, 可见);
		创建效果(全局.D[24], 有益光环, 颜色(黄色), 全局.A[24], 0.500, 可见);
		创建效果(全局.D[25], 有益光环, 颜色(黄色), 全局.A[25], 0.500, 可见);
		创建效果(全局.D[26], 有益光环, 颜色(黄色), 全局.A[26], 0.500, 可见);
		创建效果(全局.D[27], 有益光环, 颜色(黄色), 全局.A[27], 0.500, 可见);
		创建效果(全局.D[28], 有益光环, 颜色(黄色), 全局.A[28], 0.500, 可见);
		创建效果(全局.D[29], 有益光环, 颜色(黄色), 全局.A[29], 0.500, 可见);
		创建效果(全局.D[30], 有益光环, 颜色(黄色), 全局.A[30], 0.500, 可见);
		创建效果(全局.D[31], 有益光环, 颜色(黄色), 全局.A[31], 0.500, 可见);
		创建效果(全局.D[32], 有益光环, 颜色(黄色), 全局.A[32], 0.500, 可见);
		创建效果(全局.D[33], 有益光环, 颜色(黄色), 全局.A[33], 0.500, 可见);
		创建效果(全局.D[34], 有益光环, 颜色(黄色), 全局.A[34], 0.500, 可见);
		创建效果(全局.D[35], 有益光环, 颜色(黄色), 全局.A[35], 0.500, 可见);
		创建效果(全局.D[36], 有益光环, 颜色(黄色), 全局.A[36], 0.500, 可见);
		创建效果(全局.D[37], 有益光环, 颜色(黄色), 全局.A[37], 0.500, 可见);
		创建效果(全局.D[38], 有益光环, 颜色(黄色), 全局.A[38], 0.500, 可见);
		创建效果(全局.D[39], 有益光环, 颜色(黄色), 全局.A[39], 0.500, 可见);
		创建效果(全局.D[40], 有益光环, 颜色(黄色), 全局.A[40], 0.500, 可见);
		创建效果(全局.D[41], 有益光环, 颜色(黄色), 全局.A[41], 0.500, 可见);
		创建效果(全局.D[42], 有益光环, 颜色(黄色), 全局.A[42], 0.500, 可见);
		创建效果(全局.D[43], 有益光环, 颜色(黄色), 全局.A[43], 0.500, 可见);
		创建效果(全局.D[44], 有益光环, 颜色(黄色), 全局.A[44], 0.500, 可见);
		创建效果(全局.D[45], 有益光环, 颜色(黄色), 全局.A[45], 0.500, 可见);
		创建效果(全局.D[46], 有益光环, 颜色(黄色), 全局.A[46], 0.500, 可见);
		创建效果(全局.D[47], 有益光环, 颜色(黄色), 全局.A[47], 0.500, 可见);
		创建效果(全局.D[48], 有益光环, 颜色(黄色), 全局.A[48], 0.500, 可见);
		创建效果(全局.D[49], 有益光环, 颜色(黄色), 全局.A[49], 0.500, 可见);
		创建效果(全局.D[50], 有益光环, 颜色(黄色), 全局.A[50], 0.500, 可见);
		创建效果(全局.D[51], 有益光环, 颜色(黄色), 全局.A[51], 0.500, 可见);
		创建效果(全局.D[52], 有益光环, 颜色(黄色), 全局.A[52], 0.500, 可见);
		创建效果(全局.D[53], 有益光环, 颜色(黄色), 全局.A[53], 0.500, 可见);
		创建效果(全局.D[54], 有益光环, 颜色(黄色), 全局.A[54], 0.500, 可见);
		创建效果(全局.D[55], 有益光环, 颜色(黄色), 全局.A[55], 0.500, 可见);
		创建效果(全局.D[56], 有益光环, 颜色(黄色), 全局.A[56], 0.500, 可见);
		创建效果(全局.D[57], 有益光环, 颜色(黄色), 全局.A[57], 0.500, 可见);
		创建效果(全局.D[58], 有益光环, 颜色(黄色), 全局.A[58], 0.500, 可见);
		创建效果(全局.D[59], 有益光环, 颜色(黄色), 全局.A[59], 0.500, 可见);
		创建效果(全局.D[60], 有益光环, 颜色(黄色), 全局.A[60], 0.500, 可见);
	}
}

规则("shift key is pressed (acceleration)")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(技能1)) == 真;
	}

	动作
	{
		设置移动速度(事件玩家, 事件玩家.S);
	}
}

规则("shift key is not pressed (slowdown)")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(技能1)) == 假;
	}

	动作
	{
		设置移动速度(事件玩家, 110);
	}
}

禁用 规则("teleport cooldown")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.B == 真;
	}

	动作
	{
		等待(2, 无视条件);
		事件玩家.B = 假;
		如条件为”真“则循环;
	}
}

规则("acceleration after finding a group of items")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.A > 0;
		事件玩家.S <= 300;
		全局.G > 0;
		事件玩家.Q < 全局.O;
	}

	动作
	{
		事件玩家.S += 180 / 全局.G;
		等待(1, 无视条件);
		大字体信息(事件玩家, 字符串("{0} {1}", 字符串("速度"), 字符串("升级")));
		等待(2, 无视条件);
		小字体信息(事件玩家, 字符串("{0} - {1}", 字符串("技能1"), 字符串("运行")));
	}
}

规则("player found the last item in the group 1-5")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.A > 0;
		事件玩家.A <= 5;
	}

	动作
	{
		事件玩家.N = 1;
		根据条件跳过(事件玩家.A != 事件玩家.N, 2);
		消除HUD文本(事件玩家.E[事件玩家.N]);
		创建HUD文本(事件玩家, 字符串("{0} {1}", 自定义字符串("已找到"), 字符串("{0} / {1}", 全局.C[1], 全局.C[1]), 字符串("物品")), 无, 无, 左边, 1, 颜色(绿色), 颜色(白色), 颜色(白色),
			可见和字符串, 默认可见度);
		事件玩家.N = 2;
		根据条件跳过(事件玩家.A != 事件玩家.N, 2);
		消除HUD文本(事件玩家.E[事件玩家.N]);
		创建HUD文本(事件玩家, 字符串("{0} {1}", 自定义字符串("已找到"), 字符串("{0} / {1}", 全局.C[2], 全局.C[2]), 字符串("物品")), 无, 无, 左边, 2, 颜色(绿色), 颜色(白色), 颜色(白色),
			可见和字符串, 默认可见度);
		事件玩家.N = 3;
		根据条件跳过(事件玩家.A != 事件玩家.N, 2);
		消除HUD文本(事件玩家.E[事件玩家.N]);
		创建HUD文本(事件玩家, 字符串("{0} {1}", 自定义字符串("已找到"), 字符串("{0} / {1}", 全局.C[3], 全局.C[3]), 字符串("物品")), 无, 无, 左边, 3, 颜色(绿色), 颜色(白色), 颜色(白色),
			可见和字符串, 默认可见度);
		事件玩家.N = 4;
		根据条件跳过(事件玩家.A != 事件玩家.N, 2);
		消除HUD文本(事件玩家.E[事件玩家.N]);
		创建HUD文本(事件玩家, 字符串("{0} {1}", 自定义字符串("已找到"), 字符串("{0} / {1}", 全局.C[4], 全局.C[4]), 字符串("物品")), 无, 无, 左边, 4, 颜色(绿色), 颜色(白色), 颜色(白色),
			可见和字符串, 默认可见度);
		事件玩家.N = 5;
		根据条件跳过(事件玩家.A != 事件玩家.N, 2);
		消除HUD文本(事件玩家.E[事件玩家.N]);
		创建HUD文本(事件玩家, 字符串("{0} {1}", 自定义字符串("已找到"), 字符串("{0} / {1}", 全局.C[5], 全局.C[5]), 字符串("物品")), 无, 无, 左边, 5, 颜色(绿色), 颜色(白色), 颜色(白色),
			可见和字符串, 默认可见度);
		事件玩家.A = 0;
	}
}

规则("player found the last item in the group 6-10")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.A > 5;
		事件玩家.A <= 10;
	}

	动作
	{
		事件玩家.N = 6;
		根据条件跳过(事件玩家.A != 事件玩家.N, 2);
		消除HUD文本(事件玩家.E[事件玩家.N]);
		创建HUD文本(事件玩家, 字符串("{0} {1}", 自定义字符串("已找到"), 字符串("{0} / {1}", 全局.C[6], 全局.C[6]), 字符串("物品")), 无, 无, 左边, 6, 颜色(绿色), 颜色(白色), 颜色(白色),
			可见和字符串, 默认可见度);
		事件玩家.N = 7;
		根据条件跳过(事件玩家.A != 事件玩家.N, 2);
		消除HUD文本(事件玩家.E[事件玩家.N]);
		创建HUD文本(事件玩家, 字符串("{0} {1}", 自定义字符串("已找到"), 字符串("{0} / {1}", 全局.C[7], 全局.C[7]), 字符串("物品")), 无, 无, 左边, 7, 颜色(绿色), 颜色(白色), 颜色(白色),
			可见和字符串, 默认可见度);
		事件玩家.N = 8;
		根据条件跳过(事件玩家.A != 事件玩家.N, 2);
		消除HUD文本(事件玩家.E[事件玩家.N]);
		创建HUD文本(事件玩家, 字符串("{0} {1}", 自定义字符串("已找到"), 字符串("{0} / {1}", 全局.C[8], 全局.C[8]), 字符串("物品")), 无, 无, 左边, 8, 颜色(绿色), 颜色(白色), 颜色(白色),
			可见和字符串, 默认可见度);
		事件玩家.N = 9;
		根据条件跳过(事件玩家.A != 事件玩家.N, 2);
		消除HUD文本(事件玩家.E[事件玩家.N]);
		创建HUD文本(事件玩家, 字符串("{0} {1}", 自定义字符串("已找到"), 字符串("{0} / {1}", 全局.C[9], 全局.C[9]), 字符串("物品")), 无, 无, 左边, 9, 颜色(绿色), 颜色(白色), 颜色(白色),
			可见和字符串, 默认可见度);
		事件玩家.N = 10;
		根据条件跳过(事件玩家.A != 事件玩家.N, 2);
		消除HUD文本(事件玩家.E[事件玩家.N]);
		创建HUD文本(事件玩家, 字符串("{0} {1}", 自定义字符串("已找到"), 字符串("{0} / {1}", 全局.C[10], 全局.C[10]), 字符串("物品")), 无, 无, 左边, 10, 颜色(绿色), 颜色(白色), 颜色(白色),
			可见和字符串, 默认可见度);
		事件玩家.A = 0;
	}
}

规则("infinite match time")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		比赛时间 <= 1800;
		比赛时间 > 10;
	}

	动作
	{
		设置比赛时间(3600);
	}
}

规则("updating data after a player leaves the game")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.T == 0;
	}

	动作
	{
		全局.R = 全局.S[全局.T];
		根据条件跳过(全局.R == 无, 7);
		根据条件跳过(已重生(全局.R), 6);
		全局.Q += 1;
		在索引处修改全局变量(D, 全局.Q, 根据值从数组中移除, 全局.R);
		等待(0.025, 无视条件);
		根据条件跳过(全局.Q < 60, 1);
		修改全局变量(S, 根据值从数组中移除, 全局.R);
		根据条件循环(全局.Q < 60);
		全局.T += 1;
		全局.Q = 0;
		等待(0.025, 无视条件);
		根据条件循环(全局.T < 12);
	}
}


规则("SpeedToggle")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(终极技能)) == 真;
	}

	动作
	{
		If(事件玩家.SpeedToggle != 真);
			设置移动速度(事件玩家, 事件玩家.S);
			事件玩家.SpeedToggle = 真;
		Else;
			设置移动速度(事件玩家, 110);
			事件玩家.SpeedToggle = 假;
		End;
	}
}

规则("SpeedToggleReset")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(技能1)) == 假;
	}

	动作
	{
		事件玩家.SpeedToggle = 假;
	}
}


规则("顶部描述")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		While(真);
			设置目标点描述(所有玩家(所有队伍), 自定义字符串("互动键(默认V)=确认物品\r\nSHIFT=长按加速\r\n终极技能=切换加速\r\n下蹲键=进出传送门"), 可见和字符串);
			等待(5, 无视条件);
			设置目标点描述(所有玩家(所有队伍), 自定义字符串("左上角需找物品\r\n需设置模型细节：高以上\r\n同好群：1074896927"),
				可见和字符串);
			等待(5, 无视条件);
		End;
	}
}

规则("传送操作--通用")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 假;
		按钮被按下(事件玩家, 按钮(装填)) == 假;
		按钮被按下(事件玩家, 按钮(技能2)) == 假;
		按钮被按下(事件玩家, 按钮(终极技能)) == 假;
	}

	动作
	{
		事件玩家.ThisNode = 1;
		While(事件玩家.ThisNode > 0 && 事件玩家.ThisNode <= 数量(全局.P));
			If(全局.P[事件玩家.ThisNode] != 0 && 相距距离(所选位置(事件玩家), 全局.P[事件玩家.ThisNode]) <= 2);
				If(事件玩家.ThisNode % 2 == 1);
					传送(事件玩家, 全局.P[事件玩家.ThisNode + 1]);
					事件玩家.ThisNode = 数量(全局.P) + 100;
				Else If(事件玩家.ThisNode % 2 == 0);
					传送(事件玩家, 全局.P[事件玩家.ThisNode - 1]);
					事件玩家.ThisNode = 数量(全局.P) + 100;
				End;
			Else;
				事件玩家.ThisNode = 事件玩家.ThisNode + 1;
			End;
        End;
	}
}

规则("bug protection")
{
	事件
	{
		玩家离开比赛;
		双方;
		全部;
	}

	动作
	{
		设置慢动作(100);
	}
}