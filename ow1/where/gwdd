变量
{
	全局:
		26: AA

	玩家:
		26: AA
}

规则("// copy and paste the following line into the game title: *")
{
	事件
	{
		持续 - 全局;
	}
}

规则("")
{
	事件
	{
		持续 - 全局;
	}
}

规则("// all maps and additional info: bit.do/whereisit")
{
	事件
	{
		持续 - 全局;
	}
}

规则("// \"WHERE IS IT?\" ver. 1.3")
{
	事件
	{
		持续 - 全局;
	}
}

规则("// original mode is made by Foren#2660")
{
	事件
	{
		持续 - 全局;
	}
}

规则("all objects *")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.N = 0;
		全局.N += 1;
		全局.C[全局.N] = 矢量(53.705, 10.304, -79.478);
		全局.D[全局.N] = 矢量(53.848, 10.227, -79.191);
		全局.N += 1;
		全局.C[全局.N] = 矢量(28.561, 10.716, -81.180);
		全局.D[全局.N] = 矢量(28.460, 10.503, -81.225);
		全局.N += 1;
		全局.C[全局.N] = 矢量(-47.300, 6.060, -74.472);
		全局.D[全局.N] = 矢量(-47.405, 6.063, -74.619);
		全局.N += 1;
		全局.C[全局.N] = 矢量(-29.954, 3.824, -135.346);
		全局.D[全局.N] = 矢量(-29.954, 3.434, -135.333);
		全局.N += 1;
		全局.C[全局.N] = 矢量(-89.756, 9.832, -179.918);
		全局.D[全局.N] = 矢量(-89.477, 10.100, -179.966);
		全局.N += 1;
		全局.C[全局.N] = 矢量(-98.949, 10.951, -80.616);
		全局.D[全局.N] = 矢量(-98.672, 10.418, -80.428);
		全局.N += 1;
		全局.C[全局.N] = 矢量(-69.277, 9.728, -105.669);
		全局.D[全局.N] = 矢量(-67.065, 9.673, -106.220);
		全局.N += 1;
		全局.C[全局.N] = 矢量(-47.223, 2.820, -138.670);
		全局.D[全局.N] = 矢量(-46.330, 2.115, -138.732);
		全局.N += 1;
		全局.C[全局.N] = 矢量(-36.718, 13.543, -59.639);
		全局.D[全局.N] = 矢量(-36.625, 13.841, -59.235);
		全局.N += 1;
		全局.C[全局.N] = 矢量(69.398, 11.773, -84.022);
		全局.D[全局.N] = 矢量(69.384, 11.443, -84.021);
		全局.N += 1;
		全局.C[全局.N] = 矢量(-21.141, 14.707, -103.757);
		全局.D[全局.N] = 矢量(-20.928, 14.901, -103.918);
		全局.N += 1;
		全局.C[全局.N] = 矢量(-37.917, 7.191, -86.619);
		全局.D[全局.N] = 矢量(-37.737, 7.190, -86.726);
		全局.N += 1;
		全局.C[全局.N] = 矢量(-58.311, 12.259, -68.281);
		全局.D[全局.N] = 矢量(-57.988, 12.431, -68.414);
		全局.N += 1;
		全局.C[全局.N] = 矢量(-89.830, 7.676, -102.906);
		全局.D[全局.N] = 矢量(-89.471, 7.571, -103.098);
		全局.N += 1;
		全局.C[全局.N] = 矢量(-10.791, 8.405, -105.572);
		全局.D[全局.N] = 矢量(-10.429, 8.328, -105.771);
		全局.N += 1;
		全局.C[全局.N] = 矢量(21.451, 10.844, -58.625);
		全局.D[全局.N] = 矢量(21.612, 10.985, -58.373);
		全局.N += 1;
		全局.C[全局.N] = 矢量(-27.763, 4.555, -73.175);
		全局.D[全局.N] = 矢量(-27.727, 4.581, -73.001);
		全局.N += 1;
		全局.C[全局.N] = 矢量(-32.036, 8.119, -94.991);
		全局.D[全局.N] = 矢量(-32.223, 7.860, -94.825);
		全局.N += 1;
		全局.C[全局.N] = 矢量(-90.774, 7.370, -142.241);
		全局.D[全局.N] = 矢量(-90.239, 6.772, -141.833);
		全局.N += 1;
		全局.C[全局.N] = 矢量(-53.264, 2.554, -129.092);
		全局.D[全局.N] = 矢量(-53.087, 2.296, -129.455);
		全局.N += 1;
		全局.C[全局.N] = 矢量(-57.806, 12.313, -62.986);
		全局.D[全局.N] = 矢量(-57.601, 12.323, -63.034);
		全局.N += 1;
		全局.C[全局.N] = 矢量(68.871, 11.389, -80.429);
		全局.D[全局.N] = 矢量(68.927, 11.381, -80.447);
		全局.N += 1;
		全局.C[全局.N] = 矢量(-78.781, 13.611, -146.539);
		全局.D[全局.N] = 矢量(-78.895, 13.603, -146.399);
		全局.N += 1;
		全局.C[全局.N] = 矢量(-43.824, 8.949, -108.471);
		全局.D[全局.N] = 矢量(-44.007, 8.914, -108.094);
		全局.N += 1;
		全局.C[全局.N] = 矢量(44.520, 11.214, -68.042);
		全局.D[全局.N] = 矢量(44.584, 10.905, -67.869);
		全局.N += 1;
		全局.C[全局.N] = 矢量(-19.433, 7.585, -89.147);
		全局.D[全局.N] = 矢量(-18.788, 7.908, -89.354);
		全局.N += 1;
		全局.C[全局.N] = 矢量(-77.582, 3.955, -132.140);
		全局.D[全局.N] = 矢量(-77.348, 3.675, -132.277);
		全局.N += 1;
		全局.C[全局.N] = 矢量(31.014, 12.016, -96.375);
		全局.D[全局.N] = 矢量(31.151, 11.534, -96.280);
		全局.N += 1;
		全局.C[全局.N] = 矢量(27.661, 15.823, -51.537);
		全局.D[全局.N] = 矢量(27.657, 12.675, -51.662);
		全局.N += 1;
		全局.C[全局.N] = 矢量(-71.990, 8.703, -164.044);
		全局.D[全局.N] = 矢量(-72.466, 9.092, -163.730);
		全局.N += 1;
		全局.C[全局.N] = 矢量(-90.185, 12.958, -111.518);
		全局.D[全局.N] = 矢量(-90.316, 13.648, -110.778);
		全局.N += 1;
		全局.C[全局.N] = 矢量(-59.281, 26.607, -109.738);
		全局.D[全局.N] = 矢量(-59.203, 26.693, -109.462);
		全局.N += 1;
		全局.C[全局.N] = 矢量(29.184, 11.917, -89.467);
		全局.D[全局.N] = 矢量(29.219, 11.928, -89.048);
		全局.N += 1;
		全局.C[全局.N] = 矢量(67.507, 15.934, -86.570);
		全局.D[全局.N] = 矢量(67.595, 14.227, -86.569);
		全局.N += 1;
		全局.C[全局.N] = 矢量(-112.320, 7.728, -111.530);
		全局.D[全局.N] = 矢量(-112.509, 7.509, -111.609);
		全局.N += 1;
		全局.C[全局.N] = 矢量(-31.097, 10.909, -89.330);
		全局.D[全局.N] = 矢量(-31.640, 11.158, -89.391);
		全局.N += 1;
		全局.C[全局.N] = 矢量(31.413, 10.962, -89.634);
		全局.D[全局.N] = 矢量(31.427, 10.880, -89.475);
		全局.N += 1;
		全局.C[全局.N] = 矢量(-57.509, 13.561, -93.375);
		全局.D[全局.N] = 矢量(-57.324, 13.396, -93.113);
		全局.N += 1;
		全局.C[全局.N] = 矢量(-62.823, 27.727, -123.971);
		全局.D[全局.N] = 矢量(-62.843, 28.953, -124.058);
		全局.N += 1;
		全局.C[全局.N] = 矢量(20.173, 11.124, -66.304);
		全局.D[全局.N] = 矢量(20.389, 10.695, -66.314);
		全局.N += 1;
		全局.C[全局.N] = 矢量(31.964, 10.755, -95.967);
		全局.D[全局.N] = 矢量(31.449, 10.887, -95.873);
		全局.N += 1;
		全局.C[全局.N] = 矢量(-80.640, 6.407, -152.275);
		全局.D[全局.N] = 矢量(-80.664, 6.258, -152.177);
		全局.N += 1;
		全局.C[全局.N] = 矢量(-41.911, 12.454, -114.758);
		全局.D[全局.N] = 矢量(-42.013, 12.471, -114.906);
		全局.N += 1;
		全局.C[全局.N] = 矢量(20.813, 11.400, -93.095);
		全局.D[全局.N] = 矢量(20.798, 11.041, -93.094);
		全局.N += 1;
		全局.C[全局.N] = 矢量(-48.681, 24.670, -86.852);
		全局.D[全局.N] = 矢量(-48.750, 24.868, -86.842);
		全局.N += 1;
		全局.C[全局.N] = 矢量(14.376, 8.249, -66.479);
		全局.D[全局.N] = 矢量(14.203, 8.226, -66.434);
		全局.N += 1;
		全局.C[全局.N] = 矢量(60.333, 11.208, -64.824);
		全局.D[全局.N] = 矢量(60.619, 11.133, -64.873);
		全局.N += 1;
		全局.C[全局.N] = 矢量(-55.411, 11.724, -71.442);
		全局.D[全局.N] = 矢量(-55.238, 11.593, -71.282);
		全局.N += 1;
		全局.C[全局.N] = 矢量(34.897, 11.022, -87.104);
		全局.D[全局.N] = 矢量(34.901, 11.074, -87.177);
		全局.N += 1;
		全局.C[全局.N] = 矢量(44.373, 10.168, -72.564);
		全局.D[全局.N] = 矢量(44.154, 10.265, -72.576);
	}
}

规则("total number of objects")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.O = 全局.N;
	}
}

规则("beginning of the game *")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.V = 30;
		修改全局变量(J, 添加至数组, 5);
		修改全局变量(J, 添加至数组, 10);
		修改全局变量(J, 添加至数组, 15);
		修改全局变量(J, 添加至数组, 20);
		修改全局变量(J, 添加至数组, 25);
		修改全局变量(J, 添加至数组, 30);
		修改全局变量(J, 添加至数组, 35);
		修改全局变量(J, 添加至数组, 40);
		修改全局变量(J, 添加至数组, 45);
		修改全局变量(J, 添加至数组, 50);
		全局.Y = 30;
		全局.W = 假;
		全局.U = 假;
		全局.M = 假;
		全局.R[1] = 假;
		全局.R[3] = 0;
		全局.D[0] = 矢量(0, -50, 0);
		全局.AA = 19;
		全局.G = -9;
		创建效果(所有玩家(所有队伍), 火花, 颜色(橙色), 矢量(-93.318, 全局.G, -77.228), 7, 可见，位置和半径);
		创建效果(所有玩家(所有队伍), 火花, 颜色(橙色), 矢量(-93.318, 全局.G, -77.228), 7, 可见，位置和半径);
	}
}

规则("player spawn *")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
		是否是机器人(事件玩家) == 假;
	}

	动作
	{
		事件玩家.F = 0;
		传送(事件玩家, 矢量(-26.214, 6.011, -44.322));
		设置启用技能 1(事件玩家, 假);
		设置启用技能 2(事件玩家, 假);
		事件玩家.I = 真;
		事件玩家.G = 5;
		事件玩家.N = 1;
		事件玩家.U = 假;
		事件玩家.V = 假;
		事件玩家.R = 假;
		事件玩家.W = 假;
		事件玩家.O = 假;
		事件玩家.Z = 0;
		事件玩家.X = 假;
		事件玩家.L = 假;
		根据条件跳过(全局.R[2] >= 3, 2);
		全局.R[2] += 1;
		全局.R[1] = 真;
		创建效果(事件玩家, 有益光环, 颜色(橙色), 全局.D[事件玩家.F], 2, 可见，位置和半径);
		事件玩家.E[5] = 最后创建的实体;
		创建效果(事件玩家, 火花, 颜色(橙色), 全局.D[事件玩家.F], 3, 可见，位置和半径);
		事件玩家.E[6] = 最后创建的实体;
		创建HUD文本(事件玩家, 字符串("{0} {1}", 图标字符串(方块), 事件玩家.N), 无, 无, 左边, 1, 颜色(橙色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		事件玩家.E[7] = 最后创建的实体;
		创建HUD文本(事件玩家, 无, 无, 字符串("对象"), 左边, 0, 颜色(白色), 颜色(白色), 颜色(橙色), 可见和字符串, 默认可见度);
		事件玩家.E[8] = 最后创建的实体;
		禁用 设置不可见(事件玩家, 全部);
		设置状态(事件玩家, 无, 无敌, 9999);
		事件玩家.S = 150;
		根据条件跳过(全局.L[1] != 无, 2);
		全局.L[1] = 事件玩家;
		中止;
		根据条件跳过(全局.L[2] != 无, 2);
		全局.L[2] = 事件玩家;
		中止;
		根据条件跳过(全局.L[3] != 无, 2);
		全局.L[3] = 事件玩家;
		中止;
	}
}

规则("intro *")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.I == 真;
	}

	动作
	{
		设置状态(事件玩家, 无, 定身, 4);
		开始镜头(事件玩家, 矢量(10.965, 24.921, -49.823), 矢量(11.338, 24.860, -50.067), 0);
		等待(0.500, 无视条件);
		开始镜头(事件玩家, 矢量(10.965, 24.921, -49.823), 矢量(11.338, 24.860, -50.067), 0);
		等待(0.250, 无视条件);
		开始镜头(事件玩家, 矢量(14.572, 24.335, -52.183), 矢量(15.417, 24.197, -52.736), 0.500);
		小字体信息(事件玩家, 字符串("{0} {1}", 字符串("欢迎"), 字符串("{0}！", 事件玩家)));
		等待(2.500, 无视条件);
		设置朝向(事件玩家, 矢量(0.090, 0, 1), 至地图);
		等待(0.250, 无视条件);
		设置状态(事件玩家, 无, 击倒, 99);
		等待(0.250, 无视条件);
		停止镜头(事件玩家);
		开始镜头(事件玩家, 矢量(63.977, 11.783, -89.586), 矢量(63.975, 11.578, -89.630), 0);
		传送(事件玩家, 矢量(68.368, 11.638, -89.789));
		等待(0.250, 无视条件);
		禁用 设置不可见(事件玩家, 无);
		开始镜头(事件玩家, 矢量(68.353, 11.783, -89.767), 矢量(68.352, 11.636, -89.799), 0.900);
		等待(6, 无视条件);
		开始镜头(事件玩家, 矢量(69.321, 11.492, -91.410), 矢量(69.073, 11.141, -91.135), 0);
		等待(0.500, 无视条件);
		播放效果(事件玩家, 爆炸声音, 颜色(白色), 矢量(58.356, 10.548, -87.713), 50);
		等待(0.250, 无视条件);
		播放效果(事件玩家, 爆炸声音, 颜色(白色), 矢量(58.356, 10.548, -87.713), 50);
		等待(0.700, 无视条件);
		清除状态(事件玩家, 击倒);
		开始镜头(事件玩家, 矢量(69.321, 11.492, -91.410), 矢量(68.728, 11.375, -90.784), 4);
		等待(0.700, 无视条件);
		开始朝向(事件玩家, 矢量(-0.900, 0, 0.400), 200, 至地图, 方向及角速率);
		等待(1, 无视条件);
		禁用 设置不可见(事件玩家, 全部);
		停止朝向(事件玩家);
		事件玩家.I = 假;
		停止镜头(事件玩家);
		事件玩家.T = 真;
		清除状态(事件玩家, 定身);
		事件玩家.M = 真;
	}
}

规则("outro *")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.Z == 1;
	}

	动作
	{
		事件玩家.Z = 2;
		事件玩家.W = 真;
		消除效果(事件玩家.E[5]);
		消除效果(事件玩家.E[6]);
		全局.G = 10.500;
		设置状态(事件玩家, 无, 定身, 9999);
		创建效果(所有玩家(所有队伍), 火花, 颜色(亮紫色), 事件玩家, 1.500, 可见，位置和半径);
		事件玩家.E[3] = 最后创建的实体;
		创建效果(所有玩家(所有队伍), 火花, 颜色(橙色), 事件玩家, 1.500, 可见，位置和半径);
		事件玩家.E[4] = 最后创建的实体;
		开始镜头(事件玩家, 矢量(-95.702, 11.206, -78.394), 矢量(-95.696, 10.846, -78.414), 0);
		传送(事件玩家, 矢量(-93.318, 11.896, -77.228));
		等待(0.500, 无视条件);
		设置朝向(事件玩家, 矢量(-0.350, 0, 0.930), 至地图);
		等待(0.250, 无视条件);
		设置状态(事件玩家, 无, 击倒, 10);
		等待(0.500, 无视条件);
		全局.W = 真;
		禁用 设置不可见(事件玩家, 无);
		开始镜头(事件玩家, 矢量(-95.702, 11.206, -78.394), 矢量(-95.696, 10.846, -78.414), 0);
		等待(0.250, 无视条件);
		开始镜头(事件玩家, 矢量(-93.113, 11.206, -77.627), 矢量(-93.110, 10.846, -77.638), 0.900);
		等待(6.500, 无视条件);
		开始镜头(事件玩家, 矢量(-93.504, 12.340, -76.710), 矢量(-93.318, 11.623, -77.223), 4);
		等待(0.300, 无视条件);
		清除状态(事件玩家, 击倒);
		等待(1, 无视条件);
		大字体信息(所有玩家(所有队伍), 字符串("{0} {1} {2}", 英雄图标字符串(所用英雄(事件玩家)), 事件玩家, 字符串("{0}！", 字符串("胜者"))));
		交流(事件玩家, 表情（上）);
		设置慢动作(35);
		等待(0.250, 无视条件);
		停止镜头(事件玩家);
		开始镜头(事件玩家, 矢量(-93.504, 12.340, -76.710), 矢量(-93.318, 11.623, -77.223), 0);
		等待(0.250, 无视条件);
		开始镜头(事件玩家, 矢量(-93.141, 12.796, -76.754), 矢量(-93.318, 11.623, -77.223), 2);
		等待(0.300, 无视条件);
		开始镜头(事件玩家, 矢量(-92.790, 12.796, -76.918), 矢量(-93.318, 11.623, -77.223), 2);
		等待(0.300, 无视条件);
		开始镜头(事件玩家, 矢量(-92.684, 12.796, -77.436), 矢量(-93.318, 11.623, -77.223), 2);
		等待(0.300, 无视条件);
		开始镜头(事件玩家, 矢量(-93.101, 12.796, -77.877), 矢量(-93.318, 11.623, -77.223), 2);
		等待(0.300, 无视条件);
		开始镜头(事件玩家, 矢量(-93.764, 12.796, -78.031), 矢量(-93.318, 11.623, -77.223), 2);
		等待(0.300, 无视条件);
		开始镜头(事件玩家, 矢量(-94.231, 12.796, -77.715), 矢量(-93.318, 11.623, -77.223), 2);
		等待(0.300, 无视条件);
		开始镜头(事件玩家, 矢量(-94.615, 13.796, -76.735), 矢量(-93.318, 11.623, -77.223), 2);
		等待(0.300, 无视条件);
		开始镜头(事件玩家, 矢量(-93.879, 15.988, -75.711), 矢量(-93.423, 10.712, -76.894), 2);
		等待(1, 无视条件);
		播放效果(所有玩家(所有队伍), 环状爆炸, 颜色(橙色), 事件玩家, 8);
		大字体信息(事件玩家, 字符串("{0}！", 字符串("恭喜")));
		清除状态(事件玩家, 定身);
		等待(1.500, 无视条件);
		设置慢动作(100);
		全局.G = -9;
		停止镜头(事件玩家);
		全局.W = 假;
		等待(10, 无视条件);
		播放效果(事件玩家, 状态爆炸声音, 颜色(白色), 事件玩家, 10);
		消除HUD文本(事件玩家.AA);
		等待(0.250, 无视条件);
		创建HUD文本(事件玩家, 图标字符串(对号), 自定义字符串("Try other maps!"), 自定义字符串("bit.do/whereisit "), 顶部, 1, 颜色(灰绿色), 颜色(白色), 颜色(灰绿色), 字符串, 默认可见度);
		事件玩家.AA = 上一个文本ID;
		等待(90, 无视条件);
		事件玩家.W = 假;
		事件玩家.Z = 0;
		消除效果(事件玩家.E[3]);
		消除效果(事件玩家.E[4]);
		禁用 设置不可见(事件玩家, 全部);
		小字体信息(事件玩家, 字符串("{0} {1}", 事件玩家, 字符串("不可见")));
	}
}

规则("infinite match time")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		比赛时间 <= 1800;
	}

	动作
	{
		设置比赛时间(3600);
	}
}

规则("player pressed \"F\" key on the empty place")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(互动)) == 真;
		相距距离(事件玩家, 全局.D[事件玩家.F]) > 5;
		相距距离(事件玩家, 全局.D[事件玩家.F + 1]) > 5;
		事件玩家.I == 假;
		事件玩家.T == 假;
		具有状态(事件玩家, 冰冻) == 假;
		事件玩家.F < 全局.O;
	}

	动作
	{
		小字体信息(事件玩家, 字符串("{0} {1}", 字符串("否"), 字符串("物品")));
		播放效果(事件玩家, 负面状态施加声音, 颜色(白色), 事件玩家, 30);
		设置状态(事件玩家, 无, 冰冻, 1);
	}
}

规则("player found item")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(互动)) == 真;
		相距距离(事件玩家, 全局.D[事件玩家.F + 1]) <= 5;
		具有状态(事件玩家, 冰冻) == 假;
		事件玩家.F < 全局.O;
	}

	动作
	{
		小字体信息(事件玩家, 字符串("{0}！", 字符串("好")));
		播放效果(事件玩家, 环状爆炸, 颜色(橙色), 全局.D[事件玩家.F + 1], 5);
		播放效果(事件玩家, 环状爆炸, 颜色(橙色), 全局.D[事件玩家.F + 1], 7);
		播放效果(事件玩家, 正面状态施加声音, 颜色(白色), 事件玩家, 50);
		事件玩家.F += 1;
		事件玩家.K = 3;
		事件玩家.U = 真;
		事件玩家.G = 10;
		根据条件跳过(事件玩家.F == 全局.J[10], 11);
		根据条件跳过(事件玩家.F == 全局.J[9], 10);
		根据条件跳过(事件玩家.F == 全局.J[8], 9);
		根据条件跳过(事件玩家.F == 全局.J[7], 8);
		根据条件跳过(事件玩家.F == 全局.J[6], 7);
		根据条件跳过(事件玩家.F == 全局.J[5], 6);
		根据条件跳过(事件玩家.F == 全局.J[4], 5);
		根据条件跳过(事件玩家.F == 全局.J[3], 4);
		根据条件跳过(事件玩家.F == 全局.J[2], 3);
		根据条件跳过(事件玩家.F == 全局.J[1], 2);
		事件玩家.U = 假;
		事件玩家.T = 真;
		等待(1, 无视条件);
		播放效果(事件玩家, 正面状态施加声音, 颜色(白色), 事件玩家, 50);
		大字体信息(事件玩家, 字符串("{0} / {1}", 事件玩家.F, 全局.O));
		根据条件跳过(事件玩家.F != 2, 1);
		事件玩家.R = 真;
		根据条件跳过(事件玩家.F < 全局.O, 1);
		事件玩家.N = 事件玩家.F;
		根据条件跳过(事件玩家.F == 全局.O, 1);
		事件玩家.N = 事件玩家.F + 1;
	}
}

规则("shift key is pressed (acceleration)")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(技能1)) == 真;
	}

	动作
	{
		设置移动速度(事件玩家, 事件玩家.S);
	}
}

规则("shift key is not pressed (slowdown)")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(技能1)) == 假;
	}

	动作
	{
		设置移动速度(事件玩家, 110);
	}
}

规则("spacebar is pressed (fly)")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(跳跃)) == 真;
		事件玩家.F >= 全局.Y;
	}

	动作
	{
		设置引力(事件玩家, 0);
	}
}

规则("spacebar is not pressed (gravity)")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(跳跃)) == 假;
		事件玩家.F >= 全局.Y;
	}

	动作
	{
		设置引力(事件玩家, 100);
	}
}

规则("right click shows picture")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(辅助攻击模式)) == 真;
		事件玩家.I == 假;
		事件玩家.Z == 0;
		事件玩家.X == 假;
	}

	动作
	{
		根据条件跳过(事件玩家.F < 全局.O, 1);
		事件玩家.N = 事件玩家.F;
		根据条件跳过(事件玩家.F == 全局.O, 1);
		事件玩家.N = 事件玩家.F + 1;
		开始镜头(事件玩家, 全局.C[事件玩家.N], 全局.D[事件玩家.N], 0);
		事件玩家.T = 假;
		根据条件跳过(事件玩家.U == 假, 1);
		事件玩家.O = 真;
		根据条件跳过(事件玩家.G > 0, 3);
		根据条件跳过(相距距离(所选位置(事件玩家), 全局.D[事件玩家.F + 1]) < 50, 1);
		小字体信息(事件玩家, 字符串("{0} {1} {2}", 字符串("对象"), 字符串("远"), 图标字符串(停止)));
		事件玩家.G = 1;
	}
}

规则("right mouse button is not pressed")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(辅助攻击模式)) == 假;
		事件玩家.I == 假;
		事件玩家.Z == 0;
		事件玩家.X == 假;
	}

	动作
	{
		停止镜头(事件玩家);
		清除状态(事件玩家, 定身);
		根据条件跳过(事件玩家.U == 假, 1);
		事件玩家.O = 真;
		根据条件跳过(事件玩家.F < 全局.O, 1);
		事件玩家.N = 事件玩家.F;
		根据条件跳过(事件玩家.F == 全局.O, 1);
		事件玩家.N = 事件玩家.F + 1;
	}
}

规则("left mouse button shows previous objects")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(主要攻击模式)) == 真;
		按钮被按下(事件玩家, 按钮(辅助攻击模式)) == 真;
		事件玩家.I == 假;
		事件玩家.X == 假;
		事件玩家.Z == 0;
	}

	动作
	{
		事件玩家.N -= 1;
		根据条件跳过(事件玩家.N > 0, 4);
		根据条件跳过(事件玩家.F == 全局.O, 1);
		事件玩家.N = 事件玩家.F + 1;
		根据条件跳过(事件玩家.F != 全局.O, 1);
		事件玩家.N = 事件玩家.F;
	}
}

规则("teleport cooldown")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.B == 真;
	}

	动作
	{
		等待(2, 无视条件);
		事件玩家.B = 假;
		等待(0.500, 无视条件);
		如条件为”真“则循环;
	}
}

规则("teleports Team 1 *")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.P[1] = 矢量(41.099, 11.549, -76.256);
		创建效果(所有玩家(队伍1), 环, 颜色(蓝色), 全局.P[1], 1.500, 可见);
		全局.P[2] = 矢量(44.981, 11.549, -76.753);
		创建效果(所有玩家(队伍1), 环, 颜色(蓝色), 全局.P[2], 1.500, 可见);
		全局.P[3] = 矢量(51.263, 11.549, -94.038);
		创建效果(所有玩家(队伍1), 环, 颜色(蓝色), 全局.P[3], 1.200, 可见);
		全局.P[4] = 矢量(47.094, 11.044, -93.527);
		创建效果(所有玩家(队伍1), 环, 颜色(蓝色), 全局.P[4], 1.200, 可见);
	}
}

规则("teleports Team 2 *")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.P[5] = 矢量(-79.898, 8.988, -172.115);
		创建效果(所有玩家(队伍2), 环, 颜色(蓝色), 全局.P[5], 1.300, 可见);
		全局.P[6] = 矢量(-80.850, 8.988, -176.066);
		创建效果(所有玩家(队伍2), 环, 颜色(蓝色), 全局.P[6], 1.300, 可见);
		全局.P[7] = 矢量(-96.707, 8.988, -164.277);
		创建效果(所有玩家(队伍2), 环, 颜色(蓝色), 全局.P[7], 1.300, 可见);
		全局.P[8] = 矢量(-97.524, 8.988, -168.198);
		创建效果(所有玩家(队伍2), 环, 颜色(蓝色), 全局.P[8], 1.300, 可见);
		全局.P[9] = 矢量(-107.113, 7.988, -107.958);
		创建效果(所有玩家(队伍2), 环, 颜色(蓝色), 全局.P[9], 1.300, 可见);
		全局.P[10] = 矢量(-111.139, 7.988, -107.009);
		创建效果(所有玩家(队伍2), 环, 颜色(蓝色), 全局.P[10], 1.300, 可见);
		全局.P[11] = 矢量(-77.167, 7.988, -105.853);
		创建效果(所有玩家(队伍2), 环, 颜色(蓝色), 全局.P[11], 1.300, 可见);
		全局.P[12] = 矢量(-76.341, 7.988, -102.163);
		创建效果(所有玩家(队伍2), 环, 颜色(蓝色), 全局.P[12], 1.300, 可见);
		全局.P[13] = 矢量(-42.262, 8.435, -118.826);
		创建效果(所有玩家(队伍2), 环, 颜色(蓝色), 全局.P[13], 1.300, 可见);
		全局.P[14] = 矢量(-40.481, 8.928, -115.825);
		创建效果(所有玩家(队伍2), 环, 颜色(蓝色), 全局.P[14], 1.300, 可见);
		全局.P[15] = 矢量(-20.279, 7.325, -111.015);
		创建效果(所有玩家(队伍2), 环, 颜色(蓝色), 全局.P[15], 1.300, 可见);
		全局.P[16] = 矢量(-18.409, 8.029, -107.944);
		创建效果(所有玩家(队伍2), 环, 颜色(蓝色), 全局.P[16], 1.300, 可见);
	}
}

规则("teleports All Teams *")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.P[17] = 矢量(-66.917, 10.989, -82.630);
		创建效果(所有玩家(所有队伍), 环, 颜色(蓝色), 全局.P[17], 1.300, 可见);
		全局.P[18] = 矢量(-65.847, 11.029, -78.584);
		创建效果(所有玩家(所有队伍), 环, 颜色(蓝色), 全局.P[18], 1.300, 可见);
	}
}

规则("teleport 1 *")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		事件玩家.B == 假;
		全局.P[1] != 0;
		相距距离(事件玩家, 全局.P[1]) <= 2;
	}

	动作
	{
		传送(事件玩家, 矢量(45.684, 11.551, -69.700));
		事件玩家.B = 真;
		播放效果(事件玩家, 有益爆炸, 颜色(蓝色), 事件玩家, 5);
		播放效果(事件玩家, 环状爆炸声音, 颜色(白色), 事件玩家, 20);
	}
}

规则("teleport 2")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		事件玩家.B == 假;
		全局.P[2] != 0;
		相距距离(事件玩家, 全局.P[2]) <= 2;
	}

	动作
	{
		传送(事件玩家, 全局.P[1]);
		事件玩家.B = 真;
		播放效果(事件玩家, 有益爆炸, 颜色(蓝色), 事件玩家, 5);
		播放效果(事件玩家, 环状爆炸声音, 颜色(白色), 事件玩家, 20);
	}
}

规则("teleport 3")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		事件玩家.B == 假;
		全局.P[3] != 0;
		相距距离(事件玩家, 全局.P[3]) <= 2;
	}

	动作
	{
		传送(事件玩家, 全局.P[4]);
		事件玩家.B = 真;
		播放效果(事件玩家, 有益爆炸, 颜色(蓝色), 事件玩家, 5);
		播放效果(事件玩家, 环状爆炸声音, 颜色(白色), 事件玩家, 20);
	}
}

规则("teleport 4")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		事件玩家.B == 假;
		全局.P[4] != 0;
		相距距离(事件玩家, 全局.P[4]) <= 2;
	}

	动作
	{
		传送(事件玩家, 全局.P[3]);
		事件玩家.B = 真;
		播放效果(事件玩家, 有益爆炸, 颜色(蓝色), 事件玩家, 5);
		播放效果(事件玩家, 环状爆炸声音, 颜色(白色), 事件玩家, 20);
	}
}

规则("teleport 5")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		事件玩家.B == 假;
		全局.P[5] != 0;
		相距距离(事件玩家, 全局.P[5]) <= 2;
	}

	动作
	{
		传送(事件玩家, 全局.P[6]);
		事件玩家.B = 真;
		播放效果(事件玩家, 有益爆炸, 颜色(蓝色), 事件玩家, 5);
		播放效果(事件玩家, 环状爆炸声音, 颜色(白色), 事件玩家, 20);
	}
}

规则("teleport 6")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		事件玩家.B == 假;
		全局.P[6] != 0;
		相距距离(事件玩家, 全局.P[6]) <= 2;
	}

	动作
	{
		传送(事件玩家, 全局.P[5]);
		事件玩家.B = 真;
		播放效果(事件玩家, 有益爆炸, 颜色(蓝色), 事件玩家, 5);
		播放效果(事件玩家, 环状爆炸声音, 颜色(白色), 事件玩家, 20);
	}
}

规则("teleport 7")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		事件玩家.B == 假;
		全局.P[7] != 0;
		相距距离(事件玩家, 全局.P[7]) <= 2;
	}

	动作
	{
		传送(事件玩家, 全局.P[8]);
		事件玩家.B = 真;
		播放效果(事件玩家, 有益爆炸, 颜色(蓝色), 事件玩家, 5);
		播放效果(事件玩家, 环状爆炸声音, 颜色(白色), 事件玩家, 20);
	}
}

规则("teleport 8")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		事件玩家.B == 假;
		全局.P[8] != 0;
		相距距离(事件玩家, 全局.P[8]) <= 2;
	}

	动作
	{
		传送(事件玩家, 全局.P[7]);
		事件玩家.B = 真;
		播放效果(事件玩家, 有益爆炸, 颜色(蓝色), 事件玩家, 5);
		播放效果(事件玩家, 环状爆炸声音, 颜色(白色), 事件玩家, 20);
	}
}

规则("teleport 9")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		事件玩家.B == 假;
		全局.P[9] != 0;
		相距距离(事件玩家, 全局.P[9]) <= 2;
	}

	动作
	{
		传送(事件玩家, 全局.P[10]);
		事件玩家.B = 真;
		播放效果(事件玩家, 有益爆炸, 颜色(蓝色), 事件玩家, 5);
		播放效果(事件玩家, 环状爆炸声音, 颜色(白色), 事件玩家, 20);
	}
}

规则("teleport 10")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		事件玩家.B == 假;
		全局.P[10] != 0;
		相距距离(事件玩家, 全局.P[10]) <= 2;
	}

	动作
	{
		传送(事件玩家, 全局.P[9]);
		事件玩家.B = 真;
		播放效果(事件玩家, 有益爆炸, 颜色(蓝色), 事件玩家, 5);
		播放效果(事件玩家, 环状爆炸声音, 颜色(白色), 事件玩家, 20);
	}
}

规则("teleport 11")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		事件玩家.B == 假;
		全局.P[11] != 0;
		相距距离(事件玩家, 全局.P[11]) <= 2;
	}

	动作
	{
		传送(事件玩家, 全局.P[12]);
		事件玩家.B = 真;
		播放效果(事件玩家, 有益爆炸, 颜色(蓝色), 事件玩家, 5);
		播放效果(事件玩家, 环状爆炸声音, 颜色(白色), 事件玩家, 20);
	}
}

规则("teleport 12")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		事件玩家.B == 假;
		全局.P[12] != 0;
		相距距离(事件玩家, 全局.P[12]) <= 2;
	}

	动作
	{
		传送(事件玩家, 全局.P[11]);
		事件玩家.B = 真;
		播放效果(事件玩家, 有益爆炸, 颜色(蓝色), 事件玩家, 5);
		播放效果(事件玩家, 环状爆炸声音, 颜色(白色), 事件玩家, 20);
	}
}

规则("teleport 13")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		事件玩家.B == 假;
		全局.P[13] != 0;
		相距距离(事件玩家, 全局.P[13]) <= 2;
	}

	动作
	{
		传送(事件玩家, 全局.P[14]);
		事件玩家.B = 真;
		播放效果(事件玩家, 有益爆炸, 颜色(蓝色), 事件玩家, 5);
		播放效果(事件玩家, 环状爆炸声音, 颜色(白色), 事件玩家, 20);
	}
}

规则("teleport 14")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		事件玩家.B == 假;
		全局.P[14] != 0;
		相距距离(事件玩家, 全局.P[14]) <= 2;
	}

	动作
	{
		传送(事件玩家, 全局.P[13]);
		事件玩家.B = 真;
		播放效果(事件玩家, 有益爆炸, 颜色(蓝色), 事件玩家, 5);
		播放效果(事件玩家, 环状爆炸声音, 颜色(白色), 事件玩家, 20);
	}
}

规则("teleport 15")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		事件玩家.B == 假;
		全局.P[15] != 0;
		相距距离(事件玩家, 全局.P[15]) <= 2;
	}

	动作
	{
		传送(事件玩家, 全局.P[16]);
		事件玩家.B = 真;
		播放效果(事件玩家, 有益爆炸, 颜色(蓝色), 事件玩家, 5);
		播放效果(事件玩家, 环状爆炸声音, 颜色(白色), 事件玩家, 20);
	}
}

规则("teleport 16")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		全部;
	}

	条件
	{
		事件玩家.B == 假;
		全局.P[16] != 0;
		相距距离(事件玩家, 全局.P[16]) <= 2;
	}

	动作
	{
		传送(事件玩家, 全局.P[15]);
		事件玩家.B = 真;
		播放效果(事件玩家, 有益爆炸, 颜色(蓝色), 事件玩家, 5);
		播放效果(事件玩家, 环状爆炸声音, 颜色(白色), 事件玩家, 20);
	}
}

规则("teleport 17 *")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.B == 假;
		全局.P[17] != 0;
		相距距离(事件玩家, 全局.P[17]) <= 2;
	}

	动作
	{
		传送(事件玩家, 矢量(-69.893, 11.030, -77.695));
		事件玩家.B = 真;
		播放效果(事件玩家, 有益爆炸, 颜色(蓝色), 事件玩家, 5);
		播放效果(事件玩家, 环状爆炸声音, 颜色(白色), 事件玩家, 20);
	}
}

规则("teleport 18 *")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.B == 假;
		全局.P[18] != 0;
		相距距离(事件玩家, 全局.P[18]) <= 2;
	}

	动作
	{
		传送(事件玩家, 全局.P[17]);
		事件玩家.B = 真;
		播放效果(事件玩家, 有益爆炸, 颜色(蓝色), 事件玩家, 5);
		播放效果(事件玩家, 环状爆炸声音, 颜色(白色), 事件玩家, 20);
	}
}

规则("player found all objects (victory!)")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.F == 全局.O;
	}

	动作
	{
		事件玩家.Z = 5;
		设置状态(事件玩家, 无, 定身, 9999);
		播放效果(事件玩家, 环状爆炸声音, 颜色(白色), 事件玩家, 30);
		播放效果(事件玩家, 环状爆炸, 颜色(亮紫色), 全局.D[事件玩家.F], 6);
		播放效果(事件玩家, 有益爆炸, 颜色(橙色), 全局.D[事件玩家.F], 10);
		播放效果(事件玩家, 有益选择效果 , 颜色(橙色), 全局.D[事件玩家.F], 10);
		等待(3, 无视条件);
		事件玩家.Z = 1;
	}
}

规则("everyone is watching the winner *")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.W == 假;
		事件玩家.Z == 0;
		全局.W == 真;
		事件玩家.F >= 2;
	}

	动作
	{
		设置状态(事件玩家, 无, 定身, 9999);
		事件玩家.X = 真;
		开始镜头(事件玩家, 矢量(-95.702, 11.206, -78.394), 矢量(-95.696, 10.846, -78.414), 0);
		等待(0.250, 无视条件);
		开始镜头(事件玩家, 矢量(-93.113, 11.206, -77.627), 矢量(-93.110, 10.846, -77.638), 0.900);
		等待(6.500, 无视条件);
		开始镜头(事件玩家, 矢量(-93.504, 12.340, -76.710), 矢量(-93.318, 11.623, -77.223), 4);
		等待(1.800, 无视条件);
		开始镜头(事件玩家, 矢量(-93.141, 12.796, -76.754), 矢量(-93.318, 11.623, -77.223), 2);
		等待(0.300, 无视条件);
		开始镜头(事件玩家, 矢量(-92.790, 12.796, -76.918), 矢量(-93.318, 11.623, -77.223), 2);
		等待(0.300, 无视条件);
		开始镜头(事件玩家, 矢量(-92.684, 12.796, -77.436), 矢量(-93.318, 11.623, -77.223), 2);
		等待(0.300, 无视条件);
		开始镜头(事件玩家, 矢量(-93.101, 12.796, -77.877), 矢量(-93.318, 11.623, -77.223), 2);
		等待(0.300, 无视条件);
		开始镜头(事件玩家, 矢量(-93.764, 12.796, -78.031), 矢量(-93.318, 11.623, -77.223), 2);
		等待(0.300, 无视条件);
		开始镜头(事件玩家, 矢量(-94.231, 12.796, -77.715), 矢量(-93.318, 11.623, -77.223), 2);
		等待(0.300, 无视条件);
		开始镜头(事件玩家, 矢量(-94.615, 13.796, -76.735), 矢量(-93.318, 11.623, -77.223), 2);
		等待(0.300, 无视条件);
		开始镜头(事件玩家, 矢量(-93.879, 15.988, -75.711), 矢量(-93.423, 10.712, -76.894), 2);
		等待(2.500, 无视条件);
		清除状态(事件玩家, 定身);
		全局.W = 假;
		停止镜头(事件玩家);
		事件玩家.X = 假;
	}
}

规则("automatically show next object")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.T == 真;
		事件玩家.U == 假;
	}

	动作
	{
		等待(3, 无视条件);
		如条件为“假”则中止;
		事件玩家.Q = 真;
		设置状态(事件玩家, 无, 定身, 5);
		开始镜头(事件玩家, 全局.C[事件玩家.F + 1], 全局.D[事件玩家.F + 1], 0);
		根据条件跳过(事件玩家.F != 0, 1);
		大字体信息(事件玩家, 字符串("{0} {1}", 字符串("寻找"), 字符串("对象")));
		根据条件跳过(事件玩家.F == 0, 1);
		大字体信息(事件玩家, 字符串("{0} {1}", 字符串("寻找"), 字符串("下一批对象")));
		等待(5, 无视条件);
		事件玩家.T = 假;
		停止镜头(事件玩家);
		事件玩家.Q = 假;
	}
}

规则("cancel auto preview")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.T == 真;
		事件玩家.Q == 真;
		事件玩家.Z == 0;
		事件玩家.X == 假;
	}

	动作
	{
		根据条件跳过(按钮被按下(事件玩家, 按钮(主要攻击模式)) != 真, 4);
		事件玩家.T = 假;
		清除状态(事件玩家, 定身);
		停止镜头(事件玩家);
		事件玩家.Q = 假;
		根据条件跳过(按钮被按下(事件玩家, 按钮(辅助攻击模式)) != 真, 4);
		事件玩家.T = 假;
		清除状态(事件玩家, 定身);
		停止镜头(事件玩家);
		事件玩家.Q = 假;
		根据条件跳过(按钮被按下(事件玩家, 按钮(跳跃)) != 真, 4);
		事件玩家.T = 假;
		清除状态(事件玩家, 定身);
		停止镜头(事件玩家);
		事件玩家.Q = 假;
		根据条件跳过(按钮被按下(事件玩家, 按钮(终极技能)) != 真, 4);
		事件玩家.T = 假;
		清除状态(事件玩家, 定身);
		停止镜头(事件玩家);
		事件玩家.Q = 假;
		根据条件跳过(按钮被按下(事件玩家, 按钮(技能2)) != 真, 4);
		事件玩家.T = 假;
		清除状态(事件玩家, 定身);
		停止镜头(事件玩家);
		事件玩家.Q = 假;
	}
}

规则("hint near the first object *")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		相距距离(事件玩家, 全局.D[1]) <= 5;
		事件玩家.F == 0;
	}

	动作
	{
		小字体信息(事件玩家, 字符串("{0} {1}", 字符串("互动"), 字符串("{0}！", 字符串("此处"))));
	}
}

规则("message about right button")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.M == 真;
	}

	动作
	{
		等待(9, 无视条件);
		小字体信息(事件玩家, 字符串("{0} {1}", 字符串("{0} - {1}", 自定义字符串("[Right Click]"), 字符串("当前目标")), 图标字符串(眼睛)));
		事件玩家.M = 假;
	}
}

规则("message about running")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.R == 真;
	}

	动作
	{
		等待(8, 无视条件);
		小字体信息(事件玩家, 字符串("{0} {1}", 字符串("{0} - {1}", 自定义字符串("[Shift]"), 字符串("运行")), 图标字符串(箭矢)));
		事件玩家.R = 假;
	}
}

规则("message about flying")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.F == 全局.Y;
	}

	动作
	{
		等待(8, 无视条件);
		小字体信息(事件玩家, 字符串("{0} {1}", 字符串("{0} - {1}", 字符串("跳跃"), 字符串("飞行")), 图标字符串(光晕)));
		等待(30, 无视条件);
		如条件为“假”则中止;
		小字体信息(事件玩家, 字符串("{0} {1}", 字符串("{0} - {1}", 字符串("跳跃"), 字符串("飞行")), 图标字符串(光晕)));
		等待(30, 无视条件);
		如条件为“假”则中止;
		小字体信息(事件玩家, 字符串("{0} {1}", 字符串("{0} - {1}", 字符串("跳跃"), 字符串("飞行")), 图标字符串(光晕)));
		等待(30, 无视条件);
		如条件为“假”则中止;
		小字体信息(事件玩家, 字符串("{0} {1}", 字符串("{0} - {1}", 字符串("跳跃"), 字符串("飞行")), 图标字符串(光晕)));
		等待(30, 无视条件);
		如条件为“假”则中止;
		小字体信息(事件玩家, 字符串("{0} {1}", 字符串("{0} - {1}", 字符串("跳跃"), 字符串("飞行")), 图标字符串(光晕)));
	}
}

规则("player left game")
{
	事件
	{
		玩家离开比赛;
		双方;
		全部;
	}

	动作
	{
		消除效果(事件玩家.E[1]);
		消除效果(事件玩家.E[2]);
		消除效果(事件玩家.E[3]);
		消除效果(事件玩家.E[4]);
		消除效果(事件玩家.E[5]);
		消除效果(事件玩家.E[6]);
		消除效果(事件玩家.E[7]);
		消除效果(事件玩家.E[8]);
		根据条件跳过(全局.L[1] != 事件玩家, 1);
		所有玩家(所有队伍).K = 3;
		根据条件跳过(全局.L[2] != 事件玩家, 1);
		所有玩家(所有队伍).K = 3;
		根据条件跳过(全局.L[3] != 事件玩家, 1);
		所有玩家(所有队伍).K = 3;
		设置慢动作(100);
		消除HUD文本(事件玩家.AA);
		If(事件玩家.W == 真);
			全局.G = -9;
		End;
	}
}

规则("speed upgrade")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.U == 真;
		事件玩家.F != 全局.Y;
		事件玩家.F != 全局.O;
	}

	动作
	{
		播放效果(事件玩家, 环状爆炸, 颜色(天蓝色), 全局.D[事件玩家.F], 6);
		创建光束效果(事件玩家, 有益光束, 全局.D[事件玩家.F], 事件玩家, 颜色(天蓝色), 可见，位置和半径);
		事件玩家.E[1] = 最后创建的实体;
		创建效果(事件玩家, 能量声音, 颜色(白色), 事件玩家, 30, 可见，位置和半径);
		事件玩家.E[2] = 最后创建的实体;
		根据条件跳过(事件玩家.S > 410, 1);
		事件玩家.S += 全局.V;
		等待(1, 无视条件);
		消除效果(事件玩家.E[1]);
		消除效果(事件玩家.E[2]);
		小字体信息(事件玩家, 字符串("{0} {1}", 图标字符串(箭头：向上), 字符串("{0}！", 字符串("等级提升"))));
		大字体信息(事件玩家, 字符串("{0} {1} {2}", 字符串("速度"), 字符串("{0}！", 字符串("升级")), 图标字符串(箭矢)));
		等待(1, 无视条件);
		事件玩家.U = 假;
		根据条件跳过(事件玩家.O == 真, 1);
		事件玩家.T = 真;
		根据条件跳过(事件玩家.O == 假, 1);
		事件玩家.O = 假;
		事件玩家.R = 真;
	}
}

规则("flying upgrade")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.U == 真;
		事件玩家.F == 全局.Y;
	}

	动作
	{
		播放效果(事件玩家, 环状爆炸, 颜色(亮紫色), 全局.D[事件玩家.F], 7);
		创建光束效果(事件玩家, 有益光束, 全局.D[事件玩家.F], 事件玩家, 颜色(橙色), 可见，位置和半径);
		事件玩家.E[1] = 最后创建的实体;
		创建效果(事件玩家, 能量声音, 颜色(白色), 事件玩家, 30, 可见，位置和半径);
		事件玩家.E[2] = 最后创建的实体;
		事件玩家.Y = 真;
		等待(1, 无视条件);
		消除效果(事件玩家.E[1]);
		消除效果(事件玩家.E[2]);
		小字体信息(事件玩家, 字符串("{0} {1}", 图标字符串(箭头：向上), 字符串("{0}！", 字符串("等级提升"))));
		大字体信息(事件玩家, 字符串("{0} {1} {2}", 字符串("飞行"), 字符串("{0}！", 字符串("升级")), 图标字符串(光晕)));
		等待(1, 无视条件);
		事件玩家.U = 假;
		根据条件跳过(事件玩家.O == 真, 1);
		事件玩家.T = 真;
		根据条件跳过(事件玩家.O == 假, 1);
		事件玩家.O = 假;
	}
}

规则("rating")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.R[1] == 真;
	}

	动作
	{
		根据条件跳过(全局.R[2] < 1, 4);
		根据条件跳过(全局.R[3] >= 1, 3);
		创建HUD文本(所有玩家(所有队伍), 无, 无, 字符串("{0} {1}", 字符串("最佳"), 字符串("{0}:", 字符串("玩家"))), 右边, 0, 颜色(白色), 颜色(白色), 颜色(橙色), 可见和字符串, 默认可见度);
		创建HUD文本(所有玩家(所有队伍), 无, 无, 字符串("{0} {1} {2}", 英雄图标字符串(所用英雄(全局.L[1])), 全局.L[1], 字符串("{0} / {1}", 全局.L[1].F, 全局.O)), 右边, 1, 颜色(白色),
			颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		全局.R[3] = 1;
		根据条件跳过(全局.R[2] < 2, 3);
		根据条件跳过(全局.R[3] >= 2, 2);
		创建HUD文本(所有玩家(所有队伍), 无, 无, 字符串("{0} {1} {2}", 英雄图标字符串(所用英雄(全局.L[2])), 全局.L[2], 字符串("{0} / {1}", 全局.L[2].F, 全局.O)), 右边, 2, 颜色(白色),
			颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		全局.R[3] = 2;
		根据条件跳过(全局.R[2] != 3, 3);
		根据条件跳过(全局.R[3] == 3, 2);
		创建HUD文本(所有玩家(所有队伍), 无, 无, 字符串("{0} {1} {2}", 英雄图标字符串(所用英雄(全局.L[3])), 全局.L[3], 字符串("{0} / {1}", 全局.L[3].F, 全局.O)), 右边, 3, 颜色(白色),
			颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		全局.R[3] = 3;
		等待(1, 无视条件);
		根据条件循环(全局.R[2] > 全局.R[3]);
		全局.R[1] = 假;
	}
}

规则("rating update")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.K > 0;
	}

	动作
	{
		根据条件跳过(全局.L[1] != 事件玩家, 2);
		事件玩家.K = 0;
		中止;
		根据条件跳过(全局.L[2] != 事件玩家, 5);
		根据条件跳过(事件玩家.F <= 全局.L[1].F, 4);
		全局.L[2] = 全局.L[1];
		全局.L[1] = 事件玩家;
		事件玩家.K = 0;
		中止;
		根据条件跳过(全局.L[3] != 事件玩家, 3);
		根据条件跳过(事件玩家.F <= 全局.L[2].F, 2);
		全局.L[3] = 全局.L[2];
		全局.L[2] = 事件玩家;
		根据条件跳过(全局.L[1] == 事件玩家, 4);
		根据条件跳过(全局.L[2] == 事件玩家, 3);
		根据条件跳过(全局.L[3] == 事件玩家, 2);
		根据条件跳过(事件玩家.F <= 全局.L[3].F, 1);
		全局.L[3] = 事件玩家;
		等待(0.050, 无视条件);
		事件玩家.K -= 1;
		如条件为”真“则循环;
	}
}

规则("search time")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.W == 假;
		事件玩家.G > 0;
	}

	动作
	{
		等待(30, 无视条件);
		事件玩家.G -= 1;
		如条件为”真“则循环;
	}
}

规则("message about previous objects")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.F >= 10;
	}

	动作
	{
		等待(25, 无视条件);
		小字体信息(事件玩家, 字符串("{0} {1}", 字符串("{0} = {1}", 字符串("{0} + {1}", 自定义字符串("[Right Click]"), 自定义字符串("[Left Click]")), 字符串("对象")), 图标字符串(
			回收)));
	}
}

规则("graphic settings warning 1 *")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.F == 全局.AA;
	}

	动作
	{
		等待(3, 无视条件);
		如条件为“假”则中止;
		消除HUD文本(事件玩家.AA);
		等待(0.250, 无视条件);
		创建HUD文本(事件玩家, 图标字符串(眼睛), 自定义字符串("Set medium or higher model detail settings to see all objects"), 自定义字符串(
			"Options > Video > Graphics quality > Advanced > Model Detail"), 顶部, 1, 颜色(橙色), 颜色(白色), 颜色(橙色), 字符串, 默认可见度);
		事件玩家.AA = 上一个文本ID;
	}
}

规则("graphic settings warning 2 *")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.F == 全局.AA + 1;
	}

	动作
	{
		消除HUD文本(事件玩家.AA);
	}
}