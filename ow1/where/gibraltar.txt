设置
{
	主程序
	{
		描述: "2SYQ4这是哪儿——监测站：直布罗陀★在地图上寻找神秘地点 ★点击右键可以看到一个神秘图片，找到这个地方，对物品按下互动键（默认F）得到下一张照片，先找完的人获胜！ ★建议设置为中高模型特效获取更好的游戏体验★游戏结束后会获得奖励 ★按[shift]奔跑 ★提示和更多地图在owmot.net搜索★ Made by Foren#2660 ★ 国服搬运工：KDLin#5710"
	}

	大厅
	{
		地图轮换: 暂停轮换
		比赛结束后转换队伍: 否
		比赛语音聊天: 启用
		玩家上限 队伍1: 0
		玩家上限 队伍2: 12
		观战者人数上限: 3
		返回大厅: 从不
	}

	模式
	{
		突击模式
		{
			启用地图
			{
				监测站：直布罗陀
			}
		}

		综合
		{
			复生时间: 0%
			急救包刷新: 禁用
			比赛模式开始: 即时
			消灭提示: 关闭
			消灭镜头: 关闭
			英雄限制: 关闭
		}
	}

	英雄
	{
		综合
		{
			主要攻击模式: 关闭
			仅爆头有效: 开启
			战斗时终极技能充能速度: 0%
			技能冷却时间: 50%
			移动速度: 110%
			终极技能充能速度: 10%
			终极技能自动充能速度: 0%
			近身攻击: 关闭

			D.Va
			{
				主要攻击模式: 关闭
				微型飞弹: 关闭
				推进器: 关闭
				终极技能（自毁）: 关闭
				近身攻击: 关闭
				防御矩阵: 关闭
			}

			半藏
			{
				主要攻击模式: 关闭
				岚: 关闭
				终极技能（竜）: 关闭
				跃: 关闭
				近身攻击: 关闭
				音: 关闭
			}

			卢西奥
			{
				主要攻击模式: 关闭
				切歌: 关闭
				强音: 关闭
				终极技能（音障）: 关闭
				近身攻击: 关闭
				音波: 关闭
			}

			回声
			{
				主要攻击模式: 关闭
				滑翔: 关闭
				终极技能（人格复制）: 关闭
				聚焦光线: 关闭
				近身攻击: 关闭
				重生时终极技能充能完毕: 开启
				飞行: 关闭
				黏性炸弹: 关闭
			}

			堡垒
			{
				主要攻击模式: 关闭
				切换模式: 关闭
				终极技能（坦克模式）: 关闭
				自我修复: 关闭
				近身攻击: 关闭
			}

			士兵：76
			{
				主要攻击模式: 关闭
				生物力场: 关闭
				疾跑: 关闭
				终极技能（战术目镜）: 关闭
				螺旋飞弹: 关闭
				近身攻击: 关闭
			}

			天使
			{
				主要攻击模式: 关闭
				守护天使: 关闭
				终极技能（女武神）: 关闭
				自动恢复: 关闭
				辅助攻击模式: 关闭
				近身攻击: 关闭
				重生: 关闭
			}

			奥丽莎
			{
				主要攻击模式: 关闭
				强固防御: 关闭
				站住别动: 关闭
				终极技能（超充能器）: 关闭
				近身攻击: 关闭
				防护屏障: 关闭
			}

			安娜
			{
				主要攻击模式: 关闭
				生物手雷: 关闭
				终极技能（纳米激素）: 关闭
				近身攻击: 关闭
				麻醉镖: 关闭
			}

			巴蒂斯特
			{
				主要攻击模式: 关闭
				愈合冲击: 关闭
				终极技能（增幅矩阵）: 关闭
				维生力场: 关闭
				辅助攻击模式: 关闭
				近身攻击: 关闭
			}

			布丽吉塔
			{
				主要攻击模式: 关闭
				屏障护盾: 关闭
				恢复包: 关闭
				流星飞锤: 关闭
				终极技能（集结号令）: 关闭
				能量盾击: 关闭
				近身攻击: 关闭
			}

			托比昂
			{
				主要攻击模式: 关闭
				热力过载: 关闭
				终极技能（熔火核心）: 关闭
				辅助攻击模式: 关闭
				近身攻击: 关闭
				部署炮台: 关闭
			}

			末日铁拳
			{
				上勾重拳: 关闭
				主要攻击模式: 关闭
				火箭重拳: 关闭
				终极技能（毁天灭地）: 关闭
				裂地重拳: 关闭
				近身攻击: 关闭
			}

			查莉娅
			{
				主要攻击模式: 关闭
				投射屏障: 关闭
				无需装弹: 开启
				粒子屏障: 关闭
				辅助攻击模式: 关闭
				近身攻击: 关闭
			}

			死神
			{
				主要攻击模式: 关闭
				幽灵形态: 关闭
				暗影步: 关闭
				终极技能（死亡绽放）: 关闭
				近身攻击: 关闭
			}

			法老之鹰
			{
				主要攻击模式: 关闭
				悬浮背包: 关闭
				推进背包: 关闭
				终极技能（火箭弹幕）: 关闭
				近身攻击: 关闭
				震荡冲击: 关闭
			}

			温斯顿
			{
				主要攻击模式: 关闭
				喷射背包: 关闭
				屏障发射器: 关闭
				终极技能（原始暴怒）: 关闭
				近身攻击: 关闭
			}

			源氏
			{
				主要攻击模式: 关闭
				影: 关闭
				终极技能（斩）: 关闭
				辅助攻击模式: 关闭
				近身攻击: 关闭
				闪: 关闭
			}

			狂鼠
			{
				主要攻击模式: 关闭
				捕兽夹: 关闭
				终极技能（炸弹轮胎）: 关闭
				近身攻击: 关闭
				震荡地雷: 关闭
			}

			猎空
			{
				主要攻击模式: 关闭
				终极技能（脉冲炸弹）: 关闭
				近身攻击: 关闭
				闪回: 关闭
				闪现: 关闭
			}

			破坏球
			{
				主要攻击模式: 关闭
				动力铁球: 关闭
				工程抓钩: 关闭
				感应护盾: 关闭
				终极技能（地雷禁区）: 关闭
				近身攻击: 关闭
				重力坠击: 关闭
			}

			禅雅塔
			{
				主要攻击模式: 关闭
				乱: 关闭
				谐: 关闭
				辅助攻击模式: 关闭
				近身攻击: 关闭
			}

			秩序之光
			{
				主要攻击模式: 关闭
				传送面板: 关闭
				哨戒炮: 关闭
				终极技能（光子屏障）: 关闭
				辅助攻击模式: 关闭
				近身攻击: 关闭
			}

			美
			{
				主要攻击模式: 关闭
				冰墙: 关闭
				急冻: 关闭
				终极技能（暴雪）: 关闭
				辅助攻击模式: 关闭
				近身攻击: 关闭
			}

			艾什
			{
				主要攻击模式: 关闭
				延时雷管: 关闭
				短筒猎枪: 关闭
				终极技能（召唤鲍勃）: 关闭
				近身攻击: 关闭
			}

			莫伊拉
			{
				主要攻击模式: 关闭
				消散: 关闭
				生化之球: 关闭
				终极技能（聚合射线）: 关闭
				辅助攻击模式: 关闭
				近身攻击: 关闭
			}

			莱因哈特
			{
				主要攻击模式: 关闭
				冲锋: 关闭
				屏障力场: 关闭
				烈焰打击: 关闭
				终极技能（裂地猛击）: 关闭
				近身攻击: 关闭
			}

			西格玛
			{
				主要攻击模式: 关闭
				动能俘获: 关闭
				实验屏障: 关闭
				终极技能（引力乱流）: 关闭
				质量吸附: 关闭
				近身攻击: 关闭
			}

			路霸
			{
				主要攻击模式: 关闭
				呼吸器: 关闭
				终极技能（鸡飞狗跳）: 关闭
				辅助攻击模式: 关闭
				近身攻击: 关闭
				链钩: 关闭
			}

			麦克雷
			{
				主要攻击模式: 关闭
				战术翻滚: 关闭
				终极技能（神射手）: 关闭
				辅助攻击模式: 关闭
				近身攻击: 关闭
				闪光弹: 关闭
			}

			黑影
			{
				主要攻击模式: 关闭
				位移传动: 关闭
				终极技能（电磁脉冲）: 关闭
				近身攻击: 关闭
				隐秘潜行: 关闭
				黑客入侵: 关闭
			}

			黑百合
			{
				主要攻击模式: 关闭
				剧毒诡雷: 关闭
				抓钩: 关闭
				终极技能（红外侦测）: 关闭
				近身攻击: 关闭
			}

			禁用英雄
			{
				半藏
				破坏球
				西格玛
			}
		}
	}
}

变量
{
	全局:
		26: AA

	玩家:
		26: AA
}

规则("// copy and paste the following line into the game title: *")
{
	事件
	{
		持续 - 全局;
	}
}

规则("WHERE IS IT? ★ Gibraltar ★ No limits")
{
	事件
	{
		持续 - 全局;
	}
}

规则("// all maps and additional info: bit.do/whereisit")
{
	事件
	{
		持续 - 全局;
	}
}

规则("// \"WHERE IS IT?\" ver. 1.4")
{
	事件
	{
		持续 - 全局;
	}
}

规则("// original mode is made by Foren#2660")
{
	事件
	{
		持续 - 全局;
	}
}

规则("all objects *")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.N = 0;
		全局.N += 1;
		全局.C[全局.N] = 矢量(12.371, 7.510, -152.801);
		全局.D[全局.N] = 矢量(12.840, 7.505, -152.336);
		全局.N += 1;
		全局.C[全局.N] = 矢量(-8.391, 2.832, -155.124);
		全局.D[全局.N] = 矢量(-8.327, 1.665, -155.186);
		全局.N += 1;
		全局.C[全局.N] = 矢量(31.694, -10.567, -90.727);
		全局.D[全局.N] = 矢量(31.444, -10.543, -90.354);
		全局.N += 1;
		全局.C[全局.N] = 矢量(61.780, -7.121, -35.642);
		全局.D[全局.N] = 矢量(61.398, -7.120, -36.023);
		全局.N += 1;
		全局.C[全局.N] = 矢量(88.224, -1.867, 3.143);
		全局.D[全局.N] = 矢量(87.732, -2.210, 3.110);
		全局.N += 1;
		全局.C[全局.N] = 矢量(43.520, -5.831, -165.135);
		全局.D[全局.N] = 矢量(43.606, -5.782, -164.789);
		全局.N += 1;
		全局.C[全局.N] = 矢量(17.820, 7.808, -154.945);
		全局.D[全局.N] = 矢量(17.951, 7.853, -155.060);
		全局.N += 1;
		全局.C[全局.N] = 矢量(24.313, 0.999, -16.474);
		全局.D[全局.N] = 矢量(24.207, 1.423, -16.370);
		全局.N += 1;
		全局.C[全局.N] = 矢量(-3.982, 0.046, -169.212);
		全局.D[全局.N] = 矢量(-3.825, 1.242, -169.573);
		全局.N += 1;
		全局.C[全局.N] = 矢量(101.823, 1.138, -5.720);
		全局.D[全局.N] = 矢量(101.422, 1.211, -5.323);
		全局.N += 1;
		全局.C[全局.N] = 矢量(25.681, -3.378, -73.142);
		全局.D[全局.N] = 矢量(25.656, -4.458, -73.117);
		全局.N += 1;
		全局.C[全局.N] = 矢量(21.861, 4.035, -112.228);
		全局.D[全局.N] = 矢量(22.099, 4.198, -112.444);
		全局.N += 1;
		全局.C[全局.N] = 矢量(6.611, 0.881, -157.959);
		全局.D[全局.N] = 矢量(6.729, 0.865, -158.051);
		全局.N += 1;
		全局.C[全局.N] = 矢量(81.490, -2.899, -45.140);
		全局.D[全局.N] = 矢量(83.250, -1.998, -43.530);
		全局.N += 1;
		全局.C[全局.N] = 矢量(66.579, 7.583, -44.340);
		全局.D[全局.N] = 矢量(66.326, 7.871, -44.268);
		全局.N += 1;
		全局.C[全局.N] = 矢量(12.626, 7.247, -155.552);
		全局.D[全局.N] = 矢量(12.509, 6.920, -155.456);
		全局.N += 1;
		全局.C[全局.N] = 矢量(19.945, -10.729, -105.478);
		全局.D[全局.N] = 矢量(19.941, -10.440, -105.559);
		全局.N += 1;
		全局.C[全局.N] = 矢量(68.250, -2.034, -19.831);
		全局.D[全局.N] = 矢量(68.597, -2.050, -19.457);
		全局.N += 1;
		全局.C[全局.N] = 矢量(4.110, 0.077, -152.809);
		全局.D[全局.N] = 矢量(4.498, 0.228, -152.867);
		全局.N += 1;
		全局.C[全局.N] = 矢量(60.933, -7.955, -35.539);
		全局.D[全局.N] = 矢量(60.941, -8.406, -35.190);
		全局.N += 1;
		全局.C[全局.N] = 矢量(10.074, -0.137, -156.449);
		全局.D[全局.N] = 矢量(10.357, -0.043, -156.478);
		全局.N += 1;
		全局.C[全局.N] = 矢量(57.337, 4.665, -46.787);
		全局.D[全局.N] = 矢量(57.050, 4.736, -46.489);
		全局.N += 1;
		全局.C[全局.N] = 矢量(73.665, 2.639, 19.132);
		全局.D[全局.N] = 矢量(73.818, 2.632, 18.988);
		全局.N += 1;
		全局.C[全局.N] = 矢量(108.502, 4.951, -0.679);
		全局.D[全局.N] = 矢量(108.530, 3.931, -0.651);
		全局.N += 1;
		全局.C[全局.N] = 矢量(63.754, -8.487, 42.920);
		全局.D[全局.N] = 矢量(63.475, -8.820, 43.187);
		全局.N += 1;
		全局.C[全局.N] = 矢量(10.619, -1.360, -165.198);
		全局.D[全局.N] = 矢量(10.065, 0.365, -167.077);
		全局.N += 1;
		全局.C[全局.N] = 矢量(47.666, -3.601, -56.612);
		全局.D[全局.N] = 矢量(47.322, -2.945, -56.002);
		全局.N += 1;
		全局.C[全局.N] = 矢量(0.931, 6.240, -166.840);
		全局.D[全局.N] = 矢量(1.322, 6.825, -167.241);
		全局.N += 1;
		全局.C[全局.N] = 矢量(51.974, 4.545, -48.550);
		全局.D[全局.N] = 矢量(52.124, 3.779, -48.555);
		全局.N += 1;
		全局.C[全局.N] = 矢量(35.467, -0.615, -156.172);
		全局.D[全局.N] = 矢量(35.660, -1.078, -156.078);
		全局.N += 1;
		全局.C[全局.N] = 矢量(49.820, 23.795, -139.243);
		全局.D[全局.N] = 矢量(50.305, 23.992, -138.950);
		全局.N += 1;
		全局.C[全局.N] = 矢量(-4.636, 1.214, -165.164);
		全局.D[全局.N] = 矢量(-4.923, 1.113, -165.292);
		全局.N += 1;
		全局.C[全局.N] = 矢量(-5.807, 3.977, -106.191);
		全局.D[全局.N] = 矢量(-5.944, 3.767, -105.747);
		全局.N += 1;
		全局.C[全局.N] = 矢量(59.117, -7.377, -24.092);
		全局.D[全局.N] = 矢量(59.053, -7.370, -24.029);
		全局.N += 1;
		全局.C[全局.N] = 矢量(37.467, 19.962, -156.179);
		全局.D[全局.N] = 矢量(37.492, 20.683, -157.176);
		全局.N += 1;
		全局.C[全局.N] = 矢量(43.587, -4.300, -55.991);
		全局.D[全局.N] = 矢量(43.369, -4.408, -56.108);
		全局.N += 1;
		全局.C[全局.N] = 矢量(-1.293, 10.164, -150.641);
		全局.D[全局.N] = 矢量(-1.202, 8.563, -150.412);
		全局.N += 1;
		全局.C[全局.N] = 矢量(41.875, -2.794, -2.783);
		全局.D[全局.N] = 矢量(41.970, -2.433, -3.364);
		全局.N += 1;
		全局.C[全局.N] = 矢量(28.090, -2.660, -128.102);
		全局.D[全局.N] = 矢量(28.412, -2.434, -128.426);
		全局.N += 1;
		全局.C[全局.N] = 矢量(78.624, -2.322, -8.177);
		全局.D[全局.N] = 矢量(78.260, -2.280, -7.972);
		全局.N += 1;
		全局.C[全局.N] = 矢量(72.594, -8.271, -49.264);
		全局.D[全局.N] = 矢量(72.811, -7.457, -49.479);
		全局.N += 1;
		全局.C[全局.N] = 矢量(92.632, 5.280, 50.508);
		全局.D[全局.N] = 矢量(92.681, 7.528, 50.575);
		全局.N += 1;
		全局.C[全局.N] = 矢量(35.173, -3.959, -137.800);
		全局.D[全局.N] = 矢量(34.676, -3.481, -137.816);
		全局.N += 1;
		全局.C[全局.N] = 矢量(92.588, 7.495, 76.456);
		全局.D[全局.N] = 矢量(95.574, 8.011, 76.499);
		全局.N += 1;
		全局.C[全局.N] = 矢量(49.347, -3.353, -141.417);
		全局.D[全局.N] = 矢量(49.152, -2.929, -141.622);
		全局.N += 1;
		全局.C[全局.N] = 矢量(20.504, 6.589, -34.522);
		全局.D[全局.N] = 矢量(20.654, 5.901, -34.375);
		全局.N += 1;
		全局.C[全局.N] = 矢量(50.116, 6.174, 32.684);
		全局.D[全局.N] = 矢量(50.071, 6.062, 32.550);
		全局.N += 1;
		全局.C[全局.N] = 矢量(-18.289, 1.802, -90.146);
		全局.D[全局.N] = 矢量(-18.954, 1.333, -91.785);
		全局.N += 1;
		全局.C[全局.N] = 矢量(61.241, 24.702, -53.836);
		全局.D[全局.N] = 矢量(61.069, 24.970, -53.667);
		全局.N += 1;
		全局.C[全局.N] = 矢量(6.676, 7.553, -166.362);
		全局.D[全局.N] = 矢量(7.007, 7.558, -166.667);
	}
}

规则("total number of objects")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.O = 全局.N;
	}
}

规则("beginning of the game *")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.K = 假;
		全局.V = 30;
		修改全局变量(J, 添加至数组, 5);
		修改全局变量(J, 添加至数组, 10);
		修改全局变量(J, 添加至数组, 15);
		修改全局变量(J, 添加至数组, 20);
		修改全局变量(J, 添加至数组, 25);
		修改全局变量(J, 添加至数组, 30);
		修改全局变量(J, 添加至数组, 35);
		修改全局变量(J, 添加至数组, 40);
		修改全局变量(J, 添加至数组, 45);
		修改全局变量(J, 添加至数组, 50);
		全局.Y = 30;
		全局.W = 假;
		全局.U = 假;
		全局.M = 假;
		全局.R[1] = 假;
		全局.R[3] = 0;
		全局.D[0] = 矢量(0, -50, 0);
		全局.AA = 3;
	}
}

规则("intro *")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.I == 真;
	}

	动作
	{
		设置状态(事件玩家, 无, 定身, 99);
		开始镜头(事件玩家, 矢量(228.022, -34.474, -186.594), 矢量(272.084, -17.998, -169.388), 0);
		等待(0.500, 无视条件);
		开始镜头(事件玩家, 矢量(228.022, -34.474, -186.594), 矢量(272.084, -17.998, -169.388), 0);
		传送(事件玩家, 矢量(75.506, -7.500, 38.671));
		等待(1, 无视条件);
		设置朝向(事件玩家, 矢量(0.720, 0, 0.680), 至地图);
		等待(1, 无视条件);
		设置状态(事件玩家, 无, 沉睡, 23);
		等待(4, 无视条件);
		开始镜头(事件玩家, 矢量(228.022, -34.474, -186.594), 矢量(272.084, -17.998, -169.388), 0);
		等待(2, 无视条件);
		
		开始镜头(事件玩家, 矢量(75.443, -1.056, 38.606), 矢量(74.982, -38.600, 38.141), 0);
		小字体信息(事件玩家, 字符串("{0} {1}", 字符串("欢迎"), 字符串("{0}！", 事件玩家)));
		等待(3, 无视条件);
		开始镜头(事件玩家, 矢量(75.395, -5.015, 38.557), 矢量(74.982, -38.600, 38.141), 1);
		等待(6, 无视条件);
		开始镜头(事件玩家, 矢量(46.425, -1.933, -112.620), 矢量(49.547, -2.002, -109.505), 0);
		等待(0.100, 无视条件);
		
		开始镜头(事件玩家, 矢量(2.256, -2.762, -65.143), 矢量(10.738, -3.047, -56.988), 0);
		等待(0.100, 无视条件);
		开始镜头(事件玩家, 矢量(28.642, -2.164, -69.577), 矢量(43.724, -1.574, -54.548), 0);
		等待(0.100, 无视条件);
		开始镜头(事件玩家, 矢量(78.254, -0.080, -20.233), 矢量(72.851, -0.013, -25.747), 0);
		等待(0.100, 无视条件);
		开始镜头(事件玩家, 矢量(89.994, 16.350, 47.973), 矢量(101.165, 16.918, 58.876), 0);
		等待(0.100, 无视条件);
		开始镜头(事件玩家, 矢量(79.770, -6.455, 36.906), 矢量(94.181, -5.759, 22.926), 0);
		等待(0.100, 无视条件);
		开始镜头(事件玩家, 矢量(30.524, -3.238, -79.672), 矢量(41.448, -3.055, -90.153), 0);
		等待(0.100, 无视条件);
		开始镜头(事件玩家, 矢量(44.799, -2.635, -154.444), 矢量(32.675, -2.400, -142.402), 0);
		等待(0.100, 无视条件);
		开始镜头(事件玩家, 矢量(46.425, -1.933, -112.620), 矢量(49.547, -2.002, -109.505), 0);
		等待(0.100, 无视条件);
		开始镜头(事件玩家, 矢量(2.256, -2.762, -65.143), 矢量(10.738, -3.047, -56.988), 0);
		等待(0.100, 无视条件);
		开始镜头(事件玩家, 矢量(28.642, -2.164, -69.577), 矢量(43.724, -1.574, -54.548), 0);
		等待(0.100, 无视条件);
		开始镜头(事件玩家, 矢量(78.254, -0.080, -20.233), 矢量(72.851, -0.013, -25.747), 0);
		等待(0.100, 无视条件);
		开始镜头(事件玩家, 矢量(79.770, -6.455, 36.906), 矢量(94.181, -5.759, 22.926), 0);
		等待(0.100, 无视条件);
		开始镜头(事件玩家, 矢量(89.994, 16.350, 47.973), 矢量(101.165, 16.918, 58.876), 0);
		等待(0.100, 无视条件);
		开始镜头(事件玩家, 矢量(30.524, -3.238, -79.672), 矢量(41.448, -3.055, -90.153), 0);
		等待(0.100, 无视条件);
		开始镜头(事件玩家, 矢量(46.425, -1.933, -112.620), 矢量(49.547, -2.002, -109.505), 0);
		等待(0.100, 无视条件);
		开始镜头(事件玩家, 矢量(2.256, -2.762, -65.143), 矢量(10.738, -3.047, -56.988), 0);
		等待(0.100, 无视条件);
		开始镜头(事件玩家, 矢量(89.994, 16.350, 47.973), 矢量(101.165, 16.918, 58.876), 0);
		等待(0.100, 无视条件);
		开始镜头(事件玩家, 矢量(28.642, -2.164, -69.577), 矢量(43.724, -1.574, -54.548), 0);
		等待(0.100, 无视条件);
		开始镜头(事件玩家, 矢量(78.254, -0.080, -20.233), 矢量(72.851, -0.013, -25.747), 0);
		等待(0.100, 无视条件);
		开始镜头(事件玩家, 矢量(30.524, -3.238, -79.672), 矢量(41.448, -3.055, -90.153), 0);
		等待(0.100, 无视条件);
		开始镜头(事件玩家, 矢量(2.256, -2.762, -65.143), 矢量(10.738, -3.047, -56.988), 0);
		等待(0.100, 无视条件);
		开始镜头(事件玩家, 矢量(79.770, -6.455, 36.906), 矢量(94.181, -5.759, 22.926), 0);
		等待(0.100, 无视条件);
		开始镜头(事件玩家, 矢量(46.425, -1.933, -112.620), 矢量(49.547, -2.002, -109.505), 0);
		等待(0.100, 无视条件);
		开始镜头(事件玩家, 矢量(30.524, -3.238, -79.672), 矢量(41.448, -3.055, -90.153), 0);
		等待(0.300, 无视条件);
		开始镜头(事件玩家, 矢量(28.642, -2.164, -69.577), 矢量(43.724, -1.574, -54.548), 0);
		等待(0.400, 无视条件);
		开始镜头(事件玩家, 矢量(78.254, -0.080, -20.233), 矢量(72.851, -0.013, -25.747), 0);
		等待(0.600, 无视条件);
		开始镜头(事件玩家, 矢量(2.256, -2.762, -65.143), 矢量(10.738, -3.047, -56.988), 0);
		等待(0.800, 无视条件);
		开始镜头(事件玩家, 矢量(79.770, -6.455, 36.906), 矢量(94.181, -5.759, 22.926), 0);
		等待(0.900, 无视条件);
		开始镜头(事件玩家, 矢量(89.994, 16.350, 47.973), 矢量(101.165, 16.918, 58.876), 0);
		等待(2, 无视条件);
		开始镜头(事件玩家, 矢量(82.363, 15.243, 41.428), 矢量(133.513, 22.510, 85.627), 0.300);
		等待(2, 无视条件);
		开始镜头(事件玩家, 矢量(74.084, -0.820, 31.972), 矢量(136.163, 78.743, 94.086), 0.300);
		小字体信息(事件玩家, 自定义字符串("Is This a Dream?"));
		等待(3, 无视条件);
		小字体信息(事件玩家, 自定义字符串("The rocket is waiting for you!"));
		等待(3, 无视条件);
		小字体信息(事件玩家, 自定义字符串("Complete the test to fly away"));
		等待(3, 无视条件);
		传送(事件玩家, 矢量(-21.465, 7.479, -159.683));
		事件玩家.I = 假;
		设置朝向(事件玩家, 矢量(0.970, 0, 0.240), 至地图);
		等待(1, 无视条件);
		停止镜头(事件玩家);
		事件玩家.T = 真;
		清除状态(事件玩家, 定身);
		事件玩家.M = 真;
		显示姓名板(事件玩家, 所有玩家(所有队伍));
		
	}
}

规则("outro *")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.Z == 1;
	}

	动作
	{
		事件玩家.Z = 2;
		事件玩家.W = 真;
		消除效果(事件玩家.E[5]);
		消除效果(事件玩家.E[6]);
		设置状态(事件玩家, 无, 定身, 9999);
		全局.W = 真;
		开始镜头(事件玩家, 矢量(92.128, 11.035, 42.375), 矢量(95.108, 15.259, 43.404), 0);
		交流(事件玩家, 倒计时);
		等待(1.500, 无视条件);
		开始镜头(事件玩家, 矢量(93.894, 68.861, 50.310), 矢量(93.893, 66.486, 51.715), 0);
		等待(1, 无视条件);
		开始镜头(事件玩家, 矢量(69.453, 1.552, 30.391), 矢量(90.836, 20.239, 48.722), 0);
		等待(1.500, 无视条件);
		开始镜头(事件玩家, 矢量(90.741, 13.041, 48.636), 矢量(90.799, 13.126, 48.698), 0);
		交流(事件玩家, 再见);
		等待(0.010, 无视条件);
		开始镜头(事件玩家, 矢量(90.741, 1.041, 48.636), 矢量(146.720, 83.192, 108.182), 1);
		等待(2.300, 无视条件);
		停止镜头(事件玩家);
		开始镜头(事件玩家, 矢量(88.052, 71.807, 53.272), 矢量(88.995, 72.686, 53.246), 0);
		等待(0.500, 无视条件);
		开始镜头(事件玩家, 矢量(88.052, 38.509, 53.272), 矢量(435.480, 362.247, 43.644), 3);
		播放效果(所有玩家(所有队伍), 环状爆炸声音, 颜色(白色), 矢量(88.052, 38.509, 53.272), 100);
		等待(1, 无视条件);
		停止镜头(事件玩家);
		开始镜头(事件玩家, 矢量(10.548, 2.900, -152.669), 矢量(11.946, 3.700, -152.310), 0);
		等待(0.010, 无视条件);
		开始镜头(事件玩家, 矢量(7.870, 2.373, -153.404), 矢量(13.243, 2.905, -151.877), 0.800);
		等待(2, 无视条件);
		停止镜头(事件玩家);
		开始镜头(事件玩家, 矢量(18.506, 7.072, -159.693), 矢量(25.446, 10.545, -163.212), 0.500);
		等待(1, 无视条件);
		播放效果(所有玩家(所有队伍), 有害选择效果 , 颜色(白色), 矢量(69.780, 55.255, -174.115), 50);
		等待(0.400, 无视条件);
		播放效果(所有玩家(所有队伍), 有害选择效果 , 颜色(白色), 矢量(69.780, 55.255, -174.115), 20);
		传送(事件玩家, 矢量(8.391, 84.122, -148.664));
		等待(2, 无视条件);
		开始镜头(事件玩家, 矢量(16.761, 85.609, -161.454), 矢量(16.630, 80.615, -161.250), 0);
		等待(0.010, 无视条件);
		小字体信息(事件玩家, 自定义字符串("Somewhere in Space"));
		设置朝向(事件玩家, 矢量(0.950, 0.180, -0.250), 至地图);
		
		开始镜头(事件玩家, 矢量(14.083, 92.911, -157.608), 矢量(10.920, 70.290, -153.054), 0.900);
		等待(3, 无视条件);
		开始镜头(事件玩家, 矢量(13.146, 93.996, -156.076), 矢量(9.367, 83.551, -150.235), 0.900);
		等待(1, 无视条件);
		开始镜头(事件玩家, 矢量(9.294, 84.078, -149.972), 矢量(4.058, 82.670, -142.293), 0.700);
		等待(5, 无视条件);
		交流(事件玩家, 表情（上）);
		大字体信息(所有玩家(所有队伍), 字符串("{0} {1} {2}", 英雄图标字符串(所用英雄(事件玩家)), 事件玩家, 字符串("{0}！", 字符串("胜者"))));
		设置慢动作(30);
		等待(3, 无视条件);
		设置慢动作(100);
		停止镜头(事件玩家);
		开始镜头(事件玩家, 矢量(7.515, 91.939, -155.421), 矢量(8.351, 90.586, -155.408), 0);
		等待(0.100, 无视条件);
		开始镜头(事件玩家, 矢量(3.119, 91.053, -148.258), 矢量(10.809, 78.595, -148.141), 0.700);
		等待(4, 无视条件);
		全局.K = 假;
		停止镜头(事件玩家);
		大字体信息(事件玩家, 字符串("{0}！", 字符串("恭喜")));
		全局.W = 假;
		事件玩家.Z = 3;
		清除状态(事件玩家, 定身);
		等待(10, 无视条件);
		播放效果(事件玩家, 状态爆炸声音, 颜色(白色), 事件玩家, 10);
		消除HUD文本(事件玩家.AA);
		等待(0.250, 无视条件);
		创建HUD文本(事件玩家, 图标字符串(对号), 自定义字符串("Try other maps!"), 自定义字符串("bit.do/whereisit "), 顶部, 1, 颜色(灰绿色), 颜色(白色), 颜色(灰绿色), 字符串, 默认可见度);
		事件玩家.AA = 上一个文本ID;
		等待(90, 无视条件);
		事件玩家.W = 假;
		If(事件玩家.Z == 3);
			传送(事件玩家, 矢量(-13.828, 1.477, -160.667));
		End;
		事件玩家.Z = 0;
		消除效果(事件玩家.E[3]);
		消除效果(事件玩家.E[4]);
		禁用 小字体信息(事件玩家, 字符串("{0} {1}", 事件玩家, 字符串("不可见")));
	}
}

规则("outro 2 *")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.Z == 3;
		相距距离(矢量(8.894, 83.467, -154.150), 事件玩家) > 10;
	}

	动作
	{
		传送(事件玩家, 矢量(66.018, -7.720, -35.434));
		事件玩家.Z = 0;
		小字体信息(事件玩家, 自定义字符串("Wake up!"));
	}
}

规则("outro 3 *")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		创建效果(所有玩家(所有队伍), 球体, 自定义颜色(255, 200, 180, 255), 矢量(8.894, 83.467, -154.150), 12, 可见，位置和半径);
		创建效果(所有玩家(所有队伍), 球体, 自定义颜色(255, 200, 180, 255), 矢量(8.894, 83.467, -154.150), 12, 可见，位置和半径);
		创建效果(所有玩家(所有队伍), 球体, 自定义颜色(255, 200, 180, 255), 矢量(8.894, 83.467, -154.150), 12, 可见，位置和半径);
		创建效果(所有玩家(所有队伍), 球体, 自定义颜色(255, 200, 180, 255), 矢量(8.894, 83.467, -154.150), 12, 可见，位置和半径);
		创建效果(所有玩家(所有队伍), 球体, 自定义颜色(255, 200, 180, 255), 矢量(8.894, 83.467, -154.150), 12, 可见，位置和半径);
		创建效果(所有玩家(所有队伍), 球体, 自定义颜色(255, 200, 180, 255), 矢量(8.894, 83.467, -154.150), 12, 可见，位置和半径);
		创建效果(所有玩家(所有队伍), 球体, 自定义颜色(255, 200, 180, 255), 矢量(8.894, 83.467, -154.150), 12, 可见，位置和半径);
		创建效果(所有玩家(所有队伍), 球体, 自定义颜色(255, 200, 180, 255), 矢量(8.894, 83.467, -154.150), 12, 可见，位置和半径);
		创建效果(所有玩家(所有队伍), 球体, 自定义颜色(255, 200, 180, 255), 矢量(8.894, 83.467, -154.150), 12, 可见，位置和半径);
		创建效果(所有玩家(所有队伍), 球体, 自定义颜色(255, 200, 180, 255), 矢量(8.894, 83.467, -154.150), 12, 可见，位置和半径);
		创建效果(所有玩家(所有队伍), 球体, 自定义颜色(255, 200, 180, 255), 矢量(8.894, 83.467, -154.150), 12, 可见，位置和半径);
		创建效果(所有玩家(所有队伍), 球体, 自定义颜色(255, 200, 180, 255), 矢量(8.894, 83.467, -154.150), 12, 可见，位置和半径);
		创建效果(所有玩家(所有队伍), 信标声音, 颜色(白色), 矢量(11.267, 90.137, -152.375), 70, 可见，位置和半径);
	}
}

规则("player spawn *")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
		是否是机器人(事件玩家) == 假;
	}

	动作
	{
		隐藏游戏模式HUD(事件玩家);
		隐藏英雄HUD(事件玩家);
		隐藏姓名板(事件玩家, 所有玩家(所有队伍));
		开始强制设置玩家轮廓(事件玩家, 所有玩家(所有队伍), 假, 颜色(白色), 默认);
		事件玩家.F = 0;
		传送(事件玩家, 矢量(30.240, -3.638, -143.112));
		设置启用技能 1(事件玩家, 假);
		设置启用技能 2(事件玩家, 假);
		事件玩家.I = 真;
		事件玩家.G = 5;
		事件玩家.N = 1;
		事件玩家.U = 假;
		事件玩家.V = 假;
		事件玩家.R = 假;
		事件玩家.W = 假;
		事件玩家.O = 假;
		事件玩家.Z = 0;
		事件玩家.X = 假;
		事件玩家.L = 假;
		根据条件跳过(全局.R[2] >= 3, 2);
		全局.R[2] += 1;
		全局.R[1] = 真;
		创建效果(事件玩家, 有益光环, 颜色(橙色), 全局.D[事件玩家.F], 2, 可见，位置和半径);
		事件玩家.E[5] = 最后创建的实体;
		创建效果(事件玩家, 火花, 颜色(橙色), 全局.D[事件玩家.F], 3, 可见，位置和半径);
		事件玩家.E[6] = 最后创建的实体;
		创建HUD文本(事件玩家, 字符串("{0} {1}", 图标字符串(方块), 事件玩家.N), 无, 无, 左边, 1, 颜色(橙色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		事件玩家.E[7] = 最后创建的实体;
		创建HUD文本(事件玩家, 无, 无, 字符串("对象"), 左边, 0, 颜色(白色), 颜色(白色), 颜色(橙色), 可见和字符串, 默认可见度);
		事件玩家.E[8] = 最后创建的实体;
		
		设置状态(事件玩家, 无, 无敌, 9999);
		事件玩家.S = 150;
		根据条件跳过(全局.L[1] != 无, 2);
		全局.L[1] = 事件玩家;
		中止;
		根据条件跳过(全局.L[2] != 无, 2);
		全局.L[2] = 事件玩家;
		中止;
		根据条件跳过(全局.L[3] != 无, 2);
		全局.L[3] = 事件玩家;
		中止;
	}
}

规则("infinite match time")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		比赛时间 <= 1800;
	}

	动作
	{
		设置比赛时间(3600);
	}
}

规则("player pressed \"F\" key on the empty place")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(互动)) == 真;
		相距距离(事件玩家, 全局.D[事件玩家.F]) > 5;
		相距距离(事件玩家, 全局.D[事件玩家.F + 1]) > 5;
		事件玩家.I == 假;
		事件玩家.T == 假;
		具有状态(事件玩家, 冰冻) == 假;
		事件玩家.F < 全局.O;
		全局.K == 假;
		事件玩家.X == 假;
	}

	动作
	{
		小字体信息(事件玩家, 字符串("{0} {1}", 字符串("否"), 字符串("物品")));
		播放效果(事件玩家, 负面状态施加声音, 颜色(白色), 事件玩家, 30);
		设置状态(事件玩家, 无, 冰冻, 1);
	}
}

规则("player found item")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(互动)) == 真;
		相距距离(事件玩家, 全局.D[事件玩家.F + 1]) <= 5;
		具有状态(事件玩家, 冰冻) == 假;
		事件玩家.F < 全局.O;
		全局.K == 假;
		事件玩家.X == 假;
	}

	动作
	{
		小字体信息(事件玩家, 字符串("{0}！", 字符串("好")));
		播放效果(事件玩家, 环状爆炸, 颜色(橙色), 全局.D[事件玩家.F + 1], 5);
		播放效果(事件玩家, 环状爆炸, 颜色(橙色), 全局.D[事件玩家.F + 1], 7);
		播放效果(事件玩家, 正面状态施加声音, 颜色(白色), 事件玩家, 50);
		事件玩家.F += 1;
		事件玩家.K = 3;
		事件玩家.U = 真;
		事件玩家.G = 10;
		根据条件跳过(事件玩家.F == 全局.J[10], 11);
		根据条件跳过(事件玩家.F == 全局.J[9], 10);
		根据条件跳过(事件玩家.F == 全局.J[8], 9);
		根据条件跳过(事件玩家.F == 全局.J[7], 8);
		根据条件跳过(事件玩家.F == 全局.J[6], 7);
		根据条件跳过(事件玩家.F == 全局.J[5], 6);
		根据条件跳过(事件玩家.F == 全局.J[4], 5);
		根据条件跳过(事件玩家.F == 全局.J[3], 4);
		根据条件跳过(事件玩家.F == 全局.J[2], 3);
		根据条件跳过(事件玩家.F == 全局.J[1], 2);
		事件玩家.U = 假;
		事件玩家.T = 真;
		等待(1, 无视条件);
		播放效果(事件玩家, 正面状态施加声音, 颜色(白色), 事件玩家, 50);
		大字体信息(事件玩家, 字符串("{0} / {1}", 事件玩家.F, 全局.O));
		根据条件跳过(事件玩家.F != 2, 1);
		事件玩家.R = 真;
		根据条件跳过(事件玩家.F < 全局.O, 1);
		事件玩家.N = 事件玩家.F;
		根据条件跳过(事件玩家.F == 全局.O, 1);
		事件玩家.N = 事件玩家.F + 1;
	}
}

规则("shift key is pressed (acceleration)")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(技能1)) == 真;
	}

	动作
	{
		设置移动速度(事件玩家, 事件玩家.S);
	}
}

规则("shift key is not pressed (slowdown)")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(技能1)) == 假;
	}

	动作
	{
		设置移动速度(事件玩家, 110);
	}
}

规则("spacebar is pressed (fly)")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(跳跃)) == 真;
		事件玩家.F >= 全局.Y;
	}

	动作
	{
		设置引力(事件玩家, 0);
	}
}

规则("spacebar is not pressed (gravity)")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(跳跃)) == 假;
		事件玩家.F >= 全局.Y;
	}

	动作
	{
		设置引力(事件玩家, 100);
	}
}

规则("right click shows picture")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(辅助攻击模式)) == 真;
		事件玩家.I == 假;
		事件玩家.Z == 0;
		事件玩家.X == 假;
	}

	动作
	{
		根据条件跳过(事件玩家.F < 全局.O, 1);
		事件玩家.N = 事件玩家.F;
		根据条件跳过(事件玩家.F == 全局.O, 1);
		事件玩家.N = 事件玩家.F + 1;
		开始镜头(事件玩家, 全局.C[事件玩家.N], 全局.D[事件玩家.N], 0);
		事件玩家.T = 假;
		根据条件跳过(事件玩家.U == 假, 1);
		事件玩家.O = 真;
		根据条件跳过(事件玩家.G > 0, 3);
		根据条件跳过(相距距离(所选位置(事件玩家), 全局.D[事件玩家.F + 1]) < 50, 1);
		小字体信息(事件玩家, 字符串("{0} {1} {2}", 字符串("对象"), 字符串("远"), 图标字符串(停止)));
		事件玩家.G = 1;
	}
}

规则("right mouse button is not pressed")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(辅助攻击模式)) == 假;
		事件玩家.I == 假;
		事件玩家.Z == 0;
		事件玩家.X == 假;
	}

	动作
	{
		停止镜头(事件玩家);
		清除状态(事件玩家, 定身);
		根据条件跳过(事件玩家.U == 假, 1);
		事件玩家.O = 真;
		根据条件跳过(事件玩家.F < 全局.O, 1);
		事件玩家.N = 事件玩家.F;
		根据条件跳过(事件玩家.F == 全局.O, 1);
		事件玩家.N = 事件玩家.F + 1;
	}
}

规则("left mouse button shows previous objects")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(主要攻击模式)) == 真;
		按钮被按下(事件玩家, 按钮(辅助攻击模式)) == 真;
		事件玩家.I == 假;
		事件玩家.X == 假;
		事件玩家.Z == 0;
	}

	动作
	{
		事件玩家.N -= 1;
		根据条件跳过(事件玩家.N > 0, 4);
		根据条件跳过(事件玩家.F == 全局.O, 1);
		事件玩家.N = 事件玩家.F + 1;
		根据条件跳过(事件玩家.F != 全局.O, 1);
		事件玩家.N = 事件玩家.F;
	}
}

规则("teleport cooldown")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.B == 真;
	}

	动作
	{
		等待(2, 无视条件);
		事件玩家.B = 假;
		等待(0.500, 无视条件);
		如条件为”真“则循环;
	}
}

规则("teleports Team 2 *")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.P[1] = 矢量(-2.164, -0.450, -97.629);
		创建效果(所有玩家(队伍2), 环, 颜色(蓝色), 全局.P[1], 1.500, 可见);
		全局.P[2] = 矢量(-5.115, -0.450, -100.466);
		创建效果(所有玩家(队伍2), 环, 颜色(蓝色), 全局.P[2], 1.300, 可见);
		全局.P[3] = 矢量(3.437, -3.450, -69.296);
		创建效果(所有玩家(队伍2), 环, 颜色(蓝色), 全局.P[3], 1.300, 可见);
		全局.P[4] = 矢量(59.782, 1.738, 51.155);
		创建效果(所有玩家(队伍2), 环, 颜色(蓝色), 全局.P[4], 1.200, 可见);
		全局.P[5] = 矢量(63.156, -3.450, -58.070);
		创建效果(所有玩家(队伍2), 环, 颜色(蓝色), 全局.P[5], 1.200, 可见);
		全局.P[6] = 矢量(65.747, -4.249, -55.336);
		创建效果(所有玩家(队伍2), 环, 颜色(蓝色), 全局.P[6], 1.300, 可见);
		全局.P[7] = 矢量(43.277, -4.352, -32.575);
		创建效果(所有玩家(队伍2), 环, 颜色(蓝色), 全局.P[7], 1.300, 可见);
		禁用 全局.P[8] = 矢量(-72.929, 3.298, 159.971);
		禁用 创建效果(所有玩家(队伍2), 环, 颜色(蓝色), 全局.P[8], 1.500, 可见);
		全局.P[9] = 矢量(53.248, -1.428, -17.279);
		创建效果(所有玩家(队伍2), 环, 颜色(蓝色), 全局.P[9], 1.500, 可见);
		全局.P[10] = 矢量(50.173, -1.450, -14.172);
		创建效果(所有玩家(队伍2), 环, 颜色(蓝色), 全局.P[10], 1.400, 可见);
		全局.P[11] = 矢量(92.289, -1.478, -7.548);
		创建效果(所有玩家(队伍2), 环, 颜色(蓝色), 全局.P[11], 1.300, 可见);
		全局.P[12] = 矢量(95.401, -0.450, -4.390);
		创建效果(所有玩家(队伍2), 环, 颜色(蓝色), 全局.P[12], 1.300, 可见);
		全局.P[13] = 矢量(90.771, 0.606, 31.726);
		创建效果(所有玩家(队伍2), 环, 颜色(蓝色), 全局.P[13], 1.500, 可见);
		全局.P[14] = 矢量(93.865, -0.299, 28.719);
		创建效果(所有玩家(队伍2), 环, 颜色(蓝色), 全局.P[14], 1.300, 可见);
	}
}

规则("teleport 1")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.B == 假;
		全局.P[1] != 0;
		相距距离(事件玩家, 全局.P[1]) <= 2;
	}

	动作
	{
		传送(事件玩家, 全局.P[2]);
		事件玩家.B = 真;
		播放效果(事件玩家, 有益爆炸, 颜色(蓝色), 事件玩家, 5);
		播放效果(事件玩家, 环状爆炸声音, 颜色(白色), 事件玩家, 20);
	}
}

规则("teleport 2")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.B == 假;
		全局.P[2] != 0;
		相距距离(事件玩家, 全局.P[2]) <= 2;
	}

	动作
	{
		传送(事件玩家, 全局.P[1]);
		事件玩家.B = 真;
		播放效果(事件玩家, 有益爆炸, 颜色(蓝色), 事件玩家, 5);
		播放效果(事件玩家, 环状爆炸声音, 颜色(白色), 事件玩家, 20);
	}
}

规则("teleport 3 *")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.B == 假;
		全局.P[3] != 0;
		相距距离(事件玩家, 全局.P[3]) <= 2;
	}

	动作
	{
		传送(事件玩家, 矢量(6.283, -3.450, -72.101));
		事件玩家.B = 真;
		播放效果(事件玩家, 有益爆炸, 颜色(蓝色), 事件玩家, 5);
		播放效果(事件玩家, 环状爆炸声音, 颜色(白色), 事件玩家, 20);
	}
}

规则("teleport 4 *")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.B == 假;
		全局.P[4] != 0;
		相距距离(事件玩家, 全局.P[4]) <= 2;
	}

	动作
	{
		传送(事件玩家, 矢量(62.848, 2.550, 48.364));
		事件玩家.B = 真;
		播放效果(事件玩家, 有益爆炸, 颜色(蓝色), 事件玩家, 5);
		播放效果(事件玩家, 环状爆炸声音, 颜色(白色), 事件玩家, 20);
	}
}

规则("teleport 5")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.B == 假;
		全局.P[5] != 0;
		相距距离(事件玩家, 全局.P[5]) <= 2;
	}

	动作
	{
		传送(事件玩家, 全局.P[6]);
		事件玩家.B = 真;
		播放效果(事件玩家, 有益爆炸, 颜色(蓝色), 事件玩家, 5);
		播放效果(事件玩家, 环状爆炸声音, 颜色(白色), 事件玩家, 20);
	}
}

规则("teleport 6")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.B == 假;
		全局.P[6] != 0;
		相距距离(事件玩家, 全局.P[6]) <= 2;
	}

	动作
	{
		传送(事件玩家, 全局.P[5]);
		事件玩家.B = 真;
		播放效果(事件玩家, 有益爆炸, 颜色(蓝色), 事件玩家, 5);
		播放效果(事件玩家, 环状爆炸声音, 颜色(白色), 事件玩家, 20);
	}
}

规则("teleport 7 *")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.B == 假;
		全局.P[7] != 0;
		相距距离(事件玩家, 全局.P[7]) <= 2;
	}

	动作
	{
		传送(事件玩家, 矢量(40.804, -3.462, -35.071));
		事件玩家.B = 真;
		播放效果(事件玩家, 有益爆炸, 颜色(蓝色), 事件玩家, 5);
		播放效果(事件玩家, 环状爆炸声音, 颜色(白色), 事件玩家, 20);
	}
}

规则("teleport 9")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.B == 假;
		全局.P[9] != 0;
		相距距离(事件玩家, 全局.P[9]) <= 2;
	}

	动作
	{
		传送(事件玩家, 全局.P[10]);
		事件玩家.B = 真;
		播放效果(事件玩家, 有益爆炸, 颜色(蓝色), 事件玩家, 5);
		播放效果(事件玩家, 环状爆炸声音, 颜色(白色), 事件玩家, 20);
	}
}

规则("teleport 10")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.B == 假;
		全局.P[10] != 0;
		相距距离(事件玩家, 全局.P[10]) <= 2;
	}

	动作
	{
		传送(事件玩家, 全局.P[9]);
		事件玩家.B = 真;
		播放效果(事件玩家, 有益爆炸, 颜色(蓝色), 事件玩家, 5);
		播放效果(事件玩家, 环状爆炸声音, 颜色(白色), 事件玩家, 20);
	}
}

规则("teleport 11")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.B == 假;
		全局.P[11] != 0;
		相距距离(事件玩家, 全局.P[11]) <= 2;
	}

	动作
	{
		传送(事件玩家, 全局.P[12]);
		事件玩家.B = 真;
		播放效果(事件玩家, 有益爆炸, 颜色(蓝色), 事件玩家, 5);
		播放效果(事件玩家, 环状爆炸声音, 颜色(白色), 事件玩家, 20);
	}
}

规则("teleport 12")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.B == 假;
		全局.P[12] != 0;
		相距距离(事件玩家, 全局.P[12]) <= 2;
	}

	动作
	{
		传送(事件玩家, 全局.P[11]);
		事件玩家.B = 真;
		播放效果(事件玩家, 有益爆炸, 颜色(蓝色), 事件玩家, 5);
		播放效果(事件玩家, 环状爆炸声音, 颜色(白色), 事件玩家, 20);
	}
}

规则("teleport 13")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.B == 假;
		全局.P[13] != 0;
		相距距离(事件玩家, 全局.P[13]) <= 2;
	}

	动作
	{
		传送(事件玩家, 全局.P[14]);
		事件玩家.B = 真;
		播放效果(事件玩家, 有益爆炸, 颜色(蓝色), 事件玩家, 5);
		播放效果(事件玩家, 环状爆炸声音, 颜色(白色), 事件玩家, 20);
	}
}

规则("teleport 14")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.B == 假;
		全局.P[14] != 0;
		相距距离(事件玩家, 全局.P[14]) <= 2;
	}

	动作
	{
		传送(事件玩家, 全局.P[13]);
		事件玩家.B = 真;
		播放效果(事件玩家, 有益爆炸, 颜色(蓝色), 事件玩家, 5);
		播放效果(事件玩家, 环状爆炸声音, 颜色(白色), 事件玩家, 20);
	}
}

规则("player found all objects (victory!)")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.F == 全局.O;
	}

	动作
	{
		事件玩家.Z = 5;
		设置状态(事件玩家, 无, 定身, 9999);
		播放效果(事件玩家, 环状爆炸声音, 颜色(白色), 事件玩家, 30);
		播放效果(事件玩家, 环状爆炸, 颜色(亮紫色), 全局.D[事件玩家.F], 6);
		播放效果(事件玩家, 有益爆炸, 颜色(橙色), 全局.D[事件玩家.F], 10);
		播放效果(事件玩家, 有益选择效果 , 颜色(橙色), 全局.D[事件玩家.F], 10);
		全局.K = 真;
		等待(3, 无视条件);
		事件玩家.Z = 1;
	}
}

规则("everyone is watching the winner *")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.W == 假;
		事件玩家.Z == 0;
		全局.W == 真;
		事件玩家.F >= 2;
	}

	动作
	{
		设置状态(事件玩家, 无, 定身, 9999);
		事件玩家.X = 真;
		开始镜头(事件玩家, 矢量(92.128, 11.035, 42.375), 矢量(95.108, 15.259, 43.404), 0);
		等待(1.500, 无视条件);
		开始镜头(事件玩家, 矢量(93.894, 68.861, 50.310), 矢量(93.893, 66.486, 51.715), 0);
		等待(1, 无视条件);
		开始镜头(事件玩家, 矢量(69.453, 1.552, 30.391), 矢量(90.836, 20.239, 48.722), 0);
		等待(1.500, 无视条件);
		开始镜头(事件玩家, 矢量(90.741, 13.041, 48.636), 矢量(90.799, 13.126, 48.698), 0);
		等待(0.010, 无视条件);
		开始镜头(事件玩家, 矢量(90.741, 1.041, 48.636), 矢量(146.720, 83.192, 108.182), 1);
		等待(2.300, 无视条件);
		停止镜头(事件玩家);
		开始镜头(事件玩家, 矢量(88.052, 71.807, 53.272), 矢量(88.995, 72.686, 53.246), 0);
		等待(0.500, 无视条件);
		开始镜头(事件玩家, 矢量(88.052, 38.509, 53.272), 矢量(435.480, 362.247, 43.644), 3);
		等待(1, 无视条件);
		停止镜头(事件玩家);
		开始镜头(事件玩家, 矢量(10.548, 2.900, -152.669), 矢量(11.946, 3.700, -152.310), 0);
		等待(0.010, 无视条件);
		开始镜头(事件玩家, 矢量(7.870, 2.373, -153.404), 矢量(13.243, 2.905, -151.877), 0.800);
		等待(2, 无视条件);
		停止镜头(事件玩家);
		开始镜头(事件玩家, 矢量(18.506, 7.072, -159.693), 矢量(25.446, 10.545, -163.212), 0.500);
		等待(1, 无视条件);
		等待(0.400, 无视条件);
		等待(2, 无视条件);
		开始镜头(事件玩家, 矢量(16.761, 85.609, -161.454), 矢量(16.630, 80.615, -161.250), 0);
		等待(0.010, 无视条件);
		小字体信息(事件玩家, 自定义字符串("Somewhere in Space"));
		开始镜头(事件玩家, 矢量(14.083, 92.911, -157.608), 矢量(10.920, 70.290, -153.054), 0.900);
		等待(3, 无视条件);
		开始镜头(事件玩家, 矢量(13.146, 93.996, -156.076), 矢量(9.367, 83.551, -150.235), 0.900);
		等待(1, 无视条件);
		开始镜头(事件玩家, 矢量(9.294, 84.078, -149.972), 矢量(4.058, 82.670, -142.293), 0.700);
		等待(5, 无视条件);
		等待(3, 无视条件);
		停止镜头(事件玩家);
		开始镜头(事件玩家, 矢量(7.515, 91.939, -155.421), 矢量(8.351, 90.586, -155.408), 0);
		等待(0.100, 无视条件);
		开始镜头(事件玩家, 矢量(3.119, 91.053, -148.258), 矢量(10.809, 78.595, -148.141), 0.700);
		等待(4, 无视条件);
		全局.K = 假;
		清除状态(事件玩家, 定身);
		全局.W = 假;
		停止镜头(事件玩家);
		事件玩家.X = 假;
	}
}

规则("automatically show next object")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.T == 真;
		事件玩家.U == 假;
	}

	动作
	{
		等待(3, 无视条件);
		如条件为“假”则中止;
		事件玩家.Q = 真;
		设置状态(事件玩家, 无, 定身, 5);
		开始镜头(事件玩家, 全局.C[事件玩家.F + 1], 全局.D[事件玩家.F + 1], 0);
		根据条件跳过(事件玩家.F != 0, 1);
		大字体信息(事件玩家, 字符串("{0} {1}", 字符串("寻找"), 字符串("对象")));
		根据条件跳过(事件玩家.F == 0, 1);
		大字体信息(事件玩家, 字符串("{0} {1}", 字符串("寻找"), 字符串("下一批对象")));
		等待(5, 无视条件);
		事件玩家.T = 假;
		停止镜头(事件玩家);
		事件玩家.Q = 假;
	}
}

规则("cancel auto preview")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.T == 真;
		事件玩家.Q == 真;
		事件玩家.Z == 0;
		事件玩家.X == 假;
	}

	动作
	{
		根据条件跳过(按钮被按下(事件玩家, 按钮(主要攻击模式)) != 真, 4);
		事件玩家.T = 假;
		清除状态(事件玩家, 定身);
		停止镜头(事件玩家);
		事件玩家.Q = 假;
		根据条件跳过(按钮被按下(事件玩家, 按钮(辅助攻击模式)) != 真, 4);
		事件玩家.T = 假;
		清除状态(事件玩家, 定身);
		停止镜头(事件玩家);
		事件玩家.Q = 假;
		根据条件跳过(按钮被按下(事件玩家, 按钮(跳跃)) != 真, 4);
		事件玩家.T = 假;
		清除状态(事件玩家, 定身);
		停止镜头(事件玩家);
		事件玩家.Q = 假;
		根据条件跳过(按钮被按下(事件玩家, 按钮(终极技能)) != 真, 4);
		事件玩家.T = 假;
		清除状态(事件玩家, 定身);
		停止镜头(事件玩家);
		事件玩家.Q = 假;
		根据条件跳过(按钮被按下(事件玩家, 按钮(技能2)) != 真, 4);
		事件玩家.T = 假;
		清除状态(事件玩家, 定身);
		停止镜头(事件玩家);
		事件玩家.Q = 假;
	}
}

规则("hint near the first object *")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		相距距离(事件玩家, 全局.D[1]) <= 5;
		事件玩家.F == 0;
	}

	动作
	{
		小字体信息(事件玩家, 字符串("{0} {1} {2}", 字符串("互动"), 字符串("{0}！", 字符串("此处")), 字符串("({0})", 输入绑定字符串(按钮(互动)))));
	}
}

规则("message about right button")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.M == 真;
	}

	动作
	{
		等待(9, 无视条件);
		小字体信息(事件玩家, 字符串("{0} {1}", 字符串("{0} - {1}", 输入绑定字符串(按钮(辅助攻击模式)), 字符串("当前目标")), 图标字符串(眼睛)));
		事件玩家.M = 假;
	}
}

规则("message about running")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.R == 真;
	}

	动作
	{
		等待(8, 无视条件);
		小字体信息(事件玩家, 字符串("{0} {1}", 字符串("{0} - {1}", 自定义字符串("[Shift]"), 字符串("运行")), 图标字符串(箭矢)));
		事件玩家.R = 假;
	}
}

规则("message about flying")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.F == 全局.Y;
	}

	动作
	{
		等待(8, 无视条件);
		小字体信息(事件玩家, 字符串("{0} {1}", 字符串("{0} - {1}", 字符串("跳跃"), 字符串("飞行")), 图标字符串(光晕)));
		等待(30, 无视条件);
		如条件为“假”则中止;
		小字体信息(事件玩家, 字符串("{0} {1}", 字符串("{0} - {1}", 字符串("跳跃"), 字符串("飞行")), 图标字符串(光晕)));
		等待(30, 无视条件);
		如条件为“假”则中止;
		小字体信息(事件玩家, 字符串("{0} {1}", 字符串("{0} - {1}", 字符串("跳跃"), 字符串("飞行")), 图标字符串(光晕)));
		等待(30, 无视条件);
		如条件为“假”则中止;
		小字体信息(事件玩家, 字符串("{0} {1}", 字符串("{0} - {1}", 字符串("跳跃"), 字符串("飞行")), 图标字符串(光晕)));
		等待(30, 无视条件);
		如条件为“假”则中止;
		小字体信息(事件玩家, 字符串("{0} {1}", 字符串("{0} - {1}", 字符串("跳跃"), 字符串("飞行")), 图标字符串(光晕)));
	}
}

规则("player left game")
{
	事件
	{
		玩家离开比赛;
		双方;
		全部;
	}

	动作
	{
		全局.K = 假;
		消除效果(事件玩家.E[1]);
		消除效果(事件玩家.E[2]);
		消除效果(事件玩家.E[3]);
		消除效果(事件玩家.E[4]);
		消除效果(事件玩家.E[5]);
		消除效果(事件玩家.E[6]);
		消除效果(事件玩家.E[7]);
		消除效果(事件玩家.E[8]);
		根据条件跳过(全局.L[1] != 事件玩家, 1);
		所有玩家(所有队伍).K = 3;
		根据条件跳过(全局.L[2] != 事件玩家, 1);
		所有玩家(所有队伍).K = 3;
		根据条件跳过(全局.L[3] != 事件玩家, 1);
		所有玩家(所有队伍).K = 3;
		设置慢动作(100);
		消除HUD文本(事件玩家.AA);
	}
}

规则("speed upgrade")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.U == 真;
		事件玩家.F != 全局.Y;
		事件玩家.F != 全局.O;
	}

	动作
	{
		播放效果(事件玩家, 环状爆炸, 颜色(天蓝色), 全局.D[事件玩家.F], 6);
		创建光束效果(事件玩家, 有益光束, 全局.D[事件玩家.F], 事件玩家, 颜色(天蓝色), 可见，位置和半径);
		事件玩家.E[1] = 最后创建的实体;
		创建效果(事件玩家, 能量声音, 颜色(白色), 事件玩家, 30, 可见，位置和半径);
		事件玩家.E[2] = 最后创建的实体;
		根据条件跳过(事件玩家.S > 410, 1);
		事件玩家.S += 全局.V;
		等待(1, 无视条件);
		消除效果(事件玩家.E[1]);
		消除效果(事件玩家.E[2]);
		小字体信息(事件玩家, 字符串("{0} {1}", 图标字符串(箭头：向上), 字符串("{0}！", 字符串("等级提升"))));
		大字体信息(事件玩家, 字符串("{0} {1} {2}", 字符串("速度"), 字符串("{0}！", 字符串("升级")), 图标字符串(箭矢)));
		等待(1, 无视条件);
		事件玩家.U = 假;
		根据条件跳过(事件玩家.O == 真, 1);
		事件玩家.T = 真;
		根据条件跳过(事件玩家.O == 假, 1);
		事件玩家.O = 假;
		事件玩家.R = 真;
	}
}

规则("flying upgrade")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.U == 真;
		事件玩家.F == 全局.Y;
	}

	动作
	{
		播放效果(事件玩家, 环状爆炸, 颜色(亮紫色), 全局.D[事件玩家.F], 7);
		创建光束效果(事件玩家, 有益光束, 全局.D[事件玩家.F], 事件玩家, 颜色(橙色), 可见，位置和半径);
		事件玩家.E[1] = 最后创建的实体;
		创建效果(事件玩家, 能量声音, 颜色(白色), 事件玩家, 30, 可见，位置和半径);
		事件玩家.E[2] = 最后创建的实体;
		事件玩家.Y = 真;
		等待(1, 无视条件);
		消除效果(事件玩家.E[1]);
		消除效果(事件玩家.E[2]);
		小字体信息(事件玩家, 字符串("{0} {1}", 图标字符串(箭头：向上), 字符串("{0}！", 字符串("等级提升"))));
		大字体信息(事件玩家, 字符串("{0} {1} {2}", 字符串("飞行"), 字符串("{0}！", 字符串("升级")), 图标字符串(光晕)));
		等待(1, 无视条件);
		事件玩家.U = 假;
		根据条件跳过(事件玩家.O == 真, 1);
		事件玩家.T = 真;
		根据条件跳过(事件玩家.O == 假, 1);
		事件玩家.O = 假;
	}
}

规则("rating")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.R[1] == 真;
	}

	动作
	{
		根据条件跳过(全局.R[2] < 1, 4);
		根据条件跳过(全局.R[3] >= 1, 3);
		创建HUD文本(所有玩家(所有队伍), 无, 无, 字符串("{0} {1}", 字符串("最佳"), 字符串("{0}:", 字符串("玩家"))), 右边, 0, 颜色(白色), 颜色(白色), 颜色(橙色), 可见和字符串, 默认可见度);
		创建HUD文本(所有玩家(所有队伍), 无, 无, 字符串("{0} {1} {2}", 英雄图标字符串(所用英雄(全局.L[1])), 全局.L[1], 字符串("{0} / {1}", 全局.L[1].F, 全局.O)), 右边, 1, 颜色(白色),
			颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		全局.R[3] = 1;
		根据条件跳过(全局.R[2] < 2, 3);
		根据条件跳过(全局.R[3] >= 2, 2);
		创建HUD文本(所有玩家(所有队伍), 无, 无, 字符串("{0} {1} {2}", 英雄图标字符串(所用英雄(全局.L[2])), 全局.L[2], 字符串("{0} / {1}", 全局.L[2].F, 全局.O)), 右边, 2, 颜色(白色),
			颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		全局.R[3] = 2;
		根据条件跳过(全局.R[2] != 3, 3);
		根据条件跳过(全局.R[3] == 3, 2);
		创建HUD文本(所有玩家(所有队伍), 无, 无, 字符串("{0} {1} {2}", 英雄图标字符串(所用英雄(全局.L[3])), 全局.L[3], 字符串("{0} / {1}", 全局.L[3].F, 全局.O)), 右边, 3, 颜色(白色),
			颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		全局.R[3] = 3;
		等待(1, 无视条件);
		根据条件循环(全局.R[2] > 全局.R[3]);
		全局.R[1] = 假;
	}
}

规则("rating update")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.K > 0;
	}

	动作
	{
		根据条件跳过(全局.L[1] != 事件玩家, 2);
		事件玩家.K = 0;
		中止;
		根据条件跳过(全局.L[2] != 事件玩家, 5);
		根据条件跳过(事件玩家.F <= 全局.L[1].F, 4);
		全局.L[2] = 全局.L[1];
		全局.L[1] = 事件玩家;
		事件玩家.K = 0;
		中止;
		根据条件跳过(全局.L[3] != 事件玩家, 3);
		根据条件跳过(事件玩家.F <= 全局.L[2].F, 2);
		全局.L[3] = 全局.L[2];
		全局.L[2] = 事件玩家;
		根据条件跳过(全局.L[1] == 事件玩家, 4);
		根据条件跳过(全局.L[2] == 事件玩家, 3);
		根据条件跳过(全局.L[3] == 事件玩家, 2);
		根据条件跳过(事件玩家.F <= 全局.L[3].F, 1);
		全局.L[3] = 事件玩家;
		等待(0.050, 无视条件);
		事件玩家.K -= 1;
		如条件为”真“则循环;
	}
}

规则("search time")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.W == 假;
		事件玩家.G > 0;
	}

	动作
	{
		等待(30, 无视条件);
		事件玩家.G -= 1;
		如条件为”真“则循环;
	}
}

规则("message about previous objects")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.F >= 10;
	}

	动作
	{
		等待(25, 无视条件);
		小字体信息(事件玩家, 字符串("{0} {1}", 字符串("{0} = {1}", 字符串("{0} + {1}", 输入绑定字符串(按钮(辅助攻击模式)), 输入绑定字符串(按钮(主要攻击模式))), 字符串("对象")), 图标字符串(回收)));
	}
}

规则("graphic settings warning 1 *")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.F == 全局.AA;
	}

	动作
	{
		等待(3, 无视条件);
		如条件为“假”则中止;
		消除HUD文本(事件玩家.AA);
		等待(0.250, 无视条件);
		创建HUD文本(事件玩家, 图标字符串(眼睛), 自定义字符串("Set medium or higher model detail settings to see all objects"), 自定义字符串(
			"Options > Video > Graphics quality > Advanced > Model Detail"), 顶部, 1, 颜色(橙色), 颜色(白色), 颜色(橙色), 字符串, 默认可见度);
		事件玩家.AA = 上一个文本ID;
	}
}

规则("graphic settings warning 2 *")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.F == 全局.AA + 1;
	}

	动作
	{
		消除HUD文本(事件玩家.AA);
	}
}